---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html">Modelling a Type Theory in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="195563859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195563859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195563859">(Apr 28 2020 at 13:30)</a>:</h4>
<p>My current inductive definition of a term can produce ill-formed terms, for example if <code>A : type</code> is a type that is not <code>Ω</code> , then <code>all A (var 0 Ω)</code> is trying to bind an <code>Ω</code> variable to a <code>A</code> type binder.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">One</span>
<span class="kn">infix</span> <span class="bp">`××`</span> <span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">prefix</span> <span class="err">𝒫</span> <span class="o">:</span><span class="mi">101</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
</code></pre></div>


<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an <code>all A φ</code> expression  if <code>φ</code> has only <code>var 0 A</code> and no <code>var 0 B</code>).</p>
<p>My next best idea is introducing the context on terms which is a mapping of free variables to types. Here's my start on that, though I am not that familiar with using <code>fin</code>. Should I use array, vector, list? Or is there a more direct approach to only creating well-defined terms?</p>



<a name="195564055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195564055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195564055">(Apr 28 2020 at 13:31)</a>:</h4>
<p>I guess what I would like to be able to say is that a variable can be any term, and it's really only defined by its number, and when we bind it to a binder, it then has an associated type.</p>



<a name="195564501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195564501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195564501">(Apr 28 2020 at 13:34)</a>:</h4>
<blockquote>
<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an all A φ expression if φ has only var 0 A and no var 0 B).</p>
</blockquote>
<p>You can, but it's a pain because you are still in the middle of the definition so you can't easily use recursive functions at the same time</p>



<a name="195564583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195564583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195564583">(Apr 28 2020 at 13:34)</a>:</h4>
<p>I would recommend keeping the term syntax as context free as possible, and have a well typing condition afterward that can have whatever dependencies it wants</p>



<a name="195565429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195565429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195565429">(Apr 28 2020 at 13:41)</a>:</h4>
<p>Hmm okay I'll take your advice. I was looking at flypitch documentation and they seem to do without a well-formedness predicate. Is that just because their terms are all the same type?</p>



<a name="195565908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195565908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195565908">(Apr 28 2020 at 13:45)</a>:</h4>
<p>It's easier for them because it's only one type, yes. You end up having to carry around a lot of "type state" in real type theories, and it becomes hard to get all the definitional equalities you want</p>



<a name="195566085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195566085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195566085">(Apr 28 2020 at 13:46)</a>:</h4>
<p>But they have a clearly distinct step for proofs, which I think should be the analogue of type checking for you</p>



<a name="195566880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195566880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195566880">(Apr 28 2020 at 13:52)</a>:</h4>
<p>Sorry what step are you referring to?</p>



<a name="195567152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567152">(Apr 28 2020 at 13:54)</a>:</h4>
<p>step in the construction</p>



<a name="195567199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567199">(Apr 28 2020 at 13:54)</a>:</h4>
<p>I would separate the grammar from the syntax rules</p>



<a name="195567247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567247">(Apr 28 2020 at 13:55)</a>:</h4>
<p>If you want terms that embed typing information, so that only well-typed terms can be constructed, the usual approach is to index it not only by a type, but also by a context containing the types of free variables. Thus, you would have something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Fun</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">type</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var0</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">var</span> <span class="o">[</span><span class="n">α</span><span class="o">]</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">varsucc</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">var</span> <span class="o">(</span><span class="n">β</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">β</span>

<span class="c1">-- This is the simply-typed lambda calculus with a unit type and products.</span>
<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">α</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">Fun</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">Prod</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">unit</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">One</span>
</code></pre></div>


<p>This approach works fine and makes the development a little easier if (a) you don't have dependencies in your types (but I guess your <code>all</code> and <code>ex</code> are supposed to be quantifiers?) and (b) Lean properly supports indexed families (which I don't know). Mario's suggested approach -- keeping the syntax simple and putting a type predicate on top -- requires some additional boilerplate, but has the distinct advantage that it'll work regardless of what object theory you want to encode.</p>



<a name="195567396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567396">(Apr 28 2020 at 13:56)</a>:</h4>
<p>Lean's support for indexed families is fine</p>



<a name="195567406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567406">(Apr 28 2020 at 13:56)</a>:</h4>
<p>mutual is not fine</p>



<a name="195567538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567538">(Apr 28 2020 at 13:57)</a>:</h4>
<p>While I agree with you up to a point, I find that once you get down to proving theorems about these terms, you might want to e.g. prove something by induction on the context from the other end, and then it enters DTT hell</p>



<a name="195568076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568076">(Apr 28 2020 at 14:01)</a>:</h4>
<p>Yeah I'm a little turned off by the fact that my sequents will also have a context, and I'd have to marry them properly.</p>



<a name="195568381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568381">(Apr 28 2020 at 14:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I can see how that proof might be tricky. I've also become more skeptical of intrinsically typed syntax lately -- it's nice when it works, but when it breaks, it sure breaks.</p>



<a name="195568805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568805">(Apr 28 2020 at 14:06)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span> I don't know exactly what your sequents look like, but you will probably have two contexts, one for the types and one for the hypotheses (as is customary in HOL)</p>



<a name="195568843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568843">(Apr 28 2020 at 14:06)</a>:</h4>
<p>the hypotheses are nondependent so it's not such a big deal</p>



<a name="195569469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195569469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195569469">(Apr 28 2020 at 14:11)</a>:</h4>
<p>The hypotheses in my sequents are just a single <code>term Ω</code>.</p>



<a name="195574629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195574629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195574629">(Apr 28 2020 at 14:46)</a>:</h4>
<p>I'm having a little trouble stating the well-foundedness condition - am I on the right track?</p>
<p>It also seems like there's two level's of well-foundedness - that every bound variable has the correct type, and that any free variables can be bound to a single type.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">v</span><span class="bp">=</span><span class="n">n</span> <span class="bp">∧</span> <span class="n">Z</span><span class="bp">=</span><span class="n">A</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="n">top</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="n">bot</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">q</span>

<span class="n">def</span> <span class="n">well_formed</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="195574849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195574849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195574849">(Apr 28 2020 at 14:48)</a>:</h4>
<p>Do you mean <code>v = n -&gt; Z = A</code>? in other words saying that all occurrences of variable <code>n</code> are used at type <code>Z</code>?</p>



<a name="195575132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195575132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195575132">(Apr 28 2020 at 14:50)</a>:</h4>
<p>Ah yes</p>



<a name="195576900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195576900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195576900">(Apr 28 2020 at 15:02)</a>:</h4>
<p>I think it isn't the traditional presentation, but I'm pretty sure it is better to only have the notion "<code>φ : term A</code> is well-formed in <code>Γ : context</code>"</p>



<a name="195577003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195577003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195577003">(Apr 28 2020 at 15:03)</a>:</h4>
<p>rather than having only <code>term</code>s with no context and trying to guess the free variables and their types by inspecting the term</p>



<a name="195665323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195665323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anton Lorenzen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195665323">(Apr 29 2020 at 06:24)</a>:</h4>
<p>I started working on a calculus of constructions in Lean à few weeks ago, maybe you find it helpful: <a href="https://github.com/anfelor/coc-lean" title="https://github.com/anfelor/coc-lean">https://github.com/anfelor/coc-lean</a> Feel free to contact me if you have any questions.</p>



<a name="195698879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195698879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195698879">(Apr 29 2020 at 12:14)</a>:</h4>
<p>Awesome! thanks I'll take a look</p>



<a name="195709049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709049">(Apr 29 2020 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> WF means the types of the free variables of <code>term A</code> match the context.</p>



<a name="195709072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709072">(Apr 29 2020 at 13:34)</a>:</h4>
<p>More specifically?</p>



<a name="195709096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709096">(Apr 29 2020 at 13:34)</a>:</h4>
<p>What is the English translation of what you wrote?</p>



<a name="195709139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709139">(Apr 29 2020 at 13:34)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">WF</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="kn">context</span> <span class="bp">→</span>  <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span> <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
</code></pre></div>



<a name="195709173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709173">(Apr 29 2020 at 13:35)</a>:</h4>
<p>Hang on let me paste my term definition</p>



<a name="195709219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709219">(Apr 29 2020 at 13:35)</a>:</h4>
<p>Also that WF definition is incomplete, there are more terms but they are less interesting to WF</p>



<a name="195709304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709304">(Apr 29 2020 at 13:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195563859" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195563859">said</a>:</p>
<blockquote>
<p>My current inductive definition of a term can produce ill-formed terms, for example if <code>A : type</code> is a type that is not <code>Ω</code> , then <code>all A (var 0 Ω)</code> is trying to bind an <code>Ω</code> variable to a <code>A</code> type binder.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">One</span>
<span class="kn">infix</span> <span class="bp">`××`</span> <span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">prefix</span> <span class="err">𝒫</span> <span class="o">:</span><span class="mi">101</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
</code></pre></div>


<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an <code>all A φ</code> expression  if <code>φ</code> has only <code>var 0 A</code> and no <code>var 0 B</code>).</p>
<p>My next best idea is introducing the context on terms which is a mapping of free variables to types. Here's my start on that, though I am not that familiar with using <code>fin</code>. Should I use array, vector, list? Or is there a more direct approach to only creating well-defined terms?</p>
</blockquote>



<a name="195709460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709460">(Apr 29 2020 at 13:37)</a>:</h4>
<p>Say the context is empty but you have a variable. Is that well-formed?</p>



<a name="195709467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709467">(Apr 29 2020 at 13:37)</a>:</h4>
<p>Ah sorry I just realised it was you I was discussing this with earlier. I'm not sure specifically what I should clarify more about <code>WF</code>, given the definition there</p>



<a name="195709613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709613">(Apr 29 2020 at 13:38)</a>:</h4>
<p>Inductively defined propositions:</p>
<ol>
<li><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">TPIL</a></li>
<li><a href="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226" title="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226">Codewars: Multiples of 3, you say?</a></li>
<li><a href="https://www.codewars.com/kata/5e59626530e9d00028bbe569" title="https://www.codewars.com/kata/5e59626530e9d00028bbe569">Codewars: Times Three, Plus Five</a></li>
</ol>



<a name="195709755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709755">(Apr 29 2020 at 13:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Yeah I thought about that and I'm not sure how to fix that. For my use I think I can just allow those terms to exist?</p>



<a name="195710127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710127">(Apr 29 2020 at 13:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Even though I use the keyword <code>def</code>, I'm still defining it inductively on the inductive type <code>term A</code> right?</p>



<a name="195710205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710205">(Apr 29 2020 at 13:42)</a>:</h4>
<p>yes, but <code>inductive</code> might be better for this case</p>



<a name="195710496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710496">(Apr 29 2020 at 13:44)</a>:</h4>
<p>Hmm, is that because it allows me to name the axioms for well-formedness on each of the term A's? I'm not sure I see the difference/benefit.</p>



<a name="195710600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710600">(Apr 29 2020 at 13:45)</a>:</h4>
<p>it allows you to "inject" things</p>



<a name="195710631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710631">(Apr 29 2020 at 13:45)</a>:</h4>
<p>and you don't need to go through every case</p>



<a name="195710684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710684">(Apr 29 2020 at 13:46)</a>:</h4>
<p>(cases you haven't gone through are automatically "false")</p>



<a name="195711420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195711420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195711420">(Apr 29 2020 at 13:50)</a>:</h4>
<p>I'm pretty sure Reid is hinting at this, but more directly: you don't want <code>∀ a : n &lt; Γ.length, (Γ.nth_le n a = A)</code>, you want <code>∃ a : n &lt; Γ.length, (Γ.nth_le n a = A)</code>. The former says that either the type is correct or it's out of range, while the latter says that it is in range and the type is correct. Better yet, skip the hypothesis and use <code>Γ.nth n = some A</code></p>



<a name="195711855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195711855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195711855">(Apr 29 2020 at 13:53)</a>:</h4>
<p>Beautiful, thank you.</p>



<a name="195713258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195713258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195713258">(Apr 29 2020 at 14:01)</a>:</h4>
<p>Here's what I've got now (it compiles). I'm still not understanding the suggestion to use <code>inductive</code>. </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">WF</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="kn">context</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span> <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="err">⁎</span> <span class="err">Γ</span>          <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">top</span> <span class="err">Γ</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">bot</span> <span class="err">Γ</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="err">Γ</span> <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">a</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">b</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">Γ</span>    <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">a</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">α</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">p</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">q</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">p</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">q</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">p</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">q</span> <span class="err">Γ</span>
</code></pre></div>



<a name="195715381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195715381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195715381">(Apr 29 2020 at 14:13)</a>:</h4>
<p>Surely if I use inductive, I can only talking about creating un-named elements of <code>Prop</code>, and I can't actually define which proposition they are right?</p>



<a name="195715636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195715636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195715636">(Apr 29 2020 at 14:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195709613" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195709613">said</a>:</p>
<blockquote>
<p>Inductively defined propositions:</p>
<ol>
<li><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">TPIL</a></li>
<li><a href="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226" title="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226">Codewars: Multiples of 3, you say?</a></li>
<li><a href="https://www.codewars.com/kata/5e59626530e9d00028bbe569" title="https://www.codewars.com/kata/5e59626530e9d00028bbe569">Codewars: Times Three, Plus Five</a></li>
</ol>
</blockquote>



<a name="195715726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195715726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195715726">(Apr 29 2020 at 14:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195710496" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195710496">said</a>:</p>
<blockquote>
<p>Hmm, is that because it allows me to name the axioms for well-formedness on each of the term A's? I'm not sure I see the difference/benefit.</p>
</blockquote>
<p>Benefits of an inductive type for well-formedness (or any similar predicate):</p>
<ul>
<li>You can do "rule induction", i.e. induction on the derivation of a well-formedness proof. If you define the predicate by recursion over terms instead, you can't directly eliminate a hypothesis <code>WF t</code>; you'll have to eliminate <code>t</code> first until the <code>WF</code> reduces. (In your case, there's little difference in this regard because the structure of your well-formedness predicate is very close to the structure of your terms.)</li>
<li>Recursive definitions must pass the termination checker; inductive definitions are generally more liberal. (Also not a concern in your case because you don't need a complicated recursive structure.)</li>
<li>Lean may make the recursive definition extra cumbersome to use because it's picky about reducing definitional equalities (though that might not be a problem in practice; I haven't experimented with this). Maybe mark the <code>WF</code> def as <code>@[reducible]</code>.</li>
</ul>
<p>Benefits of a recursive definition of well-formedness:</p>
<ul>
<li>It may be a little clearer what's going on I guess?</li>
</ul>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195715381" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195715381">said</a>:</p>
<blockquote>
<p>Surely if I use inductive, I can only talking about creating un-named elements of <code>Prop</code>, and I can't actually define which proposition they are right?</p>
</blockquote>
<p>Sorry, I don't understand your concern; could you rephrase?</p>



<a name="195717605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195717605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195717605">(Apr 29 2020 at 14:28)</a>:</h4>
<p>Hmm, I'm feeling pretty confused. I definitely need to go back an practice more basic lean.</p>



<a name="195718293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718293">(Apr 29 2020 at 14:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span>  thanks for the resource, I think I understand it in that context but I'm struggling to translate to my case.</p>



<a name="195718415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718415">(Apr 29 2020 at 14:33)</a>:</h4>
<p>Think of it in terms of what rules build up well-formed formulas into bigger ones, rather than how do you break down a formula to check whether it is well-formed.</p>



<a name="195718440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718440">(Apr 29 2020 at 14:33)</a>:</h4>
<p>Actually, it's exactly like an inductive type except it's a proposition.</p>



<a name="195718538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718538">(Apr 29 2020 at 14:34)</a>:</h4>
<p>Hmm - aren't I then just redefining <code>term A</code>?</p>



<a name="195718580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718580">(Apr 29 2020 at 14:34)</a>:</h4>
<p>Basically, yes</p>



<a name="195718676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718676">(Apr 29 2020 at 14:35)</a>:</h4>
<p>But you still have <code>term</code> also, so you aren't restricted to only ever considering well-formed terms</p>



<a name="195718760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718760">(Apr 29 2020 at 14:35)</a>:</h4>
<p>Also, in general, you might have a more interesting notion of well-formedness which isn't directly defined by recursion on the term, but I think that doesn't happen here.</p>



<a name="195718852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718852">(Apr 29 2020 at 14:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195564583" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195564583">said</a>:</p>
<blockquote>
<p>I would recommend keeping the term syntax as context free as possible, and have a well typing condition afterward that can have whatever dependencies it wants</p>
</blockquote>
<p>This is the advice I am trying to follow at the moment</p>



<a name="195718913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718913">(Apr 29 2020 at 14:36)</a>:</h4>
<p>Both your recursive function and an inductive well-formedness predicate fall into this category, I think.</p>



<a name="195719093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195719093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195719093">(Apr 29 2020 at 14:37)</a>:</h4>
<p>I mean, your <code>WF</code> function also basically contains a complete definition of <code>term</code>, in the sense that all the constructors are listed</p>



<a name="195719203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195719203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195719203">(Apr 29 2020 at 14:38)</a>:</h4>
<p>Good point</p>



<a name="195719474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195719474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195719474">(Apr 29 2020 at 14:40)</a>:</h4>
<p>So are you suggesting keeping the inductive term, and making an inductive WF with a context, or put the context into the term from the start so every term is well-formed (by forcing the binders and var to follow the context)?</p>



<a name="195720456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195720456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195720456">(Apr 29 2020 at 14:47)</a>:</h4>
<p>Those are two options. Another is the recursive <code>WF</code> function you already have.<br>
The recursive <code>WF</code> function and the inductive well-formedness predicate are basically equivalent in terms of what you can express easily. (The main difference is that the inductive predicate gives you the ability to induct on the proof of well-formedness, but here it looks basically equivalent to inducting on the term itself; the recursive function is more like an algorithm for computing whether something is well-formed and it lets you directly prove, for example, that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>∧</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\varphi \wedge \psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span> is well-formed then the components <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span> are well-formed, which needs a case analysis if using the inductive predicate.)<br>
Putting the context into the term from the start is not really equivalent, since it means you only have the vocabulary to ever talk about well-formed terms.</p>



<a name="196264720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196264720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196264720">(May 05 2020 at 03:37)</a>:</h4>
<p>I'm going with the well-typed-from-the-start approach for now, and I've coming up with a <code>var</code> constructer which sandwiches a given type <code>A</code> between the context of terms of about to be bound <code>\Gamma</code> and those which will be bound after this variable, <code>\Delta</code>. To be clear, in any context, the type of the 0th de-bruijn index variable is at the head of the list-context.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
</code></pre></div>


<p>As the terms currently exist, to construct a big term inductively from smaller terms, you need to know the whole context of the big term to construct and use the variables of the small terms. Obviously this is unsustainable, so I think I need to create a function for modifying contexts. I don't think there's many restrictions on the kind of context modification you can do, which includes adding more context to the end of the context, lifting the context and inserting other context before it, and also any reordering of types in the existing context. Perhaps there's some general pattern there, but I'm struggling to even define a simple case. If I mention <code>A</code> more than once between then <code>|</code> and the <code>:=</code>, it tells me <code>A already appears in this pattern</code>. I understand why that's an error, but I'm not sure what I'm supposed to do instead. I haven't been able to write the other cases for similar reasons.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">add_junk</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">type</span><span class="o">),</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="n">β</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>



<a name="196293916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196293916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196293916">(May 05 2020 at 11:12)</a>:</h4>
<p>You should leave the first two arguments blank, they are inferred from the third</p>



<a name="196294018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196294018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196294018">(May 05 2020 at 11:14)</a>:</h4>
<p>Alternatively you should be able to put a dot before them like</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">add_junk</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">type</span><span class="o">),</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="n">β</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="bp">.</span><span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>


<p>and it will mark those positions as "inacessible" meaning that it won't try to split on the first argument and figure out why <code>list.append Γ (A::Δ)</code> is a constructor (because it's not)</p>



<a name="196297051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196297051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196297051">(May 05 2020 at 11:51)</a>:</h4>
<p>That results in this error</p>
<div class="codehilite"><pre><span></span><code><span class="n">equation</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">)</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">))</span> <span class="n">A</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="bp">.</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Δ</span><span class="o">))</span> <span class="n">β</span><span class="o">)</span> <span class="bp">.</span><span class="n">A</span>
</code></pre></div>



<a name="196297202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196297202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196297202">(May 05 2020 at 11:53)</a>:</h4>
<p>Also what is the . syntax called so I can find it in the documentation?</p>



<a name="196300768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300768">(May 05 2020 at 12:31)</a>:</h4>
<p>It's called an inaccessible pattern. It is almost never used in lean/mathlib because in basically every case you can use <code>_</code> instead</p>



<a name="196300838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300838">(May 05 2020 at 12:31)</a>:</h4>
<p>If you want to name the parameters, you should do so in the constructor <code>var Γ A Δ</code>, possibly using <code>@var more names Γ A Δ</code></p>



<a name="196300929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300929">(May 05 2020 at 12:32)</a>:</h4>
<p>Anyway, you've just hit DTT hell in that error there</p>



<a name="196300982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300982">(May 05 2020 at 12:32)</a>:</h4>
<p>You should definitely not have this constructor</p>
<div class="codehilite"><pre><span></span><code><span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="n">A</span>
</code></pre></div>


<p>because the term will usually not have this form</p>



<a name="196301015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301015">(May 05 2020 at 12:33)</a>:</h4>
<p>Instead you can use <code>| var (Γ A) : A \in Γ -&gt; term Γ A</code></p>



<a name="196301127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301127">(May 05 2020 at 12:34)</a>:</h4>
<p>But then how can I possibly tell which type in the context list my var is constructing?</p>



<a name="196301141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301141">(May 05 2020 at 12:34)</a>:</h4>
<p>or <code>| var {Γ i A} : list.nth Γ i = some A -&gt; term Γ A</code></p>



<a name="196301170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301170">(May 05 2020 at 12:34)</a>:</h4>
<p>that one gives you a de bruijn index</p>



<a name="196301243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301243">(May 05 2020 at 12:35)</a>:</h4>
<p>Am I not achieving the same thing by stacking a context below and a context above <code>A</code> in <code>var \Gamma A \Delta</code>?</p>



<a name="196301302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301302">(May 05 2020 at 12:36)</a>:</h4>
<p>"the same thing" up to equality but not up to defeq</p>



<a name="196301338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301338">(May 05 2020 at 12:36)</a>:</h4>
<p>and the reason defeq is coming up is because you have a dependent type</p>



<a name="196301376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301376">(May 05 2020 at 12:37)</a>:</h4>
<p>defeq meaning definitional equality?</p>



<a name="196301387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301387">(May 05 2020 at 12:37)</a>:</h4>
<p><code>term (list.append Γ (A :: list.append Δ β)) A</code> and <code>term (list.append (list.append Γ (A :: Δ)) β) A</code> are distinct types, so you have to insert a cast between them and this will make everything harder</p>



<a name="196301478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301478">(May 05 2020 at 12:38)</a>:</h4>
<p>(this is the issue I was predicting when I originally recommended to use a weakly typed <code>term</code> syntax + a well formedness judgment)</p>



<a name="196301480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301480">(May 05 2020 at 12:38)</a>:</h4>
<p>ooh that's odd, I would have expected them to reduce to the same thing by unwrapping the definition of list.append?</p>



<a name="196301493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301493">(May 05 2020 at 12:38)</a>:</h4>
<p>You can't because <code>Γ</code> is a variable</p>



<a name="196301521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301521">(May 05 2020 at 12:39)</a>:</h4>
<p>For every concrete term for <code>Γ</code> these two are defeq, but for variable <code>Γ</code> you have to prove it by induction</p>



<a name="196301562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301562">(May 05 2020 at 12:39)</a>:</h4>
<p>that's pretty interesting</p>



<a name="196301632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301632">(May 05 2020 at 12:40)</a>:</h4>
<p>Obviously you should use a difference list for your context <em>flees</em></p>



<a name="196301805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301805">(May 05 2020 at 12:42)</a>:</h4>
<p>You might have seen before I was trying to go with your original suggestion, but was struggling  to define the well-formedness predicate and was kinda lead back into well-typing it from the start.</p>



<a name="196301876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301876">(May 05 2020 at 12:43)</a>:</h4>
<p>The well formedness predicate can be done with either <code>inductive</code> or <code>def</code>. <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195713258" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195713258">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195713258</a> &lt;- this looks okay</p>



<a name="196301920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301920">(May 05 2020 at 12:43)</a>:</h4>
<p><code>inductive</code> gives you a bit more freedom to not be strictly recursive</p>



<a name="196302102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302102">(May 05 2020 at 12:45)</a>:</h4>
<p>it's also more natural when proving theorems by induction on well formed terms, so the sort of thing that the dependent type would give you</p>



<a name="196302198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302198">(May 05 2020 at 12:46)</a>:</h4>
<p>the <code>def</code> is what you would want for implementing a type checker, or a proof that the typing judgment is decidable</p>



<a name="196302262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302262">(May 05 2020 at 12:47)</a>:</h4>
<p>but you can have both versions and prove equivalence so there isn't a loss in picking one method over the other at first</p>



<a name="196302406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302406">(May 05 2020 at 12:48)</a>:</h4>
<p>I see the issues with using my non-defeq context-terms, but given your constructor<code> | var {Γ i A} : list.nth Γ i = some A -&gt; term Γ A</code>, would that suffer from similar issues?</p>



<a name="196302557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302557">(May 05 2020 at 12:49)</a>:</h4>
<p>that will solve the problem you have with unifying the context, because <code>var</code> can have any context, and the content is shifted to the hypothesis, which is a Prop and hence has no issues with defeq</p>



<a name="196302653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302653">(May 05 2020 at 12:50)</a>:</h4>
<p>your original <code>var</code> constructor only supports contexts of the form <code>Γ ++ A :: Δ</code></p>



<a name="196302878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302878">(May 05 2020 at 12:52)</a>:</h4>
<p>Yep, but given that improvement, am I naive to think that fixes everything and using a WF predicate on weakly-typed terms is overly complicated?</p>



<a name="196303010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196303010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196303010">(May 05 2020 at 12:54)</a>:</h4>
<p>With the inductive version you can set it up so that it looks almost the same. It's only about twice as long because you have two definitions instead of one (the terms, and the well formedness inductive type)</p>



<a name="196303088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196303088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196303088">(May 05 2020 at 12:54)</a>:</h4>
<p>but feel free to continue with dependent types, I've hopefully unstuck you on that issue and there are fixes or workarounds for most of the other problems that will arise</p>



<a name="196303162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196303162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196303162">(May 05 2020 at 12:55)</a>:</h4>
<p>I really appreciate the help in getting me started.</p>



<a name="196304258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196304258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196304258">(May 05 2020 at 13:04)</a>:</h4>
<p>Here's the inductive-ification of the <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/196264720" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/196264720">original dependent type</a>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>


<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="err">Γ</span><span class="o">))</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">all</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">all</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₂</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">prod</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₂</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">or</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
</code></pre></div>


<p>there is actually an algorithm to perform these sort of translations, although I took the liberty of using a nat for the variable and otherwise removing unnecessary arguments from <code>term</code>, which is not obvious to the straightforward algorithm.</p>



<a name="196305815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196305815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196305815">(May 05 2020 at 13:17)</a>:</h4>
<p>Wow that was definitely non-obvious to me that you could take the types off term's as well. From then on, as I understand, instead of talking about terms, you'd talk about proofs that terms are well-formed? (as if its the term itself)</p>



<a name="196305984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196305984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196305984">(May 05 2020 at 13:18)</a>:</h4>
<p>So a sequent is constructed from two WF's proofs, rather than from two terms?</p>



<a name="196306020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196306020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196306020">(May 05 2020 at 13:18)</a>:</h4>
<p>No, a sequent is still just two terms</p>



<a name="196306072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196306072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196306072">(May 05 2020 at 13:19)</a>:</h4>
<p>But the inductive defining the proof relation will contain WF hypotheses</p>



<a name="196307014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196307014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196307014">(May 05 2020 at 13:26)</a>:</h4>
<p>Ah, I just wrote down the type and realised of course you must introduce the term objects themselves to talk about their WF'ness<br>
<code>inductive proof : Π {Γ:context} {φ: term} {ψ : term}, WF Γ φ Ω  → WF Γ ψ Ω → Type</code></p>



<a name="196307359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196307359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196307359">(May 05 2020 at 13:29)</a>:</h4>
<p>In what sense did you mean a proof/sequent is just two terms?</p>



<a name="196307375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196307375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196307375">(May 05 2020 at 13:29)</a>:</h4>
<p>You can write the <code>proof : context -&gt; term -&gt; term -&gt; Prop</code> relation such that <code>proof Γ φ ψ -&gt;  WF Γ φ Ω  /\ WF Γ ψ Ω</code>, although I would actually suggest <code>WF Γ φ Ω -&gt; proof Γ φ ψ -&gt;  WF Γ ψ Ω</code> instead</p>



<a name="198401551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198401551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198401551">(May 22 2020 at 02:48)</a>:</h4>
<p>Been working on this lately and oh boy - I need to understand tactics better.</p>



<a name="198401743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198401743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198401743">(May 22 2020 at 02:53)</a>:</h4>
<p>What tactics do you you expect to be relevant to me? So far I'm familiar with the basic ones (apply, exact, cases, induction, simp). Since I have my own equality - would I need to write my own version of rewrite?</p>



<a name="198402030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402030">(May 22 2020 at 03:01)</a>:</h4>
<p>Also with those tactics - I'm finding that whenever I apply cases or induction, Lean comes up with really ugly local-context names for each case, and I need to manually name up to 10 things manually so they have sensible names. This is the current state of my tactic proof - any suggestions for controlling the growth here?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">proof_WF</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="n">ψ</span><span class="o">:</span> <span class="n">term</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">ψ</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">wf_φ</span> <span class="n">prf_φ_ψ</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">prf_φ_ψ</span><span class="o">,</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">axm</span> <span class="o">:</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">abs</span> <span class="o">:</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">vac</span> <span class="o">:</span> <span class="o">{</span><span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">cut</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="n">prf_PQ</span> <span class="n">prf_QR</span> <span class="n">h₁</span> <span class="n">h₂</span>
    <span class="o">{</span><span class="n">exact</span> <span class="n">h₂</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">wf_φ</span><span class="o">)},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_intro</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">prf_pq</span> <span class="n">prf_pr</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_left</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF_and_left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">wf_φ</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_right</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF_and_right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">wf_φ</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">or_intro</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">prf_pr</span> <span class="n">prf_qr</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF_or_left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₃</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">A</span> <span class="n">h</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">type</span><span class="o">,</span> <span class="n">exact</span> <span class="n">A</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">type</span><span class="o">,</span> <span class="n">exact</span> <span class="n">A</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span><span class="o">,</span>
        <span class="n">assumption</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span> <span class="o">:</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span> <span class="o">:</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span> <span class="o">:</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">wf_p</span> <span class="n">wf_q</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
          <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">wf_φ</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₂</span> <span class="n">wf_φ</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">wf_p</span> <span class="n">wf_q</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
          <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">wf_φ</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₂</span> <span class="n">wf_φ</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">wf_p</span> <span class="n">wf_q</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
          <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">wf_φ</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₂</span> <span class="n">wf_φ</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">n</span> <span class="n">A</span> <span class="n">h₁</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
        <span class="n">repeat</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
    <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="198402144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402144">(May 22 2020 at 03:05)</a>:</h4>
<p>can you make that a <a href="https://github.com/leanprover-community/mathlib/wiki/Minimum-Working-Example-&#40;MWE&#41;">#mwe</a>?</p>



<a name="198402176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402176">(May 22 2020 at 03:05)</a>:</h4>
<p>(I'm not asking you to remove anything, just add imports and definitions so that if I copy-paste it into my VSCode it compiles)</p>



<a name="198402550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402550">(May 22 2020 at 03:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/198402030">said</a>:</p>
<blockquote>
<p>Also with those tactics - I'm finding that whenever I apply cases or induction, Lean comes up with really ugly local-context names for each case, and I need to manually name up to 10 things manually so they have sensible names.</p>
</blockquote>
<p>I'm currently working on an alternative <code>induction</code> tactic that would hopefully give you better names (among other things). It's not quite ready yet though. For now, manual renaming is your best option.</p>
<p>In general, your proof looks okay to me. You could probably automate/prettify some of this stuff, but that's a rabbit hole and a half. I'd recommend you just slog through it; these sorts of proofs are always lengthy.</p>



<a name="198402660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402660">(May 22 2020 at 03:17)</a>:</h4>
<p>in this part</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">cut</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="n">prf_PQ</span> <span class="n">prf_QR</span> <span class="n">h₁</span> <span class="n">h₂</span>
    <span class="o">{</span><span class="n">exact</span> <span class="n">h₂</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">wf_φ</span><span class="o">)},</span>
</code></pre></div>


<p>does it instead work to write the following? (I could answer this question myself if i had a mwe)</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">cut</span> <span class="o">:</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span> <span class="n">h₂</span>
    <span class="o">{</span><span class="n">exact</span> <span class="n">h₂</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">wf_φ</span><span class="o">)},</span>
</code></pre></div>



<a name="198402726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402726">(May 22 2020 at 03:19)</a>:</h4>
<p>Only issue is the mwe is pretty large. I'll attach the file for now - basically everything is needed.</p>
<p><a href="/user_uploads/3121/nVDisP0SERw2ocpHxljnmtSx/TL_zulip.lean">TL_zulip.lean</a></p>



<a name="198402782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402782">(May 22 2020 at 03:20)</a>:</h4>
<p>why not paste it into a message?</p>



<a name="198402786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402786">(May 22 2020 at 03:20)</a>:</h4>
<p>that's probably much easier for both of us</p>



<a name="198402800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402800">(May 22 2020 at 03:21)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">One</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">prefix</span> <span class="err">𝒫</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>



<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">0</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">1</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">2</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">3</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">4</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">5</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">5</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">6</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">6</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">7</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">7</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">8</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">8</span>
<span class="kn">notation</span> <span class="bp">`&lt;</span><span class="mi">9</span><span class="bp">&gt;`</span> <span class="o">:=</span> <span class="n">var</span> <span class="mi">9</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="n">def</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">⟹</span> <span class="err">⊥</span>
<span class="kn">prefix</span> <span class="bp">`</span><span class="err">∼</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">not</span> <span class="c1">-- input \~, the ASCII character ~ has too low precedence</span>

<span class="n">def</span> <span class="n">biimp</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">biimp</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span><span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">φ</span>

<span class="kn">prefix</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">all</span>
<span class="kn">prefix</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex</span>

<span class="n">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="err">∈</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">≃</span><span class="bp">`</span> <span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">eq</span>

<span class="n">def</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="err">⟦</span><span class="n">a</span> <span class="err">≃</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span><span class="err">⟧</span>

<span class="n">def</span> <span class="n">ex_unique</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∃</span><span class="err">&#39;</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span> <span class="err">≃</span> <span class="n">singleton</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">3</span><span class="bp">&gt;</span><span class="o">)</span>
<span class="kn">prefix</span> <span class="bp">`∃!</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex_unique</span>

<span class="n">def</span> <span class="n">subseteq</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span>
<span class="kn">infix</span> <span class="err">⊆</span> <span class="o">:=</span> <span class="n">subseteq</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">n</span> <span class="n">A</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">a</span> <span class="n">α</span> <span class="n">A</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">α</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">b</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>

<span class="kn">variable</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span>
<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span>
<span class="kn">variables</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span>

<span class="kn">lemma</span> <span class="n">WF_and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_and_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_or_left</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_or_right</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_imp_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_imp_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_prod_left</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_prod_right</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">b</span> <span class="n">B</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_comp_elim</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span><span class="o">)</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_all_elim</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">WF_ex_elim</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>

<span class="n">def</span> <span class="n">lift</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">k</span> <span class="n">star</span>       <span class="o">:=</span> <span class="n">star</span>
<span class="bp">|</span> <span class="n">k</span> <span class="n">top</span>        <span class="o">:=</span> <span class="n">top</span>
<span class="bp">|</span> <span class="n">k</span> <span class="n">bot</span>        <span class="o">:=</span> <span class="n">bot</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>         <span class="o">:=</span>    <span class="err">⟦</span><span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prod</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">b</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">subst_nth</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="n">star</span>       <span class="o">:=</span> <span class="n">star</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="n">top</span>        <span class="o">:=</span> <span class="n">top</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="n">bot</span>        <span class="o">:=</span> <span class="n">bot</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">b</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>        <span class="o">:=</span>     <span class="err">⟦</span><span class="n">subst_nth</span> <span class="o">(</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="o">(</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="o">(</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prod</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">b</span> <span class="n">n</span> <span class="n">c</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">subst</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subst_nth</span> <span class="n">b</span> <span class="mi">0</span>


<span class="kn">inductive</span> <span class="k">proof</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">axm</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">vac</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>
<span class="bp">|</span> <span class="n">abs</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">cut</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="n">γ</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">ψ</span> <span class="n">γ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">γ</span>
<span class="bp">|</span> <span class="n">and_intro</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and_left</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">and_right</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">or_intro</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">or_left</span>    <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">or_right</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">imp_to_and</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">and_to_imp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add_var</span>    <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">ψ</span>

<span class="bp">|</span> <span class="n">apply</span>    <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="n">b</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span>
    <span class="n">WF</span> <span class="err">Γ</span> <span class="n">b</span> <span class="n">B</span>
    <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">ψ</span>
    <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">subst</span> <span class="n">b</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">subst</span> <span class="n">b</span> <span class="n">ψ</span><span class="o">)</span>

<span class="bp">|</span> <span class="n">all_elim</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">all_intro</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex_elim</span>    <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">ex_intro</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>

<span class="bp">|</span> <span class="n">comp</span>       <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>   <span class="o">:</span>
    <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span>
    <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="err">⊤</span>
      <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="err">∈</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="n">subst</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="n">φ</span><span class="o">))</span>

<span class="bp">|</span> <span class="n">ext</span>                  <span class="o">:</span>
    <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span>
      <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="err">∈</span> <span class="bp">&lt;</span><span class="mi">2</span><span class="bp">&gt;</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="err">∈</span> <span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span><span class="o">))</span> <span class="err">⟹</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span>

<span class="bp">|</span> <span class="n">prop_ext</span>             <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span> <span class="err">⇔</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">star_unique</span>          <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="err">⁎</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">prod_exists_rep</span>      <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">2</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="o">(</span><span class="n">prod</span> <span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">))</span>

<span class="bp">|</span> <span class="n">prod_distinct_rep</span>    <span class="o">:</span>
    <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span>
      <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">prod</span> <span class="bp">&lt;</span><span class="mi">3</span><span class="bp">&gt;</span> <span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="n">prod</span> <span class="bp">&lt;</span><span class="mi">2</span><span class="bp">&gt;</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="bp">&lt;</span><span class="mi">3</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="bp">&lt;</span><span class="mi">2</span><span class="bp">&gt;</span> <span class="err">⋀</span> <span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span> <span class="err">≃</span> <span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">⊤</span> <span class="o">:=</span> <span class="k">proof</span><span class="bp">.</span><span class="n">axm</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span>


<span class="kn">lemma</span> <span class="n">proof_WF</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="n">ψ</span><span class="o">:</span> <span class="n">term</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">ψ</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">wf_φ</span> <span class="n">prf_φ_ψ</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">prf_φ_ψ</span><span class="o">,</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">axm</span> <span class="o">:</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">abs</span> <span class="o">:</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">vac</span> <span class="o">:</span> <span class="o">{</span><span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">cut</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="n">prf_PQ</span> <span class="n">prf_QR</span> <span class="n">h₁</span> <span class="n">h₂</span>
    <span class="o">{</span><span class="n">exact</span> <span class="n">h₂</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">wf_φ</span><span class="o">)},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_intro</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">prf_pq</span> <span class="n">prf_pr</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_left</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF_and_left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">wf_φ</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_right</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF_and_right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">wf_φ</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">or_intro</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">prf_pr</span> <span class="n">prf_qr</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF_or_left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₃</span><span class="o">},</span>
  <span class="n">case</span> <span class="k">proof</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">A</span> <span class="n">h</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">type</span><span class="o">,</span> <span class="n">exact</span> <span class="n">A</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">type</span><span class="o">,</span> <span class="n">exact</span> <span class="n">A</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span><span class="o">,</span>
        <span class="n">assumption</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span> <span class="o">:</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span> <span class="o">:</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span> <span class="o">:</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">wf_p</span> <span class="n">wf_q</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
          <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">wf_φ</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₂</span> <span class="n">wf_φ</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">wf_p</span> <span class="n">wf_q</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
          <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">wf_φ</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₂</span> <span class="n">wf_φ</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">wf_p</span> <span class="n">wf_q</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
          <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₁</span> <span class="n">wf_φ</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ih₂</span> <span class="n">wf_φ</span><span class="o">},</span>
        <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span> <span class="o">:</span> <span class="err">Γ</span> <span class="n">n</span> <span class="n">A</span> <span class="n">h₁</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
        <span class="n">repeat</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
    <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">TT</span>
</code></pre></div>



<a name="198402864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402864">(May 22 2020 at 03:22)</a>:</h4>
<p>so yes, you can replace the unused variable names with <code>_</code></p>



<a name="198402945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198402945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198402945">(May 22 2020 at 03:25)</a>:</h4>
<p>Yep I see. As I am naming them (or not naming them) I don't really know what I've named until I move my cursor inside the <code>{}</code>, and each time I do that - it's not clear which "ugly" name is going to become the next variable name I tack on. Is trial and error the only way there?</p>



<a name="198403023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403023">(May 22 2020 at 03:26)</a>:</h4>
<p>i think in your tactic state, the autogenerated variable names appear in the order they're generated</p>



<a name="198403037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403037">(May 22 2020 at 03:27)</a>:</h4>
<p>Actually you're right - I think they just reappear in a different order once I've named them for some reason.</p>



<a name="198403078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403078">(May 22 2020 at 03:28)</a>:</h4>
<p>Can I avoid re-introducing <code>Γ</code> every time I do a case?</p>



<a name="198403174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403174">(May 22 2020 at 03:31)</a>:</h4>
<p>a mostly-not-serious suggestion is to redefine things so that the arguments that you're introducing come first</p>



<a name="198403176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403176">(May 22 2020 at 03:31)</a>:</h4>
<p>in the proof.comp case you do a lot of work tracking down metavariables</p>



<a name="198403214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403214">(May 22 2020 at 03:32)</a>:</h4>
<p><code>apply @WF.all _ _ A,</code> seems like a better thing to write for the first line than <code>apply WF.all</code></p>



<a name="198403236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403236">(May 22 2020 at 03:33)</a>:</h4>
<p>similarly <code>apply @WF.elem _ _ _ A,</code> a few lines later</p>



<a name="198403293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403293">(May 22 2020 at 03:34)</a>:</h4>
<p>Sorry could you explain what that's achieving?</p>



<a name="198403319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403319">(May 22 2020 at 03:35)</a>:</h4>
<p>well as it's written you get a metavariable and a goal that's just <code>type</code></p>



<a name="198403325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403325">(May 22 2020 at 03:35)</a>:</h4>
<p>and then later you close that goal by supplying <code>A</code></p>



<a name="198403365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403365">(May 22 2020 at 03:36)</a>:</h4>
<p>here we're feeding it A right when it's needed, instead of making lean ask us for it</p>



<a name="198403389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403389">(May 22 2020 at 03:37)</a>:</h4>
<p>I think you should abstract out the hard cases like <code>proof.comp</code> as lemmas</p>



<a name="198403434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403434">(May 22 2020 at 03:38)</a>:</h4>
<p>that way when you prove the theorem you're "just" listing all 24 cases together with either their short proofs or a call to the external lemma</p>



<a name="198403441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403441">(May 22 2020 at 03:38)</a>:</h4>
<p>I understand. Is that an indication I should change the WF.all to put the type first? And should I have the other arguments explicit or implicit? I thought making them implicit would save me from having to state them but I seems I have to do it anyway with this proof.</p>



<a name="198403456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403456">(May 22 2020 at 03:39)</a>:</h4>
<p>Yeah if in fact you end up always stating A explicitly then probably you want A to be an explicit argument</p>



<a name="198403459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403459">(May 22 2020 at 03:39)</a>:</h4>
<p>the first three implicit arguments get dealt with just fine</p>



<a name="198403501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403501">(May 22 2020 at 03:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/198403434">said</a>:</p>
<blockquote>
<p>that way when you prove the theorem you're "just" listing all 24 cases together with either their short proofs or a call to the external lemma</p>
</blockquote>
<p>If I'm doing it by induction though - do those lemmas need an appropriate hypothesis related to the induction?</p>



<a name="198403511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403511">(May 22 2020 at 03:40)</a>:</h4>
<p>the tactic state looks like this</p>
<div class="codehilite"><pre><span></span><code><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">φ</span> <span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="n">wf_φ</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="err">Ω</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="err">Ω</span>
<span class="err">⊢</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span><span class="o">(</span><span class="n">var</span> <span class="mi">0</span> <span class="err">∈</span> <span class="err">⟦</span><span class="n">p</span><span class="err">⟧</span><span class="o">)</span> <span class="err">⇔</span> <span class="n">subst</span> <span class="o">(</span><span class="n">var</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span> <span class="err">Ω</span>
</code></pre></div>



<a name="198403516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403516">(May 22 2020 at 03:41)</a>:</h4>
<p>you could have a lemma whose type signature is this tactic state</p>



<a name="198403574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403574">(May 22 2020 at 03:42)</a>:</h4>
<p>That's a nice way to go about it. That reminds me, what's up with the multiple Gammas?</p>



<a name="198403578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403578">(May 22 2020 at 03:42)</a>:</h4>
<p>Shouldn't they be unified or something?</p>



<a name="198403585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403585">(May 22 2020 at 03:42)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">case_proof_comp</span>
<span class="o">(</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span>
<span class="o">(</span><span class="n">φ</span> <span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
<span class="o">(</span><span class="err">Γ</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">)</span>
<span class="o">(</span><span class="n">wf_φ</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="err">Ω</span><span class="o">)</span>
<span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="err">Ω</span><span class="o">)</span> <span class="o">:</span>
 <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span><span class="o">(</span><span class="n">var</span> <span class="mi">0</span> <span class="err">∈</span> <span class="err">⟦</span><span class="n">p</span><span class="err">⟧</span><span class="o">)</span> <span class="err">⇔</span> <span class="n">subst</span> <span class="o">(</span><span class="n">var</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="198403590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403590">(May 22 2020 at 03:43)</a>:</h4>
<p>unified?</p>



<a name="198403591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403591">(May 22 2020 at 03:43)</a>:</h4>
<p>they have different types</p>



<a name="198403636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403636">(May 22 2020 at 03:44)</a>:</h4>
<p><code>context</code> is <code>list type</code></p>



<a name="198403647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403647">(May 22 2020 at 03:44)</a>:</h4>
<p>depends on what you mean by is</p>



<a name="198403682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403682">(May 22 2020 at 03:45)</a>:</h4>
<p>Definitional is? I'm not even sure why one of them became <code>list type</code></p>



<a name="198403687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403687">(May 22 2020 at 03:45)</a>:</h4>
<p><code>context</code> is defeq to <code>list type</code></p>



<a name="198403731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403731">(May 22 2020 at 03:46)</a>:</h4>
<p>but defeq is weaker than syntactic equality</p>



<a name="198403739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403739">(May 22 2020 at 03:46)</a>:</h4>
<p>and some things (I don't know which ones, really) only work up to syntactic equality</p>



<a name="198403824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403824">(May 22 2020 at 03:48)</a>:</h4>
<p>i do share some of your confusion</p>



<a name="198403845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403845">(May 22 2020 at 03:49)</a>:</h4>
<p>So when I do some case - I wanna say "use the same context here"</p>



<a name="198403906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403906">(May 22 2020 at 03:50)</a>:</h4>
<p>hmm why do you write </p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="k">proof</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>


<p>instead of e.g. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="k">proof</span>  <span class="o">(</span><span class="err">\</span><span class="n">G</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span>  <span class="o">(</span><span class="err">\</span><span class="n">phi</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="err">\</span><span class="n">psi</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="198403990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403990">(May 22 2020 at 03:53)</a>:</h4>
<p>I was under the impression I need to do the first, since my understanding of the second is that it locks in those variables globally to the rest of the inductive definitions.</p>



<a name="198403997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198403997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198403997">(May 22 2020 at 03:53)</a>:</h4>
<p>Whereas I need to unpack all the different cases for the context and terms</p>



<a name="198404000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404000">(May 22 2020 at 03:53)</a>:</h4>
<p>okay, I don't understand but vaguely believe you</p>



<a name="198404039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404039">(May 22 2020 at 03:54)</a>:</h4>
<p>also i'm gonna go sleep now</p>



<a name="198404046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404046">(May 22 2020 at 03:54)</a>:</h4>
<p>uh I guess to go back to one of your first questions</p>



<a name="198404049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404049">(May 22 2020 at 03:54)</a>:</h4>
<p>if you want more automation you could tag things with the simp attribute</p>



<a name="198404054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404054">(May 22 2020 at 03:55)</a>:</h4>
<p>and I think that the <code>tidy</code> tactic knows how to do some of the proofs you're doing</p>



<a name="198404129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404129">(May 22 2020 at 03:56)</a>:</h4>
<p>Goodnight :) That sounds cool and I need to read up on attributes and how that all works. I just put @[simp] next to subst and subst_nth because I had a guess at what it does.</p>



<a name="198404130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404130">(May 22 2020 at 03:56)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#tidy">tactic#tidy</a></p>



<a name="198404280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198404280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198404280">(May 22 2020 at 04:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/198403574">said</a>:</p>
<blockquote>
<p>That reminds me, what's up with the multiple Gammas?</p>
</blockquote>
<p>These are different hypotheses; they just have the same name. You can use <code>dedup</code> to give them different names. The first one may be unnecessary (if nothing in the goal refers to it); if so, you can <code>clear</code> it after the <code>dedup</code>.</p>



<a name="198406083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198406083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198406083">(May 22 2020 at 04:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/198402945">said</a>:</p>
<blockquote>
<p>Yep I see. As I am naming them (or not naming them) I don't really know what I've named until I move my cursor inside the <code>{}</code>, and each time I do that - it's not clear which "ugly" name is going to become the next variable name I tack on. Is trial and error the only way there?</p>
</blockquote>
<p>This is what I used to do, but the new "sticky position" vscode feature helps a lot with this. You put the marker inside the body of the <code>case</code>, then you start writing names in the <code>case</code> statement and push underscores until the name lines up with the variable you want</p>



<a name="198406153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198406153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198406153">(May 22 2020 at 04:55)</a>:</h4>
<p>To add to what Jannis said about the multiple gammas, the first one is probably the input to the theorem before the <code>induction</code> line. It can be removed, assuming you have generalized all the relevant hypotheses about it.</p>



<a name="198406195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198406195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198406195">(May 22 2020 at 04:56)</a>:</h4>
<p>It can also be ignored</p>



<a name="198411103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198411103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198411103">(May 22 2020 at 07:00)</a>:</h4>
<p>Not sure what you mean by sticky position. Like multiple cursors?</p>



<a name="198411727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198411727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198411727">(May 22 2020 at 07:11)</a>:</h4>
<p>When you have an editor with Lean code focused, you should see a button that looks like a pin near the top right of that editor. If you press that, or hit ctrl+P and search for "toggle sticky position", then the current position of the text cursor will get a blue mark. Now you can move your text cursor elsewhere, and the info view will continue to display the messages coming from the blue spot in the file. To turn it off, you can hit the button or call the command again.</p>



<a name="198412417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198412417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198412417">(May 22 2020 at 07:23)</a>:</h4>
<p>How can I be more eco-friendly and solve 10 different lemmas at the same time? (they all compile with the same proof)</p>



<a name="198412836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198412836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198412836">(May 22 2020 at 07:30)</a>:</h4>
<p>if they are only cases in one bigger proof and not meaningful as separate lemmas, you could use <code>any_goals {proof}</code>. i've also read something on here about a tactic that allows you to select a specific set of goals, but i don't remember what it's called or whether it exists in mathlib.</p>



<a name="198413162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198413162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198413162">(May 22 2020 at 07:35)</a>:</h4>
<p>They just deconstruct well-formedness - so I'm predicting using them in various places</p>
<p>All of those lemmas should be solved by the first one's proof</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span>   <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span>   <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span>   <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span>   <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">α</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">b</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mod</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">a</span> <span class="n">A</span>

<span class="kn">variable</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span>
<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span>
<span class="kn">variables</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span>

<span class="kn">lemma</span> <span class="n">WF_and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">induction</span> <span class="err">Γ</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="o">:</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">:</span> <span class="n">B</span> <span class="err">Δ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">mod</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ih</span><span class="o">,</span> <span class="n">assumption</span><span class="o">},</span>
<span class="kn">end</span>
<span class="kn">lemma</span> <span class="n">WF_and_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_or_left</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_or_right</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_imp_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_imp_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">q</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_prod_left</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_prod_right</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">b</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">WF_comp_elim</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span><span class="o">)</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="err">Ω</span> <span class="o">:=</span>
</code></pre></div>



<a name="198414572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198414572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198414572">(May 22 2020 at 07:56)</a>:</h4>
<p>Whoops, my new "mod" constructor for Well-formedness was not supposed to put the new variable at the start of the list (should go at the end). Regardless - my original question is still relevant.</p>



<a name="198416027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198416027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198416027">(May 22 2020 at 08:16)</a>:</h4>
<p>Here's my new definition of mod : <code>| mod  {Γ a A} (B) : WF Γ a A → WF (list.concat Γ B) a A</code>. I am having trouble with the following proof</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">WF_and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">Ω</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">induction</span> <span class="err">Γ</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="o">:</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>Lean is unhappy with "cases h", I think because it tries to unify the <code>(list.concat Γ B)</code> with <code>list.nil</code> to do the WF.mod case. Shouldn't it recognise this as an irrelevant case?</p>
<p>This is the error message</p>
<div class="codehilite"><pre><span></span><code><span class="n">cases</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">unsupported</span> <span class="n">equality</span> <span class="n">between</span> <span class="n">type</span> <span class="n">and</span> <span class="n">constructor</span> <span class="n">indices</span>
<span class="o">(</span><span class="n">only</span> <span class="n">equalities</span> <span class="n">between</span> <span class="n">constructors</span> <span class="n">and</span><span class="bp">/</span><span class="n">or</span> <span class="kn">variables</span> <span class="n">are</span> <span class="n">supported</span><span class="o">,</span> <span class="n">try</span> <span class="n">cases</span> <span class="n">on</span> <span class="n">the</span> <span class="n">indices</span><span class="o">):</span>
<span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">concat</span> <span class="n">h_</span><span class="err">Γ</span> <span class="n">h_B</span>

<span class="n">state</span><span class="o">:</span>
<span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">WF</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="o">(</span><span class="n">and</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span><span class="o">,</span>
<span class="n">h_</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">h_a</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">h_A</span> <span class="n">h_B</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">h_a_1</span> <span class="o">:</span> <span class="n">WF</span> <span class="n">h_</span><span class="err">Γ</span> <span class="n">h_a</span> <span class="n">h_A</span>
<span class="err">⊢</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">concat</span> <span class="n">h_</span><span class="err">Γ</span> <span class="n">h_B</span> <span class="bp">→</span> <span class="n">and</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">h_a</span> <span class="bp">→</span> <span class="err">Ω</span> <span class="bp">=</span> <span class="n">h_A</span> <span class="bp">→</span> <span class="n">h</span> <span class="bp">==</span> <span class="bp">_</span> <span class="bp">→</span> <span class="n">WF</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="n">p</span> <span class="err">Ω</span>
</code></pre></div>


<p>a similar thing happens with <code>case list.cons {cases h, }</code></p>
<div class="codehilite"><pre><span></span><code><span class="n">cases</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">unsupported</span> <span class="n">equality</span> <span class="n">between</span> <span class="n">type</span> <span class="n">and</span> <span class="n">constructor</span> <span class="n">indices</span>
<span class="o">(</span><span class="n">only</span> <span class="n">equalities</span> <span class="n">between</span> <span class="n">constructors</span> <span class="n">and</span><span class="bp">/</span><span class="n">or</span> <span class="kn">variables</span> <span class="n">are</span> <span class="n">supported</span><span class="o">,</span> <span class="n">try</span> <span class="n">cases</span> <span class="n">on</span> <span class="n">the</span> <span class="n">indices</span><span class="o">):</span>
<span class="err">Γ</span><span class="bp">_</span><span class="n">hd</span> <span class="bp">::</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">concat</span> <span class="n">h_</span><span class="err">Γ</span> <span class="n">h_B</span>

<span class="n">state</span><span class="o">:</span>
<span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="err">Γ</span><span class="bp">_</span><span class="n">hd</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="err">Γ</span><span class="bp">_</span><span class="n">ih</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span> <span class="o">(</span><span class="n">and</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span> <span class="n">p</span> <span class="err">Ω</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">_</span><span class="n">hd</span> <span class="bp">::</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span><span class="o">)</span> <span class="o">(</span><span class="n">and</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="err">Ω</span><span class="o">,</span>
<span class="n">h_</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">h_a</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">h_A</span> <span class="n">h_B</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">h_a_1</span> <span class="o">:</span> <span class="n">WF</span> <span class="n">h_</span><span class="err">Γ</span> <span class="n">h_a</span> <span class="n">h_A</span>
<span class="err">⊢</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">hd</span> <span class="bp">::</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">concat</span> <span class="n">h_</span><span class="err">Γ</span> <span class="n">h_B</span> <span class="bp">→</span> <span class="n">and</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">h_a</span> <span class="bp">→</span> <span class="err">Ω</span> <span class="bp">=</span> <span class="n">h_A</span> <span class="bp">→</span> <span class="n">h</span> <span class="bp">==</span> <span class="bp">_</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">_</span><span class="n">hd</span> <span class="bp">::</span> <span class="err">Γ</span><span class="bp">_</span><span class="n">tl</span><span class="o">)</span> <span class="n">p</span> <span class="err">Ω</span>
</code></pre></div>



<a name="198423511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198423511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198423511">(May 22 2020 at 09:50)</a>:</h4>
<p><code>list.concat</code> isn't a constructor, and indeed the result of <code>list.concat</code> could even be <code>list.nil</code>.</p>



<a name="198423830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198423830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198423830">(May 22 2020 at 09:55)</a>:</h4>
<p>I would ditch the induction on <code>Γ</code>, and induct on <code>h</code> instead</p>



<a name="198423873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198423873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198423873">(May 22 2020 at 09:55)</a>:</h4>
<p>What is <code>mod</code> supposed to represent?</p>



<a name="198426221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198426221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198426221">(May 22 2020 at 10:25)</a>:</h4>
<p>Oh whoops, <code>list.concat</code> doesn't mean what it means in every other language. Nevertheless, the first point remains.</p>



<a name="198430001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198430001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198430001">(May 22 2020 at 11:16)</a>:</h4>
<p>haha yeah, also <code>list.append</code> is what I first thought <code>list.concat</code> would be</p>



<a name="198430085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198430085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198430085">(May 22 2020 at 11:17)</a>:</h4>
<p><code>mod</code> adds a single junk type to the back of the context of a well-formed term</p>



<a name="198430291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198430291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198430291">(May 22 2020 at 11:20)</a>:</h4>
<p>If I do <code>induction h</code> - I don't know how to deal with all of the irrelevant cases that could not construct the given term. For example the first case want me to show <code>WF Δ p 𝟙</code></p>



<a name="198430453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198430453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198430453">(May 22 2020 at 11:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/198412417">said</a>:</p>
<blockquote>
<p>How can I be more eco-friendly and solve 10 different lemmas at the same time? (they all compile with the same proof)</p>
</blockquote>
<p>You can make a simple tactic like so:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">billy_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span>
<span class="bp">`</span><span class="o">[</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">induction</span> <span class="err">Γ</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="o">:</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">:</span> <span class="n">B</span> <span class="err">Δ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">mod</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ih</span><span class="o">,</span> <span class="n">assumption</span><span class="o">},]</span>
</code></pre></div>



<a name="198431945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198431945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198431945">(May 22 2020 at 11:43)</a>:</h4>
<p>What does <code>mod</code> stand for then?</p>



<a name="198432027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198432027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198432027">(May 22 2020 at 11:44)</a>:</h4>
<p>I would have thought <code>WF</code> already has this property, am I missing something?</p>



<a name="198432870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198432870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198432870">(May 22 2020 at 11:56)</a>:</h4>
<p>Oh no, I was proving something else and thought I didn't have that - and then added this mod thing (modify context) and that complicated things</p>



<a name="198482667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198482667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198482667">(May 22 2020 at 19:12)</a>:</h4>
<p>I think the <code>mod</code> constructor should be a theorem (usually called "weakening")</p>



<a name="198999237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198999237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198999237">(May 28 2020 at 09:18)</a>:</h4>
<p>I think I need quotients now to find the objects of my category - where can I find good examples of quotient types?</p>



<a name="198999616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/198999616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#198999616">(May 28 2020 at 09:23)</a>:</h4>
<p><code>git grep quotient</code>?</p>



<a name="199003821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199003821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199003821">(May 28 2020 at 10:11)</a>:</h4>
<p>That didn't work but I have been searching - just found Zmod37.lean - perfect!</p>



<a name="199006032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199006032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199006032">(May 28 2020 at 10:38)</a>:</h4>
<p>Just to comment that that file using <code>quotient</code>, which finds the equivalence relation using type class search, but there is also <code>quotient'</code>, which finds it via unification.</p>



<a name="199006477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199006477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199006477">(May 28 2020 at 10:44)</a>:</h4>
<p>What happens when you form a quotient type using a relation that's not an equivalence relation?</p>



<a name="199477115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199477115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199477115">(Jun 02 2020 at 11:22)</a>:</h4>
<p>How does one lift a function <code>a -&gt; a -&gt; a -&gt; b</code> to a function <code>quotient r a -&gt; quotient r a -&gt; quotient r a -&gt; b</code> in a controlled way? I'm away of quot.lift - does this generalise in a manageable way?</p>



<a name="199477248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199477248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199477248">(Jun 02 2020 at 11:24)</a>:</h4>
<p>There should be <code>quotient.lift\3</code></p>



<a name="199479218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199479218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199479218">(Jun 02 2020 at 11:46)</a>:</h4>
<p>There isn't :(</p>



<a name="199479535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199479535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199479535">(Jun 02 2020 at 11:49)</a>:</h4>
<p>Add it!</p>



<a name="199480251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199480251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199480251">(Jun 02 2020 at 11:57)</a>:</h4>
<p><span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span> I'll try when I have time :(</p>



<a name="199481644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199481644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199481644">(Jun 02 2020 at 12:12)</a>:</h4>
<p>Look at the proof of <code>lift2</code> and copy it</p>



<a name="199481899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199481899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199481899">(Jun 02 2020 at 12:14)</a>:</h4>
<p>or just use <code>lift</code> three times. It's not even a much worse proof obligation, it just has you vary one argument at a time instead of all three in one go</p>



<a name="199487930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199487930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199487930">(Jun 02 2020 at 13:06)</a>:</h4>
<p>I'm working with equivalence classes of provably equal closed terms, and I'm trying to define proofs about terms given some such equivalence classes - hence the need for lifting - but now I'm realising I maybe I should show "if you have provably equal terms, you can interchange them in any proof", then I could just apply that a bunch of times. But then I'm guessing I'd need to work in all of the constructors for terms - do I really need to repeat myself about every little thing for terms, but now about equivalence classes of terms?</p>



<a name="199492249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199492249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199492249">(Jun 02 2020 at 13:42)</a>:</h4>
<p>Perhaps that was a bit rambly - here's what I have so far in two files, the second file is where I'm trying to do stuff with the equivalence classes of closed terms - which are called <code>tset A</code> for any <code>A  : type</code> (an abbreviation for "type theory set"). I feel like I should be able to coerce my tset's into closed_terms (which coerce into terms), so I can talk about <code>proof</code>'s about tsets - without having to quotient.lift everything each time. Is that possible?</p>



<a name="199492282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199492282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199492282">(Jun 02 2020 at 13:42)</a>:</h4>
<p>TT.lean</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Definitions of a type theory</span>

<span class="cm">Author: Billy Price</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">prefix</span> <span class="err">𝒫</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="n">def</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">⟹</span> <span class="err">⊥</span>
<span class="kn">prefix</span> <span class="bp">`</span><span class="err">∼</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">not</span> <span class="c1">-- input \~</span>

<span class="n">def</span> <span class="n">iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">iff</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span><span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">prefix</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">prefix</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>

<span class="n">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">a₁</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="n">a₂</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">≃</span><span class="bp">`</span> <span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">eq</span>

<span class="n">def</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="err">⟦</span><span class="n">a</span> <span class="err">≃</span> <span class="o">(</span><span class="mi">𝟘</span><span class="o">)</span><span class="err">⟧</span>

<span class="n">def</span> <span class="n">ex_unique</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∃</span><span class="err">&#39;</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span> <span class="err">≃</span> <span class="n">singleton</span> <span class="o">(</span><span class="mi">𝟛</span><span class="o">)</span>
<span class="kn">prefix</span> <span class="bp">`∃!</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex_unique</span>

<span class="n">def</span> <span class="n">subseteq</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span>
<span class="kn">infix</span> <span class="err">⊆</span> <span class="o">:=</span> <span class="n">subseteq</span>

<span class="n">def</span> <span class="n">set_prod</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="err">⟦</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="mi">𝟛</span> <span class="err">≃</span> <span class="err">⟪</span><span class="mi">𝟚</span><span class="o">,</span><span class="mi">𝟙</span><span class="err">⟫</span><span class="o">)</span><span class="err">⟧</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="kn">open</span> <span class="n">term</span>


<span class="kn">section</span> <span class="n">wellformedness</span>

  <span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>


  <span class="kn">variable</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span>
  <span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="err">Ω&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span>
  <span class="c1">-- Ω&#39; is just a fake/variable version of Ω so we don&#39;t need to bother proving</span>
  <span class="c1">-- that it must be Ω itself.</span>

  <span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="n">ez</span><span class="bp">`</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span>               <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span>               <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or_left</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span>               <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or_right</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span>               <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span>             <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span>             <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair_left</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span>            <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair_right</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span>            <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp_elim</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span>          <span class="o">:=</span> <span class="n">ez</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all_elim</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex_elim</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">iff_intro</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}}</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">iff_elim</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h_a</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}}</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">eq_intro</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">a₁</span> <span class="n">a₂</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">((</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="n">a₁</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">((</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="n">a₂</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a₁</span> <span class="err">≃</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">iff_intro</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="n">simp</span><span class="o">}}</span>

<span class="kn">end</span> <span class="n">wellformedness</span>

<span class="kn">section</span> <span class="n">substitution</span>

  <span class="n">def</span> <span class="n">lift</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>         <span class="o">:=</span>    <span class="err">⟦</span><span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

  <span class="n">def</span> <span class="n">subst_nth</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst_nth</span> <span class="n">n</span> <span class="n">x</span> <span class="n">c</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>         <span class="o">:=</span>    <span class="err">⟦</span><span class="n">subst_nth</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">subst_nth</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

  <span class="n">def</span> <span class="n">subst</span> <span class="o">:=</span> <span class="n">subst_nth</span> <span class="mi">0</span>

  <span class="kn">notation</span>  <span class="n">φ</span> <span class="bp">`</span><span class="err">⁅</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⁆</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="n">b</span> <span class="n">φ</span>

  <span class="bp">#</span><span class="n">reduce</span> <span class="mi">𝟘</span><span class="err">⁅⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="mi">𝟙</span><span class="err">⁅⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>

<span class="kn">end</span> <span class="n">substitution</span>

<span class="kn">section</span> <span class="n">proofs</span>

  <span class="kn">inductive</span> <span class="k">proof</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">axm</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">vac</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">abs</span>        <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="err">⊥</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">and_intro</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">and_left</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span>
  <span class="bp">|</span> <span class="n">and_right</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">or_intro</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">or_left</span>    <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">or_right</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">imp_to_and</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">and_to_imp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">weakening</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">concat</span> <span class="err">Γ</span> <span class="n">B</span><span class="o">)</span> <span class="n">φ</span> <span class="n">ψ</span>
  <span class="bp">|</span> <span class="n">cut</span>        <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="n">c</span> <span class="n">ψ</span><span class="o">)</span>   <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">c</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">c</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span>
  <span class="bp">|</span> <span class="n">all_elim</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">all_intro</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span>   <span class="o">:</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ex_elim</span>    <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">ex_intro</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">φ</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ext</span>                      <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="mi">𝟚</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="mi">𝟙</span><span class="o">))</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="err">≃</span> <span class="mi">𝟘</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">prop_ext</span>                 <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="err">⇔</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟚</span> <span class="err">≃</span> <span class="mi">𝟙</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">star_unique</span>              <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="err">≃</span> <span class="err">⁎</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">pair_exists_rep</span>          <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="mi">𝟚</span> <span class="err">≃</span> <span class="err">⟪</span><span class="mi">𝟙</span><span class="o">,</span><span class="mi">𝟘</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">pair_distinct_rep</span>        <span class="o">:</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="err">⟪</span><span class="mi">𝟜</span><span class="o">,</span><span class="mi">𝟚</span><span class="err">⟫</span> <span class="err">≃</span> <span class="err">⟪</span><span class="mi">𝟛</span><span class="o">,</span><span class="mi">𝟙</span><span class="err">⟫</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟜</span> <span class="err">≃</span> <span class="mi">𝟛</span> <span class="err">⋀</span> <span class="mi">𝟚</span> <span class="err">≃</span> <span class="mi">𝟙</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">apply</span>      <span class="o">{</span><span class="err">Γ</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="n">ψ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="k">proof</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">φ</span><span class="err">⁅</span><span class="n">b</span><span class="err">⁆</span><span class="o">)</span> <span class="o">(</span><span class="n">ψ</span><span class="err">⁅</span><span class="n">b</span><span class="err">⁆</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">comp</span>       <span class="o">{</span><span class="err">Γ</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>       <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="n">φ</span><span class="err">⁅</span><span class="mi">𝟙</span><span class="err">⁆</span><span class="o">))</span>

  <span class="kn">prefix</span> <span class="err">⊢</span> <span class="o">:=</span> <span class="k">proof</span> <span class="o">[]</span> <span class="err">⊤</span>
  <span class="kn">infix</span> <span class="bp">`</span> <span class="err">⊢</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="k">proof</span> <span class="o">[]</span>
  <span class="kn">notation</span> <span class="n">φ</span> <span class="bp">`</span> <span class="err">⊢</span><span class="o">[</span><span class="bp">`</span> <span class="err">Γ</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span> <span class="n">ψ</span> <span class="o">:=</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span>
  <span class="kn">notation</span> <span class="bp">`</span><span class="err">⊢</span><span class="o">[</span><span class="bp">`</span> <span class="err">Γ</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span> <span class="n">ψ</span> <span class="o">:=</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="n">ψ</span>

  <span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">term</span>

  <span class="bp">#</span><span class="n">reduce</span>   <span class="err">⊢</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="err">∼</span><span class="n">p</span><span class="o">)</span>  <span class="c1">-- proof [] ⊤ (or p (imp p ⊥))</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="n">q</span> <span class="err">⊢</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="err">∼</span><span class="n">p</span><span class="o">)</span>  <span class="c1">-- proof [] q (or p (imp p ⊥))</span>
  <span class="bp">#</span><span class="n">reduce</span>   <span class="err">⊢</span><span class="o">[</span><span class="err">Ω</span><span class="o">,</span><span class="n">Unit</span><span class="o">]</span> <span class="n">p</span> <span class="c1">-- proof [Ω,Unit] ⊤ p</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="n">q</span> <span class="err">⊢</span><span class="o">[</span><span class="err">Ω</span><span class="o">,</span><span class="n">Unit</span><span class="o">]</span> <span class="n">p</span> <span class="c1">-- proof [Ω,Unit] q p</span>

  <span class="kn">variable</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span>
  <span class="kn">variables</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span>

  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">proof_left</span>  <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">:=</span> <span class="n">sorry</span>
  <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">proof_right</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">ψ</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">proofs</span>

<span class="kn">end</span> <span class="n">TT</span>
</code></pre></div>



<a name="199492351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/199492351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#199492351">(Jun 02 2020 at 13:43)</a>:</h4>
<p>category.lean</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">The associated category of a type theory</span>

<span class="cm">Author: Billy Price</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="kn">import</span> <span class="n">TT</span>

<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">section</span>
  <span class="kn">variable</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span>

  <span class="n">def</span> <span class="n">closed</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">WF</span> <span class="o">[]</span>

  <span class="n">def</span> <span class="n">closed_term</span> <span class="o">:=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">//</span> <span class="n">closed</span> <span class="n">A</span> <span class="n">a</span><span class="o">}</span>

  <span class="n">def</span> <span class="n">closed_term</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">closed</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">closed_term</span> <span class="n">A</span><span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">a</span>

  <span class="kn">instance</span> <span class="n">closed_term_has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">closed_term</span> <span class="n">A</span><span class="o">)</span> <span class="n">term</span> <span class="o">:=</span> <span class="n">coe_subtype</span>

  <span class="n">def</span> <span class="n">proof_eq</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="err">⊢</span> <span class="o">(</span><span class="n">a₁</span> <span class="err">≃</span> <span class="n">a₂</span><span class="o">)</span>

  <span class="kn">section</span> <span class="n">equivalence_relation</span>

  <span class="kn">lemma</span> <span class="n">proof_to_imp</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span> <span class="o">(</span><span class="n">q</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_to_imp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">cut</span> <span class="bp">_</span> <span class="n">q</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_right</span> <span class="bp">_</span> <span class="err">⊤</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">axm</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">proof_left</span> <span class="n">q</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">tidy</span>
  <span class="kn">end</span>

  <span class="kn">theorem</span> <span class="n">proof_eq_refl</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="o">(</span><span class="n">proof_eq</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">proof_eq</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">all_intro</span> <span class="err">𝒫</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_intro</span><span class="o">,</span>
    <span class="n">all_goals</span>
      <span class="o">{</span>
        <span class="n">apply</span> <span class="n">proof_to_imp</span><span class="o">,</span>
        <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">axm</span><span class="o">,</span>
        <span class="n">apply</span> <span class="bp">@</span><span class="n">WF</span><span class="bp">.</span><span class="n">elem</span> <span class="bp">_</span> <span class="n">A</span><span class="o">,</span>
        <span class="n">sorry</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">,</span>
        <span class="n">simp</span>
      <span class="o">}</span>
  <span class="kn">end</span>

  <span class="kn">theorem</span> <span class="n">proof_eq_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">proof_eq</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">all_intro</span> <span class="err">𝒫</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_intro</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_right</span> <span class="bp">_</span> <span class="o">((</span><span class="err">↑</span><span class="n">a₁</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="err">↑</span><span class="n">a₂</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">))</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">all_elim</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">and_left</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">((</span><span class="err">↑</span><span class="n">a₂</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="err">↑</span><span class="n">a₁</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)),</span>
    <span class="n">apply</span> <span class="k">proof</span><span class="bp">.</span><span class="n">all_elim</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
  <span class="kn">end</span>

  <span class="kn">theorem</span> <span class="n">proof_eq_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="o">(</span><span class="n">proof_eq</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

  <span class="kn">theorem</span> <span class="n">proof_eq_equiv</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="o">(</span><span class="n">proof_eq</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
    <span class="bp">⟨</span><span class="n">proof_eq_refl</span> <span class="n">A</span><span class="o">,</span> <span class="n">proof_eq_symm</span> <span class="n">A</span><span class="o">,</span> <span class="n">proof_eq_trans</span> <span class="n">A</span><span class="bp">⟩</span>

  <span class="kn">end</span> <span class="n">equivalence_relation</span>

  <span class="kn">definition</span> <span class="n">TT</span><span class="bp">.</span><span class="n">setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">closed_term</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span><span class="n">r</span> <span class="o">:=</span> <span class="n">proof_eq</span> <span class="n">A</span><span class="o">,</span> <span class="n">iseqv</span> <span class="o">:=</span> <span class="n">proof_eq_equiv</span> <span class="n">A</span><span class="o">}</span>

  <span class="bp">#</span><span class="kn">check</span> <span class="n">TT</span><span class="bp">.</span><span class="n">setoid</span>

  <span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">TT</span><span class="bp">.</span><span class="n">setoid</span>


  <span class="n">def</span> <span class="n">tset</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="o">(</span><span class="n">TT</span><span class="bp">.</span><span class="n">setoid</span> <span class="n">A</span><span class="o">)</span>

  <span class="n">def</span> <span class="n">to_tset</span> <span class="o">:=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">proof_eq</span> <span class="n">A</span><span class="o">)</span>

  <span class="n">def</span> <span class="n">coe_term_tset</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">closed_term</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">tset</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">to_tset</span> <span class="n">A</span><span class="bp">⟩</span>

  <span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">coe_term_tset</span>

  <span class="n">def</span> <span class="n">tset</span><span class="bp">.</span><span class="n">star</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">Unit</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">to_tset</span><span class="o">,</span> <span class="n">apply</span> <span class="n">closed_term</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="err">⁎</span><span class="o">,</span> <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span><span class="o">}</span>

<span class="kn">end</span>

<span class="kn">section</span>

  <span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span>

  <span class="n">def</span> <span class="n">term_is_subset</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="err">𝒫</span> <span class="o">(</span><span class="n">A</span><span class="bp">××</span><span class="n">B</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="err">⊢</span> <span class="n">F</span> <span class="err">⊆</span> <span class="o">(</span><span class="bp">@</span><span class="n">set_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>

  <span class="n">def</span> <span class="n">is_subset</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">tset</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">tset</span> <span class="err">𝒫</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>

  <span class="n">def</span> <span class="n">term_is_graph</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="err">𝒫</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">))</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">closed_term</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="err">⊢</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">((</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="bp">∃!</span><span class="err">&#39;</span> <span class="err">⟪</span><span class="mi">𝟙</span><span class="o">,</span><span class="mi">𝟘</span><span class="err">⟫</span> <span class="err">∈</span> <span class="n">F</span><span class="o">))</span>

  <span class="n">def</span> <span class="n">is_graph</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">tset</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">tset</span> <span class="err">𝒫</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">TT</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

  <span class="kn">namespace</span> <span class="n">TT</span>

  <span class="kn">open</span> <span class="n">TT</span>

  <span class="kn">instance</span> <span class="n">category</span> <span class="o">:</span> <span class="n">small_category</span> <span class="o">(</span><span class="n">tset</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- lean unhappy with tset : type → Type : Type 1</span>

  <span class="kn">end</span> <span class="n">TT</span>

<span class="kn">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="200207194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200207194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200207194">(Jun 09 2020 at 10:49)</a>:</h4>
<p>Now that I've explicitly type-parametrised <code>term.all</code>, I can't define my notation for equality. Any tips for that? I've done it with a placeholder but I don't think it will ever get inferred.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">leibniz_equal</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">((</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">a₁</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">a₂</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span>
<span class="kn">infix</span> <span class="err">≃</span> <span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">leibniz_equal</span> <span class="bp">_</span>
</code></pre></div>



<a name="200207771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200207771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200207771">(Jun 09 2020 at 10:56)</a>:</h4>
<p>To be fair this is exactly what equality in lean looks like</p>



<a name="200207793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200207793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200207793">(Jun 09 2020 at 10:57)</a>:</h4>
<p>If you want to omit it you will probably have to make it a builtin</p>



<a name="200207913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200207913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200207913">(Jun 09 2020 at 10:59)</a>:</h4>
<p>Your embedded language isn't going to get type inference so you should get used to ugly terms unless you start writing a deeply embedded proof assistant</p>



<a name="200207961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200207961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200207961">(Jun 09 2020 at 10:59)</a>:</h4>
<p>However there are ways to make use of tactics to allow reflecting lean exprs into your target language to make things a bit easier</p>



<a name="200208326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200208326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200208326">(Jun 09 2020 at 11:03)</a>:</h4>
<p>If the struggle is only with the use of <code>infix</code>, a reasonable workaround is to use something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">≃</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">leibniz_equal</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="200209416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200209416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200209416">(Jun 09 2020 at 11:17)</a>:</h4>
<p>Cool thanks, I was just trying to design something like that.</p>



<a name="200402900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200402900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200402900">(Jun 10 2020 at 11:11)</a>:</h4>
<p>I can't get my predefined <code>WF_rules</code> to work with <code>apply_rules</code> in the bottom lemma here. Note I have commented out <code>apply_rules [WF.and, WF.imp]</code>, which solves it, and those rules are part of WF_rules, so what's the issue? I get <code>no matching rule</code> on the line <code>apply_rules WF_rules</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Definitions of a type theory</span>

<span class="cm">Author: Billy Price</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="n">def</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">⟹</span> <span class="err">⊥</span>
<span class="kn">prefix</span> <span class="bp">`</span><span class="err">∼</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">not</span> <span class="c1">-- input \~</span>

<span class="n">def</span> <span class="n">iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">iff</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span> <span class="bp">`</span> <span class="n">A</span> <span class="bp">`</span> <span class="bp">|</span> <span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>


<span class="kn">section</span> <span class="n">substitution</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift_d</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>     <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift</span> <span class="o">:=</span> <span class="n">lift_d</span> <span class="mi">1</span> <span class="mi">0</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">c</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span>   <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

  <span class="kn">notation</span>  <span class="bp">`</span><span class="err">⁅</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="bp">//</span> <span class="bp">`</span>  <span class="n">b</span> <span class="bp">`</span><span class="err">⁆</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="mi">0</span> <span class="n">b</span> <span class="n">φ</span>

  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span><span class="mi">𝟘</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span> <span class="mi">𝟙</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>

<span class="kn">end</span> <span class="n">substitution</span>

<span class="n">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">$</span> <span class="o">((</span><span class="n">lift</span> <span class="n">a₁</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="n">lift</span> <span class="n">a₂</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">≃</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">eq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span> <span class="n">Unit</span> <span class="mi">𝟘</span> <span class="mi">𝟘</span>

<span class="n">def</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="o">(</span><span class="n">lift</span> <span class="n">a</span><span class="o">)</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="mi">𝟘</span><span class="err">⟧</span>

<span class="n">def</span> <span class="n">ex_unique</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span> <span class="err">≃</span><span class="o">[</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">A</span> <span class="mi">𝟘</span><span class="o">))</span>
<span class="kn">prefix</span> <span class="bp">`∃!</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex_unique</span>

<span class="n">def</span> <span class="n">subseteq</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">⊆</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">subseteq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">def</span> <span class="n">term_prod</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="err">⟦</span> <span class="n">A</span> <span class="bp">××</span> <span class="n">B</span> <span class="bp">|</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">B</span> <span class="o">((</span><span class="mi">𝟙</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">eq</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="mi">𝟚</span> <span class="err">⟪</span><span class="mi">𝟙</span><span class="o">,</span><span class="mi">𝟘</span><span class="err">⟫</span><span class="o">)))</span><span class="err">⟧</span>
<span class="kn">notation</span> <span class="n">α</span> <span class="bp">`</span> <span class="bp">×</span><span class="n">x</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">term_prod</span> <span class="n">A</span> <span class="n">α</span> <span class="n">β</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="bp">@</span><span class="o">[</span><span class="n">user_attribute</span><span class="o">]</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_rules</span> <span class="o">:</span> <span class="n">user_attribute</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">name</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">WF_rules</span><span class="o">,</span>
  <span class="n">descr</span> <span class="o">:=</span> <span class="s2">&quot;lemmas usable to prove Well Formedness&quot;</span> <span class="o">}</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span>

<span class="kn">section</span>

<span class="kn">variable</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span>
<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="err">Ω&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span>
<span class="c1">-- Ω&#39; is just a fake/variable version of Ω so we don&#39;t need to bother proving</span>
<span class="c1">-- that it must be Ω itself.&#39;</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_prover</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">and_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">or_left</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">or_right</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">imp_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">imp_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">pair_left</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">pair_right</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_elim</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">all_elim</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">ex_elim</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">iff_intro</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">,</span>
  <span class="c1">-- apply_rules [WF.and, WF.imp],</span>
<span class="kn">end</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">TT</span>
</code></pre></div>



<a name="200403159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403159">(Jun 10 2020 at 11:14)</a>:</h4>
<p>Most or all of your second set of rules (starting with <code>and_left</code>) shouldn't be used with <code>apply_rules</code>.</p>



<a name="200403205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403205">(Jun 10 2020 at 11:15)</a>:</h4>
<p>Ah good point, they would generate infinite possibilities for derivation right?</p>



<a name="200403306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403306">(Jun 10 2020 at 11:16)</a>:</h4>
<p>right, they are possibly suitable for forwards reasoning, but not for backwards reasoning</p>



<a name="200403360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403360">(Jun 10 2020 at 11:17)</a>:</h4>
<p>oh, you just have a namespace problem actually</p>



<a name="200403438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403438">(Jun 10 2020 at 11:18)</a>:</h4>
<p>I'm not sure what the right way to fix it is, but I would just move the attribute to the root namespace</p>



<a name="200403452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403452">(Jun 10 2020 at 11:18)</a>:</h4>
<p>outside <code>namespace TT</code>?</p>



<a name="200403478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403478">(Jun 10 2020 at 11:18)</a>:</h4>
<p>right. Alternatively, call it <code>TT.WF_rules</code> everywhere</p>



<a name="200403523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403523">(Jun 10 2020 at 11:19)</a>:</h4>
<p>Everywhere except the definition?</p>



<a name="200403631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403631">(Jun 10 2020 at 11:21)</a>:</h4>
<p>right, not literally in <code>meta def WF_rules</code> but everywhere else</p>



<a name="200403648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200403648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200403648">(Jun 10 2020 at 11:21)</a>:</h4>
<p>probably it's optional in <code> `WF_rules </code>, I forget how the backticked names work exactly</p>



<a name="200404040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404040">(Jun 10 2020 at 11:26)</a>:</h4>
<p>I can't add <code>TT.</code> to any of the other <code>WF_rules</code> without red-lines "unknown attribute [TT.WF_rules]"</p>



<a name="200404067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404067">(Jun 10 2020 at 11:26)</a>:</h4>
<p>Not optional with <code>`WF_rules</code> but you should be using <code>``WF_rules</code> and there it is optional</p>



<a name="200404172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404172">(Jun 10 2020 at 11:28)</a>:</h4>
<p>For reference: <code> ``name </code> goes through name resolution and is checked at tactic compile time, while <code>`name</code> is used as is (and so is generally checked at run time)</p>



<a name="200404319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404319">(Jun 10 2020 at 11:31)</a>:</h4>
<p>I'm not sure I understand the relevance. Is the name checking time relevant to whether a <code>TT.</code> is needed?</p>



<a name="200404456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404456">(Jun 10 2020 at 11:33)</a>:</h4>
<p>By the way <code>apply_rules WF_rules</code> and <code>apply_rules TT.WF_rules</code> both give "no matching rule", and <code>apply_rules hsdfsfj</code> gives <code>unknown identifier hsdfsfj </code>, so it seems to be recognising the object</p>



<a name="200404499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404499">(Jun 10 2020 at 11:34)</a>:</h4>
<p>maybe you have no matching rule</p>



<a name="200404551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404551">(Jun 10 2020 at 11:34)</a>:</h4>
<p>Weird. It works for me when I change all occurrences of <code>WF_rules</code> to <code>TT.WF_rules</code> except the one in <code>meta def WF_rules</code></p>



<a name="200404566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404566">(Jun 10 2020 at 11:34)</a>:</h4>
<p>name resolution means that it inserts namespaces based on the current context</p>



<a name="200404567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404567">(Jun 10 2020 at 11:34)</a>:</h4>
<p>and once I comment out all the bad rules</p>



<a name="200404612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200404612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200404612">(Jun 10 2020 at 11:35)</a>:</h4>
<p>so <code> ``WF_rules </code> is equivalent to <code> `TT.WF_rules</code> except that it will give an error if <code>WF_rules</code> can't be found</p>



<a name="200405009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405009">(Jun 10 2020 at 11:41)</a>:</h4>
<p>I can't get anything working here's the most updated version of what I've got, as soon as I change any instances of WF_rules to TT.WF_rules it doesn't recognise it, and the usage in the actual proof is ambilavent to <code>TT.</code>. However <code>apply_rules [WF.and, WF.imp]</code> works fine.</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Definitions of a type theory</span>

<span class="cm">Author: Billy Price</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="n">def</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">⟹</span> <span class="err">⊥</span>
<span class="kn">prefix</span> <span class="bp">`</span><span class="err">∼</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">not</span> <span class="c1">-- input \~</span>

<span class="n">def</span> <span class="n">iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">iff</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span> <span class="bp">`</span> <span class="n">A</span> <span class="bp">`</span> <span class="bp">|</span> <span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>


<span class="kn">section</span> <span class="n">substitution</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift_d</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>     <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift</span> <span class="o">:=</span> <span class="n">lift_d</span> <span class="mi">1</span> <span class="mi">0</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">c</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span>   <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

  <span class="kn">notation</span>  <span class="bp">`</span><span class="err">⁅</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="bp">//</span> <span class="bp">`</span>  <span class="n">b</span> <span class="bp">`</span><span class="err">⁆</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="mi">0</span> <span class="n">b</span> <span class="n">φ</span>

  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span><span class="mi">𝟘</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span> <span class="mi">𝟙</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>

<span class="kn">end</span> <span class="n">substitution</span>

<span class="n">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">$</span> <span class="o">((</span><span class="n">lift</span> <span class="n">a₁</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="n">lift</span> <span class="n">a₂</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">≃</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">eq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span> <span class="n">Unit</span> <span class="mi">𝟘</span> <span class="mi">𝟘</span>

<span class="n">def</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="o">(</span><span class="n">lift</span> <span class="n">a</span><span class="o">)</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="mi">𝟘</span><span class="err">⟧</span>

<span class="n">def</span> <span class="n">ex_unique</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span> <span class="err">≃</span><span class="o">[</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">A</span> <span class="mi">𝟘</span><span class="o">))</span>
<span class="kn">prefix</span> <span class="bp">`∃!</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex_unique</span>

<span class="n">def</span> <span class="n">subseteq</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">⊆</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">subseteq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">def</span> <span class="n">term_prod</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="err">⟦</span> <span class="n">A</span> <span class="bp">××</span> <span class="n">B</span> <span class="bp">|</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">B</span> <span class="o">((</span><span class="mi">𝟙</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">eq</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="mi">𝟚</span> <span class="err">⟪</span><span class="mi">𝟙</span><span class="o">,</span><span class="mi">𝟘</span><span class="err">⟫</span><span class="o">)))</span><span class="err">⟧</span>
<span class="kn">notation</span> <span class="n">α</span> <span class="bp">`</span> <span class="bp">×</span><span class="n">x</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">term_prod</span> <span class="n">A</span> <span class="n">α</span> <span class="n">β</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>



<span class="bp">@</span><span class="o">[</span><span class="n">user_attribute</span><span class="o">]</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_rules</span> <span class="o">:</span> <span class="n">user_attribute</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">name</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">WF_rules</span><span class="o">,</span>
  <span class="n">descr</span> <span class="o">:=</span> <span class="s2">&quot;lemmas usable to prove Well Formedness&quot;</span> <span class="o">}</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span>


<span class="kn">section</span>

<span class="kn">variable</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span>
<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="err">Ω&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span>
<span class="c1">-- Ω&#39; is just a fake/variable version of Ω so we don&#39;t need to bother proving</span>
<span class="c1">-- that it must be Ω itself.&#39;</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_prover</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or_left</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or_right</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair_left</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair_right</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp_elim</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all_elim</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex_elim</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_prover</span>
<span class="bp">@</span><span class="o">[</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">iff_intro</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">,</span>
  <span class="c1">-- apply_rules [WF.and, WF.imp],</span>
<span class="kn">end</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">TT</span>
</code></pre></div>



<a name="200405027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405027">(Jun 10 2020 at 11:41)</a>:</h4>
<p>Could you paste what you got working <span class="user-mention" data-user-id="110032">@Reid Barton</span> ?</p>



<a name="200405293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405293">(Jun 10 2020 at 11:44)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Definitions of a type theory</span>

<span class="cm">Author: Billy Price</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="n">def</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">⟹</span> <span class="err">⊥</span>
<span class="kn">prefix</span> <span class="bp">`</span><span class="err">∼</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">not</span> <span class="c1">-- input \~</span>

<span class="n">def</span> <span class="n">iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">iff</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span> <span class="bp">`</span> <span class="n">A</span> <span class="bp">`</span> <span class="bp">|</span> <span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>


<span class="kn">section</span> <span class="n">substitution</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift_d</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>     <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift</span> <span class="o">:=</span> <span class="n">lift_d</span> <span class="mi">1</span> <span class="mi">0</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">c</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span>   <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

  <span class="kn">notation</span>  <span class="bp">`</span><span class="err">⁅</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="bp">//</span> <span class="bp">`</span>  <span class="n">b</span> <span class="bp">`</span><span class="err">⁆</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="mi">0</span> <span class="n">b</span> <span class="n">φ</span>

  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span><span class="mi">𝟘</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span> <span class="mi">𝟙</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>

<span class="kn">end</span> <span class="n">substitution</span>

<span class="n">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">$</span> <span class="o">((</span><span class="n">lift</span> <span class="n">a₁</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="n">lift</span> <span class="n">a₂</span><span class="o">)</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">≃</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">eq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span> <span class="n">Unit</span> <span class="mi">𝟘</span> <span class="mi">𝟘</span>

<span class="n">def</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="o">(</span><span class="n">lift</span> <span class="n">a</span><span class="o">)</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="mi">𝟘</span><span class="err">⟧</span>

<span class="n">def</span> <span class="n">ex_unique</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span> <span class="err">≃</span><span class="o">[</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">A</span> <span class="mi">𝟘</span><span class="o">))</span>
<span class="kn">prefix</span> <span class="bp">`∃!</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex_unique</span>

<span class="n">def</span> <span class="n">subseteq</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">⊆</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">subseteq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">def</span> <span class="n">term_prod</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="err">⟦</span> <span class="n">A</span> <span class="bp">××</span> <span class="n">B</span> <span class="bp">|</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">B</span> <span class="o">((</span><span class="mi">𝟙</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="mi">𝟘</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">eq</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="mi">𝟚</span> <span class="err">⟪</span><span class="mi">𝟙</span><span class="o">,</span><span class="mi">𝟘</span><span class="err">⟫</span><span class="o">)))</span><span class="err">⟧</span>
<span class="kn">notation</span> <span class="n">α</span> <span class="bp">`</span> <span class="bp">×</span><span class="n">x</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">term_prod</span> <span class="n">A</span> <span class="n">α</span> <span class="n">β</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="bp">@</span><span class="o">[</span><span class="n">user_attribute</span><span class="o">]</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_rules</span> <span class="o">:</span> <span class="n">user_attribute</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">name</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">,</span>
  <span class="n">descr</span> <span class="o">:=</span> <span class="s2">&quot;lemmas usable to prove Well Formedness&quot;</span> <span class="o">}</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span>

<span class="kn">section</span>

<span class="kn">variable</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span>
<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="err">Ω&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span>
<span class="c1">-- Ω&#39; is just a fake/variable version of Ω so we don&#39;t need to bother proving</span>
<span class="c1">-- that it must be Ω itself.&#39;</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_prover</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">]</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">@[TT.WF_rules] lemma and_left   : WF Γ Ω&#39; (p ⋀ q) → WF Γ Ω&#39; p := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma and_right  : WF Γ Ω&#39; (p ⋀ q) → WF Γ Ω&#39; q := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma or_left    : WF Γ Ω&#39; (p ⋁ q) → WF Γ Ω&#39; p := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma or_right   : WF Γ Ω&#39; (p ⋁ q) → WF Γ Ω&#39; q := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma imp_left   : WF Γ Ω&#39; (p ⟹ q) → WF Γ Ω&#39; p := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma imp_right  : WF Γ Ω&#39; (p ⟹ q) → WF Γ Ω&#39; q := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma pair_left  : WF Γ (A ×× B) ⟪a,b⟫ → WF Γ A a := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma pair_right : WF Γ (A ×× B) ⟪a,b⟫ → WF Γ B b := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma comp_elim  : WF Γ (𝒫 A) ⟦A | φ⟧ → WF (A::Γ) Ω φ := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma all_elim   : WF Γ Ω&#39; (∀&#39; A φ) → WF (A::Γ) Ω&#39; φ := by WF_prover</span>
<span class="cm">@[TT.WF_rules] lemma ex_elim    : WF Γ Ω&#39; (∀&#39; A φ) → WF (A::Γ) Ω&#39; φ := by WF_prover</span>
<span class="cm">-/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">iff_intro</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">apply_rules</span> <span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">,</span>
  <span class="c1">-- apply_rules [WF.and, WF.imp],</span>
<span class="kn">end</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">TT</span>
</code></pre></div>



<a name="200405340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405340">(Jun 10 2020 at 11:45)</a>:</h4>
<p>Oh you change the name too</p>



<a name="200405407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405407">(Jun 10 2020 at 11:46)</a>:</h4>
<p>By the way, I noticed earlier that the interactive parser for <code>apply_rules</code> is a little weird--it expects an identifier, but it doesn't actually use it as an identifier, it uses it as an attribute name.</p>



<a name="200405438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405438">(Jun 10 2020 at 11:46)</a>:</h4>
<p>It gets weird if the attribute name is not the same as the identifier that introduces the attribute itself.</p>



<a name="200405463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200405463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200405463">(Jun 10 2020 at 11:47)</a>:</h4>
<p>Yes, sorry. I literally meant "in the string <code>meta def WF_rules</code>"</p>



<a name="200409037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409037">(Jun 10 2020 at 12:30)</a>:</h4>
<p>I'm now trying to prove you can lift all the variables in a term up by 1 and shove a new type at the start of the context, but it's unclear how to prove it in the quantified cases (WF.all, WF.ex, WF.comp), It looks like I need to do more induction - but doesn't that produce the same problem again?</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">lift</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="o">:</span> <span class="err">Δ</span> <span class="n">A</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span> <span class="o">:</span> <span class="err">Δ</span> <span class="n">A</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="err">Δ</span> <span class="n">A</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">lift</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">lift_d</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>


<p>Here's the state at the first <code>sorry</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="err">Δ</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">wfψ</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Δ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">ψ</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">B</span> <span class="bp">::</span> <span class="n">A</span> <span class="bp">::</span> <span class="err">Δ</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift</span> <span class="n">ψ</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="n">B</span> <span class="bp">::</span> <span class="err">Δ</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">ψ</span><span class="o">)</span>
</code></pre></div>



<a name="200409115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409115">(Jun 10 2020 at 12:31)</a>:</h4>
<p>That's right, this is why <code>lift</code> is not good enough</p>



<a name="200409132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409132">(Jun 10 2020 at 12:31)</a>:</h4>
<p>you have to prove the analogous theorem for <code>lift_d</code></p>



<a name="200409411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409411">(Jun 10 2020 at 12:34)</a>:</h4>
<p>Hmm okay, so prepending some list of types of length <code>d</code> in the <code>lift_d d</code> case?</p>



<a name="200409462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409462">(Jun 10 2020 at 12:34)</a>:</h4>
<p>Since you are holding <code>d</code> fixed in the definition of <code>lift_d</code>, you can probably prove it in the special case <code>d = 1</code></p>



<a name="200409490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409490">(Jun 10 2020 at 12:35)</a>:</h4>
<p>but you definitely have to generalize <code>k</code></p>



<a name="200409570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409570">(Jun 10 2020 at 12:35)</a>:</h4>
<p>Then again, the general theorem is not much harder and may come in useful</p>



<a name="200409788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409788">(Jun 10 2020 at 12:37)</a>:</h4>
<p>Ah okay, so splitting the original context at the <code>k</code>th position and shoving <code>d</code> variables in there.</p>



<a name="200409939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200409939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200409939">(Jun 10 2020 at 12:39)</a>:</h4>
<p>I think it looks something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_d</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="n">D</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">length</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">length</span> <span class="n">D</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="n">D</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="200410097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200410097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200410097">(Jun 10 2020 at 12:40)</a>:</h4>
<p>since you aren't inducting on <code>k</code> or <code>d</code> you can also simplify this to</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_d</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="n">D</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="n">D</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="200410535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200410535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200410535">(Jun 10 2020 at 12:45)</a>:</h4>
<p>Yep that makes sense to me</p>



<a name="200411475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200411475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200411475">(Jun 10 2020 at 12:53)</a>:</h4>
<p>This state looks equally difficult to solve - am I missing something?</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">K</span> <span class="err">Δ</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="err">Δ</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">wfψ</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">B</span> <span class="bp">::</span> <span class="err">Δ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">ψ</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">WF</span> <span class="o">(</span><span class="n">B</span> <span class="bp">::</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">))</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
</code></pre></div>



<a name="200411556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200411556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200411556">(Jun 10 2020 at 12:54)</a>:</h4>
<p>How did you start the proof?</p>



<a name="200411584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200411584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200411584">(Jun 10 2020 at 12:54)</a>:</h4>
<p>You need <code>generalizing K</code> at least</p>



<a name="200411586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200411586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200411586">(Jun 10 2020 at 12:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">K</span> <span class="err">Δ</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="o">:</span> <span class="err">Δ</span> <span class="n">B</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span><span class="o">,</span><span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span> <span class="o">:</span> <span class="err">Δ</span> <span class="n">B</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="err">Δ</span> <span class="n">B</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">any_goals</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">lift_d</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200411741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200411741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200411741">(Jun 10 2020 at 12:56)</a>:</h4>
<p>You also need to generalize <code>generalize e : K ++ Γ = Γ'</code> before the induction</p>



<a name="200411816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200411816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200411816">(Jun 10 2020 at 12:57)</a>:</h4>
<p>You should also be able to use <code>constructor</code> instead of <code>apply_rules</code> for an inductive proof like this</p>



<a name="200412036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412036">(Jun 10 2020 at 12:58)</a>:</h4>
<p>I don't understand what generalizing K does? What does more general mean here?</p>



<a name="200412078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412078">(Jun 10 2020 at 12:59)</a>:</h4>
<p><code>K</code> needs to be forall-quantified in the inductive hypothesis</p>



<a name="200412130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412130">(Jun 10 2020 at 12:59)</a>:</h4>
<p>That was the problem with your stuck goal, if <code>K</code> was generalized in <code>ih</code> then you could have instantiated <code>K</code> to <code>B :: K</code></p>



<a name="200412355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412355">(Jun 10 2020 at 13:01)</a>:</h4>
<p>Another way to put it is, we expect that <code>K</code> will change over the course of the induction, while <code>Δ</code> and <code>Γ</code> for instance don't need to change</p>



<a name="200412462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412462">(Jun 10 2020 at 13:01)</a>:</h4>
<p><code>A</code> and <code>a</code> also need to change over the induction but since they are indices to the inductive family this is automatic and you don't need to specify <code>generalizing A a</code></p>



<a name="200412692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412692">(Jun 10 2020 at 13:03)</a>:</h4>
<p>That makes so much sense thank you. I've seen "indices" before - what does it mean to be an index to an inductive family?</p>



<a name="200412710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412710">(Jun 10 2020 at 13:03)</a>:</h4>
<p>right of the colon in the <code>inductive</code> statement</p>



<a name="200412807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412807">(Jun 10 2020 at 13:04)</a>:</h4>
<p>In <code>WF</code> there are no parameters (left of the colon) and three indices</p>



<a name="200412886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412886">(Jun 10 2020 at 13:05)</a>:</h4>
<p>yep, context, type and term?</p>



<a name="200412891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200412891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200412891">(Jun 10 2020 at 13:05)</a>:</h4>
<p>right</p>



<a name="200413040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413040">(Jun 10 2020 at 13:06)</a>:</h4>
<p>K appears in the context of <code>wfa</code> - why does that not automatically generalise?</p>



<a name="200413080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413080">(Jun 10 2020 at 13:07)</a>:</h4>
<p>Because the context is an append of two contexts?</p>



<a name="200413098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413098">(Jun 10 2020 at 13:07)</a>:</h4>
<p>So it can't do it?</p>



<a name="200413243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413243">(Jun 10 2020 at 13:08)</a>:</h4>
<p>If you leave a composed expression in an index when you do <code>induction</code>, it will silently generalize it, losing the connection to the original expression</p>



<a name="200413339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413339">(Jun 10 2020 at 13:09)</a>:</h4>
<p>That is, it tries to prove <code>WF Γ' A a → WF (K ++ Δ ++ Γ) A (lift_d (length Δ) (length K) a)</code>, which won't be provable because <code>K</code> is gone from the left side</p>



<a name="200413446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413446">(Jun 10 2020 at 13:10)</a>:</h4>
<p>If you do <code>generalize e : K ++ Γ = Γ'</code> then it is instead proving <code>WF Γ' A a → \forall K, K ++ Γ = Γ' -&gt; WF (K ++ Δ ++ Γ) A (lift_d (length Δ) (length K) a)</code> which is okay</p>



<a name="200413664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200413664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200413664">(Jun 10 2020 at 13:11)</a>:</h4>
<p>(technically indices aren't generalized in the sense of <code>generalizing</code>, they are handled specially because they participate directly in the statement of the recursor)</p>



<a name="200414272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414272">(Jun 10 2020 at 13:16)</a>:</h4>
<p>Hmm, I'm not sure if this is the right setup. Also what's the reason for the duplicate K's and A's (which I've rename with apostrophe's).</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">K</span> <span class="err">Δ</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="n">e</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span> <span class="bp">=</span> <span class="err">Γ&#39;</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wfa</span> <span class="n">generalizing</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="o">:</span> <span class="n">K&#39;</span> <span class="n">A&#39;</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">constructor</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span> <span class="o">:</span> <span class="n">K&#39;</span> <span class="n">A&#39;</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">constructor</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="n">K&#39;</span> <span class="n">A&#39;</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">constructor</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">any_goals</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">lift_d</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>


<p>this is my state for the first sorry</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="err">Δ</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="err">Γ&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">K</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">K&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="n">e</span> <span class="o">:</span> <span class="n">K&#39;</span> <span class="bp">=</span> <span class="err">Γ&#39;</span><span class="o">,</span>
<span class="n">A&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">wfψ</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A&#39;</span> <span class="bp">::</span> <span class="n">K&#39;</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">ψ</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span> <span class="n">A&#39;</span> <span class="bp">::</span> <span class="n">K&#39;</span> <span class="bp">=</span> <span class="err">Γ&#39;</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kn">context</span><span class="o">),</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A&#39;</span> <span class="bp">::</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">))</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
</code></pre></div>



<a name="200414434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414434">(Jun 10 2020 at 13:17)</a>:</h4>
<p>I think I should have <code>length K'</code> appearing in <code>ih</code>, not <code>length K</code></p>



<a name="200414643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414643">(Jun 10 2020 at 13:19)</a>:</h4>
<p>You can simplify this by eliminating the equality immediately using <code>induction wfa generalizing K; subst e,</code></p>



<a name="200414736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414736">(Jun 10 2020 at 13:20)</a>:</h4>
<p><code>K'</code> is just <code>Γ'</code></p>



<a name="200414805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414805">(Jun 10 2020 at 13:21)</a>:</h4>
<p>but that inductive hypothesis does look like bad news</p>



<a name="200414849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414849">(Jun 10 2020 at 13:21)</a>:</h4>
<p>Oh right I got the renaming wrong.</p>



<a name="200414869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200414869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200414869">(Jun 10 2020 at 13:21)</a>:</h4>
<p>what is the state before <code>induction</code></p>



<a name="200415087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200415087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200415087">(Jun 10 2020 at 13:23)</a>:</h4>
<p>Ah, I think I know what happened; <code>wfa</code> is in the context so <code>generalize</code> won't hit it and it is useless (it just adds a useless equality to the context)</p>



<a name="200415104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200415104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200415104">(Jun 10 2020 at 13:23)</a>:</h4>
<p>Use <code>generalize_hyp e : K ++ Γ = Γ' at wfa,</code></p>



<a name="200415198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200415198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200415198">(Jun 10 2020 at 13:24)</a>:</h4>
<p>the idea here is that immediately before the induction <code>wfa</code> should have variables in all the indices, no composed expressions</p>



<a name="200415235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200415235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200415235">(Jun 10 2020 at 13:24)</a>:</h4>
<p>Yep that makes sense</p>



<a name="200415730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200415730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200415730">(Jun 10 2020 at 13:29)</a>:</h4>
<p>Now we're here</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">K</span> <span class="err">Δ</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="n">e</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span> <span class="bp">=</span> <span class="err">Γ&#39;</span> <span class="n">at</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wfa</span> <span class="n">generalizing</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="o">:</span> <span class="err">Γ&#39;</span> <span class="n">A&#39;</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">subst</span> <span class="n">e</span><span class="o">,</span> <span class="n">constructor</span><span class="o">,},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span> <span class="o">:</span> <span class="err">Γ&#39;</span> <span class="n">A&#39;</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">constructor</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:</span> <span class="err">Γ&#39;</span> <span class="n">A&#39;</span> <span class="n">ψ</span> <span class="n">wfψ</span> <span class="n">ih</span> <span class="o">{</span><span class="n">constructor</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">any_goals</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">lift_d</span><span class="o">,</span> <span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>


<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="err">Δ</span> <span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="err">Γ&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">K</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">A&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">ψ</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span>
<span class="n">wfψ</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A&#39;</span> <span class="bp">::</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">))</span> <span class="err">Ω</span> <span class="n">ψ</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">K_1</span> <span class="o">:</span> <span class="kn">context</span><span class="o">),</span> <span class="n">K_1</span> <span class="bp">++</span> <span class="err">Γ</span> <span class="bp">=</span> <span class="n">A&#39;</span> <span class="bp">::</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">K_1</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K_1</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A&#39;</span> <span class="bp">::</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">))</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
</code></pre></div>



<a name="200415891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200415891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200415891">(Jun 10 2020 at 13:30)</a>:</h4>
<p>That's the state after <code>constructor,</code>. I put the <code>subst e</code>, inside the case because applying it do all the inductive cases via <code>induction wfa generalizing K; subst e</code> anonymised the goals so I couldn't name a case anymore.</p>



<a name="200416267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200416267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200416267">(Jun 10 2020 at 13:33)</a>:</h4>
<p>The hypothesis seems good to me - is it just failing to see how to unify the lists because of associativity or something? This is what I get when I try to <code>apply ih</code></p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="n">WF</span> <span class="o">(</span><span class="n">A&#39;</span> <span class="bp">::</span> <span class="o">(</span><span class="n">K</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">))</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">K</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
<span class="k">with</span>
  <span class="n">WF</span> <span class="o">(</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">++</span> <span class="err">Δ</span> <span class="bp">++</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">lift_d</span> <span class="o">(</span><span class="n">length</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="err">?</span><span class="n">m_1</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span>
</code></pre></div>



<a name="200416969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200416969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200416969">(Jun 10 2020 at 13:39)</a>:</h4>
<p>you have to explicitly specify <code>ih (A' :: K)</code>, but it looks defeq modulo that</p>



<a name="200417135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200417135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200417135">(Jun 10 2020 at 13:41)</a>:</h4>
<p>(you should get out of the habit of using <code>apply</code>; <code>refine</code> and <code>exact</code> are better because they have the expected type)</p>



<a name="200417829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200417829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200417829">(Jun 10 2020 at 13:47)</a>:</h4>
<p>oh okay, I was aware of <code>exact</code> but not <code>refine</code>. Though reading it now I don't quite see the importance - what do you mean by "they have the expected type"?</p>



<a name="200417876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200417876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200417876">(Jun 10 2020 at 13:48)</a>:</h4>
<p>whaaat <code>refine</code> is the best tactic</p>



<a name="200417972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200417972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200417972">(Jun 10 2020 at 13:48)</a>:</h4>
<p>the argument of <code>refine e</code> or <code>exact e</code> is typechecked using the goal as the target type</p>



<a name="200418069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200418069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200418069">(Jun 10 2020 at 13:49)</a>:</h4>
<p>the argument of <code>apply e</code> is typechecked with no expected type, and then the result is unified against the target type after counting the number of pis to eliminate</p>



<a name="200418433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200418433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200418433">(Jun 10 2020 at 13:52)</a>:</h4>
<p>Is there a minimal situation in which that makes a difference?</p>



<a name="200418507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200418507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200418507">(Jun 10 2020 at 13:52)</a>:</h4>
<p>anything using structure constructor brackets for example</p>



<a name="200418706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200418706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200418706">(Jun 10 2020 at 13:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨⟨⟩</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="c1">-- works</span>
  <span class="n">exact</span> <span class="bp">⟨⟨⟩</span><span class="o">,</span> <span class="bp">⟨⟩⟩</span><span class="o">,</span> <span class="c1">-- works</span>
<span class="kn">end</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="bp">⟨⟨⟩</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="c1">-- invalid constructor ⟨...⟩, expected type must be known</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200419035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419035">(Jun 10 2020 at 13:56)</a>:</h4>
<p>refine is great for compact and powerful combinations of <code>existsi</code>, <code>intro</code>  and simple proof terms like <code>refine ⟨x, easy_lemma, λ t, _⟩,</code></p>



<a name="200419042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419042">(Jun 10 2020 at 13:56)</a>:</h4>
<p>Ah I see, I think you mean <code>exact ⟨⟨⟩, ⟨⟩,⟨⟩⟩</code> though</p>



<a name="200419074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419074">(Jun 10 2020 at 13:57)</a>:</h4>
<p>no, I wrote what I meant</p>



<a name="200419105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419105">(Jun 10 2020 at 13:57)</a>:</h4>
<p>that is, <code>apply</code> isn't replacing <code>refine</code> in this example</p>



<a name="200419160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419160">(Jun 10 2020 at 13:57)</a>:</h4>
<p>of course you can also try to give the whole proof term at once as well, making <code>apply</code> act like <code>exact</code></p>



<a name="200419223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419223">(Jun 10 2020 at 13:58)</a>:</h4>
<p>and it would still fail</p>



<a name="200419271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419271">(Jun 10 2020 at 13:58)</a>:</h4>
<p>Oh sorry I interpreted it wrong</p>



<a name="200419682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419682">(Jun 10 2020 at 14:01)</a>:</h4>
<p>Can I undo the generalizing of <code>K</code> to simplify my other inductive cases?</p>



<a name="200419803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419803">(Jun 10 2020 at 14:02)</a>:</h4>
<p>You can use <code>exact ih K</code></p>



<a name="200419818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419818">(Jun 10 2020 at 14:02)</a>:</h4>
<p>or <code>apply ih</code> if it works</p>



<a name="200419892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419892">(Jun 10 2020 at 14:03)</a>:</h4>
<p>You could use <code>specialize ih K</code> but it's probably not worth the characters it takes to say</p>



<a name="200419903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200419903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200419903">(Jun 10 2020 at 14:03)</a>:</h4>
<p>Some of them have multiple inductive hypotheses</p>



<a name="200420077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200420077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200420077">(Jun 10 2020 at 14:04)</a>:</h4>
<p>I would do something like <code>iterate 4 { constructor, exact ih_1 K, exact ih_2 K }</code></p>



<a name="200420131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200420131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200420131">(Jun 10 2020 at 14:05)</a>:</h4>
<p>or <code>try { ... }</code></p>



<a name="200420206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200420206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200420206">(Jun 10 2020 at 14:05)</a>:</h4>
<p>probably some higher level thing like <code>solve_by_elim</code> works too</p>



<a name="200420417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200420417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200420417">(Jun 10 2020 at 14:07)</a>:</h4>
<p>But how would I name the inductive hypotheses like that?</p>



<a name="200420479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200420479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200420479">(Jun 10 2020 at 14:07)</a>:</h4>
<p>They all have gross names and I need to open a single case to name them</p>



<a name="200426313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200426313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200426313">(Jun 10 2020 at 14:49)</a>:</h4>
<p>I'm now proving an equality using <code>list.nth</code>, and I want to use theorems that talk about <code>list.nth_le</code>. I haven't seen any theorems converting between the two.</p>



<a name="200426942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200426942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200426942">(Jun 10 2020 at 14:53)</a>:</h4>
<p>I'll try write one myself but just wondering if it's already there somewhere (I couldn't find it)</p>



<a name="200428316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200428316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200428316">(Jun 10 2020 at 15:02)</a>:</h4>
<p>An MSc student of mine found a lot of missing lemmas about <code>nth</code> and <code>nth_le</code>. Her repo is now public so maybe there is some stuff here <a href="https://github.com/ImperialCollegeLondon/dots_and_boxes/tree/master/src/list/lemmas">https://github.com/ImperialCollegeLondon/dots_and_boxes/tree/master/src/list/lemmas</a> which is of some use. Note that the repo uses Lean 3.4.2.</p>



<a name="200429147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429147">(Jun 10 2020 at 15:09)</a>:</h4>
<p>There is one key theorem called something like <code>nth_le_nth</code></p>



<a name="200429189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429189">(Jun 10 2020 at 15:09)</a>:</h4>
<p>^ that</p>



<a name="200429225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429225">(Jun 10 2020 at 15:09)</a>:</h4>
<p>also <code>nth_eq_some</code></p>



<a name="200429235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429235">(Jun 10 2020 at 15:09)</a>:</h4>
<p>My student needed some <code>nth_le_append</code> lemmas</p>



<a name="200429330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429330">(Jun 10 2020 at 15:10)</a>:</h4>
<p>We never managed to formalise what <code>nth_le_bind</code> was but fortunately we were only glueing two lists together at that point</p>



<a name="200429357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429357">(Jun 10 2020 at 15:10)</a>:</h4>
<p>I see <code>nth_le_append</code> and <code>nth_le_append_right</code></p>



<a name="200429496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429496">(Jun 10 2020 at 15:11)</a>:</h4>
<p>I wouldn't bother with <code>nth_le_bind</code>, the expression is not any better than what you get by induction</p>



<a name="200429612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200429612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200429612">(Jun 10 2020 at 15:12)</a>:</h4>
<p>They weren't in mathlib when the project started, and the student never bothered keeping up to date with mathlib</p>



<a name="200514209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200514209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200514209">(Jun 11 2020 at 07:50)</a>:</h4>
<p>Thanks for the help, I'm gonna bookmark that proof for now. I have a thing called <code>tset : type -&gt; Type</code>, so if <code>A : type</code>, then <code>tset A</code> is basically a closed term of type <code>PA</code>, and I'd like to form a category of all such tsets of all types. But if I say <code>instance category : small_category (Π A : type, tset A)</code> are the objects in that category elements of Type <code>tset A</code> for some <code>A</code>, or are they indexed families of tsets, which are indexed by the elements of <code>type</code>?</p>



<a name="200514245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200514245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200514245">(Jun 11 2020 at 07:51)</a>:</h4>
<p>I understand that I need to actually define the structure of that category, but I'm just trying to get the Type right for now</p>



<a name="200515274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200515274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200515274">(Jun 11 2020 at 08:05)</a>:</h4>
<p>To strip away all the unnecessary context here,  if I have</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span><span class="o">:</span> <span class="kt">Type</span>
<span class="n">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">-&gt;</span> <span class="n">foo</span>
<span class="n">def</span> <span class="n">baz</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">bar</span> <span class="n">n</span>
</code></pre></div>


<p>what <em>is</em> an <code>f : baz</code>? Is it an indexed family of <code>foo</code>'s (via <code>bar</code>) or is it a <code>bar n : foo</code> for some  <code>n</code>? What is the type of all <code>bar n</code> for any <code>n</code>? My best idea is a subtype of <code>foo</code> where any <code>a</code> in the subtype has <code>∃ n : ℕ, bar n == a</code>, but that seems too implicit. I'd like to say maybe pairs of the form <code>&lt;n,bar n&gt;</code>?</p>



<a name="200515884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200515884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200515884">(Jun 11 2020 at 08:12)</a>:</h4>
<p>I think I just figured out that this is what the sigma construction is for lol.</p>



<a name="200516260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200516260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200516260">(Jun 11 2020 at 08:16)</a>:</h4>
<p>An element of <code>\Sigma A : type, tset A</code> would be a "pointed type" - - are these really the objects you want for your category?</p>



<a name="200516298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200516298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200516298">(Jun 11 2020 at 08:17)</a>:</h4>
<p>In <code>category C</code>, C is just the type of "abstract objects". An element of C does not need to have any internal structure - - it is just a label. Maybe here you want C to be just <code>type</code>? Then you can define Hom-sets however you like</p>



<a name="200517695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200517695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200517695">(Jun 11 2020 at 08:35)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span>  what you wrote about bar doesn't typecheck.</p>



<a name="200517789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200517789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200517789">(Jun 11 2020 at 08:36)</a>:</h4>
<p><code>baz</code> doesn't make sense. It looks like it's going to be a function which eats a natural <code>n</code> and returns a term of type <code>bar n</code>, but <code>bar n</code> isn't a type.</p>



<a name="200517843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200517843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200517843">(Jun 11 2020 at 08:37)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span><span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">-&gt;</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">baz</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">bar</span> <span class="n">n</span> <span class="c1">-- error -- type expected at bar n</span>
</code></pre></div>



<a name="200518371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200518371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200518371">(Jun 11 2020 at 08:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/200516260">said</a>:</p>
<blockquote>
<p>An element of <code>\Sigma A : type, tset A</code> would be a "pointed type" - - are these really the objects you want for your category?</p>
</blockquote>
<p>Yep, I'm not forming the typical category of types. Closer to the category of sets. My objects are terms <code>α : term</code> such that <code>WF [] (P A) α</code>, that is, <code>α</code> is a well-formed term in the empty context (it's closed) "of type (P A)", where <code>P: type -&gt; type</code> is thought of as the powerset of a type. My morphisms are terms which look like the graph of a function between two such "subsets of a type".</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I must have confused myself in translating to that example. I might reattempt, but I think <code>Σ A : type, tset A</code> is what I was looking for, where <code>tset</code> is defined like this</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">tset</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">//</span> <span class="n">WF</span> <span class="o">[]</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span><span class="o">}</span>
</code></pre></div>


<p>The related definitions to what I'm doing appear here<br>
<a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/200405009">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/200405009</a></p>



<a name="200518534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200518534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200518534">(Jun 11 2020 at 08:44)</a>:</h4>
<p>Pi's are types of dependent functions and Sigma's are types of dependent pairs</p>



<a name="200519356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200519356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200519356">(Jun 11 2020 at 08:54)</a>:</h4>
<p>I actually want to form equivalence classes of "provably equal" such terms, but it's becoming difficult to prove the lifting properties, so I'm just ignoring that for now. It definitely doesn't form a category without doing this, since associativity will never hold (composition produces ugly terms which are "provably equal" to simpler terms). Btw, "Provably equal" is its own thing my type theory.</p>



<a name="200531435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200531435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200531435">(Jun 11 2020 at 11:26)</a>:</h4>
<p>How come <code>cases</code> recognises whenever a constructor couldn't possibly produce the target, but <code>induction</code> doesn't? I always end up with absurd cases to prove with induction.</p>



<a name="200531532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200531532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200531532">(Jun 11 2020 at 11:27)</a>:</h4>
<p>because properties if the input may not hold of the inductive subcases</p>



<a name="200531854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200531854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200531854">(Jun 11 2020 at 11:31)</a>:</h4>
<p>But shouldn't the result of those constructors fail to unify with the target?</p>



<a name="200531900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200531900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200531900">(Jun 11 2020 at 11:31)</a>:</h4>
<p>If <code>induction</code> used the same motive as <code>cases</code>, the inductive hypothesis would be guaranteed useless</p>



<a name="200531934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200531934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200531934">(Jun 11 2020 at 11:31)</a>:</h4>
<p>the point is that just because you are inducting on <code>foo (C1 t)</code>, doesn't mean that every subterm of <code>C1 t</code> is also of the form <code>C1 t</code></p>



<a name="200532016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532016">(Jun 11 2020 at 11:32)</a>:</h4>
<p>so although you may be able to eliminate case <code>C2</code> at the top level, when you go around the recursion once you won't be able to skip the <code>C2</code> case anymore</p>



<a name="200532077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532077">(Jun 11 2020 at 11:33)</a>:</h4>
<p>Hmm lemme make a simple example that I don't understand</p>



<a name="200532162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532162">(Jun 11 2020 at 11:34)</a>:</h4>
<p>If you want to explicitly say that an index is fixed, for example you are proving something about terms in the empty context and don't mind that the inductive hypothesis of <code>WF.all</code> doesn't apply, then you can explicitly generalize it before and eliminate it after using <code>generalize_hyp e : Gamma = [] at wf, induction wf; cases e,</code></p>



<a name="200532353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532353">(Jun 11 2020 at 11:37)</a>:</h4>
<p>Oh okay I do have more questions about what's going on here in this example so I'll paste it anyway</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span> <span class="bp">`</span> <span class="n">A</span> <span class="bp">`</span> <span class="bp">|</span> <span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wf</span><span class="o">,</span>

<span class="kn">end</span>
</code></pre></div>



<a name="200532368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532368">(Jun 11 2020 at 11:37)</a>:</h4>
<p>The recent <code>generalizes</code> tactic by <span class="user-mention" data-user-id="256311">@Jannis Limperg</span> should help with this in the dependent case. I believe that is part of a larger induction tactic but that hasn't been merged AFAIK</p>



<a name="200532378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532378">(Jun 11 2020 at 11:37)</a>:</h4>
<p>Firstly, why does the variable <code>wf</code> become a context in the states?</p>



<a name="200532386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532386">(Jun 11 2020 at 11:37)</a>:</h4>
<p>that's just a <code>cases</code> proof</p>



<a name="200532425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532425">(Jun 11 2020 at 11:38)</a>:</h4>
<p>no need for induction</p>



<a name="200532466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532466">(Jun 11 2020 at 11:38)</a>:</h4>
<p>Yeah I know I've done this proof before, it's just a simpler example for me to understand</p>



<a name="200532470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532470">(Jun 11 2020 at 11:38)</a>:</h4>
<blockquote>
<p>Firstly, why does the variable wf become a context in the states?</p>
</blockquote>
<p>The induction variables need names, and these names are derived from the input variable when possible</p>



<a name="200532528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532528">(Jun 11 2020 at 11:39)</a>:</h4>
<p>If you at all care, or if you need to refer to the variables, you should use <code>induction with</code> or <code>case</code> to name the variables</p>



<a name="200532563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532563">(Jun 11 2020 at 11:39)</a>:</h4>
<p>Does it get the same name because there's only one inductive variable, hence no need for the <code>wf_</code> form variables?</p>



<a name="200532573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532573">(Jun 11 2020 at 11:39)</a>:</h4>
<p>yes</p>



<a name="200532719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532719">(Jun 11 2020 at 11:41)</a>:</h4>
<p>Here's how you can prove that theorem using <code>induction</code> instead of <code>cases</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">generalize</span> <span class="n">e1</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">=</span> <span class="err">Γ</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wf</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e1</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200532851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532851">(Jun 11 2020 at 11:43)</a>:</h4>
<p>Note that this process of generalizing and casing on the equality cuts down on the cases to prove, but does so at the cost of making the induction hypotheses useless:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">...</span>
<span class="n">wf_ih_a</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">→</span> <span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="err">Ω</span> <span class="n">p</span><span class="o">,</span>
<span class="n">wf_ih_a_1</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">→</span> <span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="err">Ω</span> <span class="n">p</span><span class="o">,</span>
</code></pre></div>



<a name="200532973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532973">(Jun 11 2020 at 11:45)</a>:</h4>
<p>I don't quite see what ties the <code>[]</code> or the <code>Γ</code> in <code>e1</code> to anything that appears in the inductive state.</p>



<a name="200532981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200532981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200532981">(Jun 11 2020 at 11:45)</a>:</h4>
<p>this is why <code>cases</code> and <code>induction</code> use different default motives even though they both boil down to an application of the recursor. In <code>cases</code> you are saying explicitly that you don't care about induction hypotheses so we can add as many assumptions as we like to the induction motive to say that we are only inducting on something equal to the input, and so kill all the unnecessary cases. In <code>induction</code> we want to generalize the induction hypothesis so we just suck in all assumptions from the context and generalize arguments as specified by <code>generalizing</code></p>



<a name="200533080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533080">(Jun 11 2020 at 11:46)</a>:</h4>
<p>What we are doing is proving <code>WF Γ Ω a → ([] = Γ → p ⋀ q = a → WF Γ Ω p)</code> by induction</p>



<a name="200533117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533117">(Jun 11 2020 at 11:46)</a>:</h4>
<p>How are the Gammas the same Gamma in both appearances there?</p>



<a name="200533135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533135">(Jun 11 2020 at 11:47)</a>:</h4>
<p>that is, the motive is <code>λ Γ A a, [] = Γ → p ⋀ q = a → WF Γ A p</code></p>



<a name="200533271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533271">(Jun 11 2020 at 11:49)</a>:</h4>
<p>Oh is it because <code>generalize e1 : [] = Γ</code> looks at the target and looks for instances of <code>[]</code>?</p>



<a name="200533287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533287">(Jun 11 2020 at 11:49)</a>:</h4>
<p>Remember what the recursor says. You are proving that <code>\forall Γ A a, WF Γ A a -&gt; C Γ A a</code> and this is how we are picking <code>C</code></p>



<a name="200533314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533314">(Jun 11 2020 at 11:49)</a>:</h4>
<p>Yes, <code>generalize</code> automatically replaces instances of <code>[]</code> with <code>Γ</code></p>



<a name="200533384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533384">(Jun 11 2020 at 11:50)</a>:</h4>
<p>You can also state this explicitly, which I do sometimes when getting the exact induction hypothesis right is more difficult</p>



<a name="200533565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533565">(Jun 11 2020 at 11:52)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">wf</span><span class="o">,</span> <span class="n">this</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">wf</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wf</span><span class="bp">;</span> <span class="n">rintro</span> <span class="bp">⟨⟩</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200533664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200533664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200533664">(Jun 11 2020 at 11:53)</a>:</h4>
<p>this is the most general and powerful form of induction since you can state the induction hypothesis however you wish</p>



<a name="200534084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200534084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200534084">(Jun 11 2020 at 11:58)</a>:</h4>
<p>For example in my recent proof <a href="https://github.com/leanprover-community/mathlib/blob/5129aed/src/computability/tm_to_partrec.lean">tm_to_partrec.lean</a> if you search for <code>induction</code> you will find a significant fraction of them are preceded by a <code>suffices</code>, for example in <a href="https://leanprover-community.github.io/mathlib_docs/find/turing.partrec_to_TM2.succ_ok/src">src#turing.partrec_to_TM2.succ_ok</a></p>



<a name="200534176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200534176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200534176">(Jun 11 2020 at 11:59)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/5129aed/src/computability/tm_to_partrec.lean#L224-L235">Here's</a> another good example</p>



<a name="200534489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200534489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200534489">(Jun 11 2020 at 12:02)</a>:</h4>
<p>the <code>∀ a b, a + b = n → ...</code> is hard for lean to guess automatically. (Without going into details, we are proving a fact about <code>P n 0</code> by induction given <code>P 0 n</code> and <code>P a b -&gt; P (a+1) (b-1)</code>.)</p>



<a name="200535193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200535193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200535193">(Jun 11 2020 at 12:10)</a>:</h4>
<p>Cool that looks like a useful practice.</p>



<a name="200535749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200535749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200535749">(Jun 11 2020 at 12:16)</a>:</h4>
<p>This bottom lemma is what I'm actually trying to prove - I should be able to prove all cases at once, but there's an "list.nil = list.nil -&gt;" in front of all of my inductive hypotheses - can I eliminate them all in one go?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">namespace</span> <span class="n">TT</span>
<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span> <span class="bp">`</span> <span class="n">A</span> <span class="bp">`</span> <span class="bp">|</span> <span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">substitution</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift_d</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>     <span class="o">:=</span>   <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift</span> <span class="o">:=</span> <span class="n">lift_d</span> <span class="mi">1</span> <span class="mi">0</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">c</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span>   <span class="o">:=</span>    <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

  <span class="kn">notation</span>  <span class="bp">`</span><span class="err">⁅</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="bp">//</span> <span class="bp">`</span>  <span class="n">b</span> <span class="bp">`</span><span class="err">⁆</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="mi">0</span> <span class="n">b</span> <span class="n">φ</span>

  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span><span class="mi">𝟘</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span> <span class="mi">𝟙</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>

<span class="kn">end</span> <span class="n">substitution</span>

<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_closed</span> <span class="o">{</span><span class="n">a</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">lift</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">generalize_hyp</span> <span class="n">e</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">=</span> <span class="err">Γ</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wf</span><span class="bp">;</span><span class="n">cases</span> <span class="n">e</span><span class="bp">;</span><span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">TT</span>
</code></pre></div>



<a name="200536221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200536221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200536221">(Jun 11 2020 at 12:21)</a>:</h4>
<p>You will need a stronger inductive hypothesis</p>



<a name="200536468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200536468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200536468">(Jun 11 2020 at 12:24)</a>:</h4>
<p><code>simp</code> will do a lot of the work here, although it doesn't like that you wrote the equality the wrong way around</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_closed</span> <span class="o">{</span><span class="n">a</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">lift</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">generalize_hyp</span> <span class="n">e</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">=</span> <span class="err">Γ</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wf</span><span class="bp">;</span><span class="n">cases</span> <span class="n">e</span><span class="bp">;</span><span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>

<span class="kn">end</span>
</code></pre></div>



<a name="200536604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200536604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200536604">(Jun 11 2020 at 12:25)</a>:</h4>
<p>What do the stars do?</p>



<a name="200536668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200536668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200536668">(Jun 11 2020 at 12:26)</a>:</h4>
<p>they make the sky more beautiful</p>



<a name="200536760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200536760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200536760">(Jun 11 2020 at 12:26)</a>:</h4>
<p>Hahaha, oh I found the docs explaining what they are too</p>



<a name="200537029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200537029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200537029">(Jun 11 2020 at 12:29)</a>:</h4>
<p>Lemme guess, I need to be proving the strong lemma which says "if the highest free variable is below the lift-cutoff, then <code>lift a = a</code>"</p>



<a name="200537202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200537202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200537202">(Jun 11 2020 at 12:30)</a>:</h4>
<p>Indeed. I believe the most similar statement to what you have here that will do the job is <code>WF G A a → length G &lt;= k -&gt; lift_d 1 k a = a</code></p>



<a name="200537737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200537737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200537737">(Jun 11 2020 at 12:36)</a>:</h4>
<p>This is an interesting pattern - the most "appropriately general" statement of a theorem is typically easier to prove than specialisations of that theorem. Is this specific to inductive proofs or formal proofs in general?</p>



<a name="200538007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538007">(Jun 11 2020 at 12:39)</a>:</h4>
<p>this is pretty common of inductive proofs</p>



<a name="200538180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538180">(Jun 11 2020 at 12:40)</a>:</h4>
<p>the examples I showed earlier were also of that form - I said that I wanted to prove something about <code>P n 0</code> but the obvious inductive proof would try to show <code>P 0 0</code> and <code>P a 0 -&gt; P (a+1) 0</code> which doesn't work</p>



<a name="200538278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538278">(Jun 11 2020 at 12:41)</a>:</h4>
<p>induction proofs can vary a lot in their dependency structure, so the easiest reliable way to make lean do what you want is to say what you want</p>



<a name="200538330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538330">(Jun 11 2020 at 12:41)</a>:</h4>
<p>(unfortunately this is also quite verbose so I usually use it as a last resort when basic <code>induction</code> doesn't do the right thing)</p>



<a name="200538331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538331">(Jun 11 2020 at 12:41)</a>:</h4>
<p>You're referring to the suffices pattern?</p>



<a name="200538344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538344">(Jun 11 2020 at 12:42)</a>:</h4>
<p>yes</p>



<a name="200538390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538390">(Jun 11 2020 at 12:42)</a>:</h4>
<p>You could use it here too</p>



<a name="200538704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200538704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200538704">(Jun 11 2020 at 12:45)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lift_closed</span> <span class="o">{</span><span class="n">a</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">lift</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">WF</span> <span class="n">G</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">lift_d</span> <span class="mi">1</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">G</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="n">introv</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">wf</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">if_neg</span> <span class="o">(</span><span class="n">not_le_of_gt</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nth_eq_some</span><span class="bp">.</span><span class="mi">1</span> <span class="n">wf_a</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200540330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200540330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200540330">(Jun 11 2020 at 13:00)</a>:</h4>
<p>So I've been doing all of this stuff for a 1 semester project (I convinced a mathematician at my uni to supervise me for a project in Lean), and I'm going to be ending it on "here's a statement in Lean that says this type theory forms a category". Once the semester is over (very soon) I want to go back to the basics of Lean so I'm better equipped to actual prove all the theorems</p>
<p>From what you've seen from me, is there any particular ways you'd recommend learning the relevant intricacies of Lean I need to understand how to do my proofs? Do the mathematics tutorials (NNG, Real Number Game etc) cover the same stuff but on different topics? Should I keep posting "how do I do this proof" whenever I get to a new roadblock? Usually the easiest answer (like this time) is just "here's the proof" and I feel bad that I'm just constantly getting other people to do my work for me. Thoughts?</p>



<a name="200541640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200541640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200541640">(Jun 11 2020 at 13:11)</a>:</h4>
<p>the point isn't "here's the proof", it is "here's a technique for solving problems of this kind"</p>



<a name="200541695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200541695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200541695">(Jun 11 2020 at 13:11)</a>:</h4>
<p>don't worry about my having "stolen" a proof from you, trust me there are more than enough proof obligations to go around</p>



<a name="200541978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200541978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200541978">(Jun 11 2020 at 13:14)</a>:</h4>
<p>For a type theory category, I suggest jumping into the formalization and asking questions when you don't know how to express something</p>



<a name="200542088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200542088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200542088">(Jun 11 2020 at 13:15)</a>:</h4>
<p>My sense is that it should not be too difficult to write something down that vaguely resembles your goal statement. There will then be some rearranging and fixing of the definition to make it amenable to proof stuff</p>



<a name="200542334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200542334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200542334">(Jun 11 2020 at 13:17)</a>:</h4>
<p>For the first pass, figure out what a category is: if you intend to use mathlib categories, then study the mathlib definition of a category, or if you plan to write your own then figure out how to make that definition. You said something about quotienting by equivalence, so figure out how to write down a quotient and specify functions on quotients. Don't concern yourself with proofs too much, but try not to write something that you know is false</p>



<a name="200542453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200542453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200542453">(Jun 11 2020 at 13:18)</a>:</h4>
<p>I think the best way to learn about intricacies of lean is to trip over them on your way to getting something done</p>



<a name="200543320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200543320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200543320">(Jun 11 2020 at 13:26)</a>:</h4>
<p>Thanks, that's good to hear. My concern is less about intellectual property (though that's important), and more about using up your time!</p>
<p>At a basic level, I do understand how to define a math lib category and I feel somewhat comfortable with quotient stuff (I've followed the Zmod37 example and created my own quotient type), but one of my roadblocks there is how to say the following theorem (which I hope is true), "If I have a <code>proof Γ p q</code> and either of <code>p</code> or <code>q</code> contains some <code>a : term</code> which is well-formed of type A (<code>WF Γ A a</code>), and <code>a</code> is provably equal to <code>a'</code> (I can show <code>proof Γ ⊤ a ≃[A] a'</code>), then I can swap out occurrences of <code>a</code> with <code>a'</code>. I think that would help me a lot with lifting things to the quotients.</p>



<a name="200543348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200543348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200543348">(Jun 11 2020 at 13:26)</a>:</h4>
<p>ah whoops sent too soon, I'll edit it (done)</p>



<a name="200544707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200544707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200544707">(Jun 11 2020 at 13:37)</a>:</h4>
<p>Here's an attempt which I'm worried is too general and false.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">eq_sound</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">eq</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="n">a₁</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">a₂</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">f</span> <span class="n">a₁</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">→</span> <span class="k">proof</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">f</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">a₂</span><span class="o">)</span>
</code></pre></div>


<p>(made it a <code>theorem</code> because wew, it looks powerful.)</p>



<a name="200544907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200544907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200544907">(Jun 11 2020 at 13:38)</a>:</h4>
<p>yeah that version is false</p>



<a name="200545001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200545001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200545001">(Jun 11 2020 at 13:39)</a>:</h4>
<p>Good to know</p>



<a name="200545035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200545035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200545035">(Jun 11 2020 at 13:39)</a>:</h4>
<p>Do you have a substitution operator? If so you can express that <code>t[a1/x] = t[a2/x]</code> is provable</p>



<a name="200545555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200545555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200545555">(Jun 11 2020 at 13:43)</a>:</h4>
<p>You can also define a subset of functions <code>term -&gt; term</code> according to whether they respect equality. The theorem holds for such functions more or less by definition, but the interesting observation is that all the term constructors are examples of such functions</p>



<a name="200546839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200546839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200546839">(Jun 11 2020 at 13:53)</a>:</h4>
<p>I actually tried that substitution method but I found it difficult to apply it. Thinking about the second option - that sounds like you could inductively define all such functions based on the term constructors?</p>



<a name="200547019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200547019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200547019">(Jun 11 2020 at 13:55)</a>:</h4>
<p>How would one say "a function which is just some composition of the term constructors?"</p>



<a name="200547215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200547215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200547215">(Jun 11 2020 at 13:56)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span> I'd be very happy if you could try the current version of my induction tactic. It should take care of all the generalising for you and give less scary names as a bonus. The current draft is at <a href="https://github.com/leanprover-community/mathlib/tree/induction">the induction branch</a>. When you have that, you should be able to <code>import tactic.induction</code> and use <code>induction'</code> instead of the <code>generalize ..., induction</code> dance. I'll gladly fix any bugs you find.</p>



<a name="200547659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200547659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200547659">(Jun 11 2020 at 13:59)</a>:</h4>
<p>Oh cool! I will gladly do so :)</p>



<a name="200548231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200548231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200548231">(Jun 11 2020 at 14:03)</a>:</h4>
<blockquote>
<p>How would one say "a function which is just some composition of the term constructors?"</p>
</blockquote>
<p>Of course the import of the substitution operator is that it is a way to represent such functions using terms</p>



<a name="200548505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200548505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200548505">(Jun 11 2020 at 14:05)</a>:</h4>
<p>The simpler alternative is just to prove in each individual case that a concretely given function satisfies the equality property by applying equality axioms using e.g. <code>apply_rules</code></p>



<a name="200549542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200549542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200549542">(Jun 11 2020 at 14:13)</a>:</h4>
<p>What do you mean by the equality axioms?</p>



<a name="200612610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200612610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200612610">(Jun 11 2020 at 22:00)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span> the way to learn the intricacies of Lean is to have a healthy source of projects in your area of interest and then just keep formalising and ask whenever you get stuck. After a few months (maybe it took me a year but I am old and have no CS background) you find that you're asking fewer questions and are in fact now answering them.</p>



<a name="200629225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629225">(Jun 12 2020 at 02:25)</a>:</h4>
<p>Tada I did a proof, I think I better understand the idea of generalising hypotheses in induction now. <span class="user-mention" data-user-id="256311">@Jannis Limperg</span>  I haven't yet switched to the induction branch to try your tactic - how do I do that?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">lift_zero_does_nothing</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">}</span> <span class="o">:</span> <span class="n">lift_d</span> <span class="mi">0</span> <span class="n">k</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">lift_d</span> <span class="mi">0</span> <span class="n">k</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="n">induction</span> <span class="n">a</span><span class="bp">;</span><span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>Let me phrase some subtlety I was overlooking before (lemme know if this is the wrong way of thinking about it): Although <code>k</code> is an arbitrary hypothesis to the lemma, within the goal state, it's thought of as fixed. It's a 'given' number. So without the suffices line, the inductive cases must be proved for that fixed <code>k</code>. This seems to highlight the subtle difference between <code>example (k : nat) : P k</code> and <code>example :  ∀ k : nat, P k</code>.</p>



<a name="200629316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629316">(Jun 12 2020 at 02:27)</a>:</h4>
<p>I could make my original lemma <code>lemma lift_zero_does_nothing {a : term} : ∀ k, lift_d 0 k a = a</code>, but that would make it less usable right?</p>



<a name="200629396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629396">(Jun 12 2020 at 02:29)</a>:</h4>
<p>More succinct</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">lift_zero_does_nothing</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">}</span> <span class="o">:</span> <span class="n">lift_d</span> <span class="mi">0</span> <span class="n">k</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="k">by</span> <span class="n">induction</span> <span class="n">a</span> <span class="n">generalizing</span> <span class="n">k</span><span class="bp">;</span><span class="n">simp</span> <span class="bp">*</span>
</code></pre></div>



<a name="200629673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629673">(Jun 12 2020 at 02:35)</a>:</h4>
<blockquote>
<p>Although k is an arbitrary hypothesis to the lemma, within the goal state, it's thought of as fixed. It's a 'given' number. So without the suffices line, the inductive cases must be proved for that fixed k. </p>
</blockquote>
<p>Yes and no. The <code>induction</code> tactic will generalize the variable <code>k</code>, ignoring the initial value that it had. It's just that when the input was a variable to start with this is no loss (but you will see <code>k</code> hanging around uselessly in the inductive subcases)</p>



<a name="200629755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629755">(Jun 12 2020 at 02:36)</a>:</h4>
<blockquote>
<p>I could make my original lemma <code>lemma lift_zero_does_nothing {a : term} : ∀ k, lift_d 0 k a = a</code>, but that would make it less usable right?</p>
</blockquote>
<p>Externally these are indistinguishable, except that you reordered the two variables and made <code>k</code> explicit in this version</p>



<a name="200629820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629820">(Jun 12 2020 at 02:38)</a>:</h4>
<p>In tactic mode you will always end up intro'ing all variables before the induction, so it makes no difference what is "right of the colon". This does affect inductive proofs performed using the equation compiler though (you will not be able to use the equation compiler with the first version)</p>



<a name="200629901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200629901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200629901">(Jun 12 2020 at 02:40)</a>:</h4>
<p>Oh, correction: since you are doing induction on <code>term</code> in this case, there are no indices and so <code>k</code> will be held fixed unless you explicitly use <code>generalizing</code> to indicate that you want it to change</p>



<a name="200666618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200666618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200666618">(Jun 12 2020 at 13:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/200629225">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span>  I haven't yet switched to the induction branch to try your tactic - how do I do that?</p>
</blockquote>
<p>Could you post your leanpkg.toml? Alternatively put your project on Github or something, then I'll see what needs to be changed.</p>



<a name="200699109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200699109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200699109">(Jun 12 2020 at 17:25)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span> the answer depends on whether you're working in mathlib or working on your own project and have mathlib as a dependency. If you have mathlib as a dependency then you probably have to edit your project's <code>leanpkg.toml</code>. <span class="user-mention" data-user-id="256311">@Jannis Limperg</span> 's branch is here <a href="https://github.com/leanprover-community/mathlib/commits/induction">https://github.com/leanprover-community/mathlib/commits/induction</a> and the most recent commit is <code>52c995b6ee3ed40c6c962043e8bdd37176a942e3</code> so you want to change your mathlib <code>rev</code> to that commit hash and then do <code>leanproject get-mathlib-cache</code> in the root directory of your project, and it should then all work by magic.</p>



<a name="200699306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/200699306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#200699306">(Jun 12 2020 at 17:27)</a>:</h4>
<p>If you're working in mathlib directory then you might be able to just checkout the induction branch and then do <code>leanproject up</code>.</p>



<a name="201230382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201230382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201230382">(Jun 18 2020 at 05:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195564583">said</a>:</p>
<blockquote>
<p>I would recommend keeping the term syntax as context free as possible, and have a well typing condition afterward that can have whatever dependencies it wants</p>
</blockquote>
<p>I'm currently reflecting on the decisions I made for the definitions in my type theory, and I'm trying to justify why terms and Well-formedness are defined separately - it seemed that I had to do a lot of work later regarding lemmas to prove well-formedness. Would this have not gone away if I defined only well-formed terms? Are there more obvious reasons why keeping terms context free is valuable?</p>



<a name="201238475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201238475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201238475">(Jun 18 2020 at 08:04)</a>:</h4>
<p>If you find yourself manually constructing terms with a proof of well formedness a lot (for example if you are acting like a typechecker and have some concrete terms of interest), then one thing you can do is construct a sigma type of a term and a proof of its well foundedness, and then the construction of the term will be carried out in parallel with the proof of well foundedness. Here a separate WF proof is not particularly helpful. (This is done in the flypitch formalization, for example.)</p>
<p>The advantage comes when you are doing metatheory, which is usually what people want to do with defined type theories such as this inside lean. (If you just want a typechecker, it is often simpler to just write one directly in a standard programming language, as the many proof assistants for HoTT-based type theories can attest.) Here you really want to be able to do things like reassociate contexts or do other non-defeq manipulations inside the indices to the <code>WF</code> inductive, and then if <code>WF</code> is not a <code>Prop</code> but is rather a dependent type of well formed terms, this will cause no end of headaches due to the induced cast.</p>



<a name="201346025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201346025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201346025">(Jun 19 2020 at 02:10)</a>:</h4>
<p>I think you've interpreted my question as "I'm sick of the separation of terms and Well-formedness, so how can I remedy that in the current setup (thanks for the suggestions), but I'm interested in what are the downsides of doing it all in one with <code>term : context -&gt; type -&gt; Type</code>. I think you were answering that in this reply - but could you explain what you mean here about carrying around type state, and what definitional equalities are hard to get?</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195565908">said</a>:</p>
<blockquote>
<p>It's easier for them because it's only one type, yes. You end up having to carry around a lot of "type state" in real type theories, and it becomes hard to get all the definitional equalities you want</p>
</blockquote>



<a name="201347368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347368">(Jun 19 2020 at 02:47)</a>:</h4>
<p>I mean the context and the type</p>



<a name="201347422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347422">(Jun 19 2020 at 02:48)</a>:</h4>
<p>Hard to get definitional equalities are things like <code>Gamma ++ a :: Delta = (Gamma ++ [a]) ++ Delta</code> that come up in proofs</p>



<a name="201347438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347438">(Jun 19 2020 at 02:48)</a>:</h4>
<p>it's even worse when <code>Gamma</code> itself has sequential dependencies as in dependent type theory</p>



<a name="201347532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347532">(Jun 19 2020 at 02:51)</a>:</h4>
<p>If you have a term <code>Gamma ++ a :: Delta |- e : A</code> and want the same term <code>(Gamma ++ [a]) ++ Delta |- e : A</code> you can't do the obvious thing. Instead you have to cast <code>e</code> to the new context, and now it's not a constructor so you can't pattern match on it, and things sort of go downhill from there</p>



<a name="201347584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347584">(Jun 19 2020 at 02:52)</a>:</h4>
<p>It's certainly possible to construct things so that everything beautifully meshes together. But this is like a sudoku puzzle, a quite mind bending exercise that has little relation to the original problem you set out to solve</p>



<a name="201347651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347651">(Jun 19 2020 at 02:54)</a>:</h4>
<p>If you like that sort of thing it's possible to build a career on it but you might find that you've left your original problem behind. (I would argue this is what happened to Voevodsky with HoTT)</p>



<a name="201347727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201347727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201347727">(Jun 19 2020 at 02:56)</a>:</h4>
<p>If you have extrinsic typing, then you can transport terms to new contexts without apology. All the ugliness is encapsulated in proofs that don't interfere with later statements because of proof irrelevance</p>



<a name="201348053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348053">(Jun 19 2020 at 03:05)</a>:</h4>
<p>Ah okay I think I follow. If we dump the context from the constructor, is the remaining problem just that it's hard to define the <code>var</code> constructor with no context? Or are there still downsides without the var problem?</p>



<a name="201348174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348174">(Jun 19 2020 at 03:09)</a>:</h4>
<p>I like to think about indices to dependent types as "rigid variables". Variables in these positions can only be manipulated in very restrictive ways, essentially by applying constructors and pattern matching. Using functions defined by induction is a no-no</p>



<a name="201348188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348188">(Jun 19 2020 at 03:09)</a>:</h4>
<p>This mostly matches the way we treat types in <em>simple</em> type theory</p>



<a name="201348245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348245">(Jun 19 2020 at 03:10)</a>:</h4>
<p>for example a <code>list A</code> is not the same as a <code>list A'</code> even if <code>A</code>  and <code>A'</code> are extensionally equivalent (have the same elements or some other synthetic notion of equality)</p>



<a name="201348357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348357">(Jun 19 2020 at 03:13)</a>:</h4>
<p>I get what you're saying but I don't see the relevance</p>



<a name="201348407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348407">(Jun 19 2020 at 03:14)</a>:</h4>
<p>If you take the context out of a term, it just has a type, and presumably the inductive type <code>type</code> is a simple inductive. So this is plausible. But variables have a weird type in this context: you didn't do this but a classically reasonable alternative type for the <code>var</code> constructor would have been <code>var (i : fin (length G)) : term G (G.nth' i)</code> but this is a bad idea in DTT</p>



<a name="201348428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348428">(Jun 19 2020 at 03:15)</a>:</h4>
<p>because it uses inductive functions in rigid positions twice: once in <code>fin (length G)</code> and once in <code>term G (G.nth' i)</code></p>



<a name="201348629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348629">(Jun 19 2020 at 03:21)</a>:</h4>
<p>That's still <code>term : context -&gt; type -&gt; Type</code> though?</p>



<a name="201348698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348698">(Jun 19 2020 at 03:22)</a>:</h4>
<p>well you can't write <code>var</code> at all without a context</p>



<a name="201348701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348701">(Jun 19 2020 at 03:23)</a>:</h4>
<p>it could be a parameter though</p>



<a name="201348705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348705">(Jun 19 2020 at 03:23)</a>:</h4>
<p>as long as you don't also have binders</p>



<a name="201348751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348751">(Jun 19 2020 at 03:24)</a>:</h4>
<p>parameters to inductive types are also rigid variables, but you usually don't have as pressing a need to change them in the middle of a proof</p>



<a name="201348827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348827">(Jun 19 2020 at 03:26)</a>:</h4>
<p>What do you mean by parameter as opposed to a rigid variable?</p>



<a name="201348836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348836">(Jun 19 2020 at 03:27)</a>:</h4>
<p>parameters to inductive types meaning left of the colon</p>



<a name="201348841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348841">(Jun 19 2020 at 03:27)</a>:</h4>
<p><code>inductive term (G : context) : type -&gt; Type</code></p>



<a name="201348847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348847">(Jun 19 2020 at 03:27)</a>:</h4>
<p>Then the <code>G</code> in <code>term G A</code> is a rigid variable</p>



<a name="201348914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201348914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201348914">(Jun 19 2020 at 03:29)</a>:</h4>
<p>One way to conceptualize rigid variables are as terms about which it is common to have equalities, like <code>list.append_assoc</code>, but for which <code>simp</code> refuses to touch and <code>rw</code> gives <code>motive is not type correct</code> when you try to use those equalities</p>



<a name="201349029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201349029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201349029">(Jun 19 2020 at 03:32)</a>:</h4>
<p>as long as you only ever do syntactic or defeq matching in rigid positions there are no problems</p>



<a name="201353396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201353396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201353396">(Jun 19 2020 at 05:18)</a>:</h4>
<p>Okay.</p>



<a name="201353679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201353679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201353679">(Jun 19 2020 at 05:25)</a>:</h4>
<p>By the way, my type theory as it is, is the "pure" version, which is supposed to be extensible. How would I go about defining a type theory which has at least everything I've defined, but maybe more types, more terms, more deduction rules etc? For example, if I wanted to throw in a <code>mynat : type</code> and corresponding terms which are <code>WF [] mynat</code>? I imagine doing so would ruin all the lemmas I've proved. All my lemmas just talk about stuff in the pure type theory, so they should hold in any extension (I imagine there are pathological counterexamples depending on the generality of the lemma).</p>



<a name="201354093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201354093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201354093">(Jun 19 2020 at 05:35)</a>:</h4>
<p>Just an idea that probably doesn't work because of cardinality.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variable</span> <span class="err">\</span><span class="n">alpha</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">special</span> <span class="o">(</span><span class="err">\</span><span class="n">alpha</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>
</code></pre></div>



<a name="201355255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201355255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201355255">(Jun 19 2020 at 05:58)</a>:</h4>
<p>That works fine</p>



<a name="201355279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201355279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201355279">(Jun 19 2020 at 05:59)</a>:</h4>
<p>you have to parameterize the whole theory over alpha which is kind of annoying but otherwise it works well</p>



<a name="201355296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201355296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201355296">(Jun 19 2020 at 06:00)</a>:</h4>
<p>It's also not very pleasant to actually instantiate and get this nested inductive type of types with more types inside</p>



<a name="201355523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201355523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201355523">(Jun 19 2020 at 06:04)</a>:</h4>
<p>Since you are wondering about universe issues: note that <code>alpha</code> will usually be a small type, for example <code>inductive base_types | nat | bool | real | extra_special (beta : Type)</code> where perhaps beta is yet another parameter</p>



<a name="201357426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201357426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201357426">(Jun 19 2020 at 06:46)</a>:</h4>
<p>Ah whoops I made \alpha a variable and a parameter at the same time. I have two possible ideas below, both of which I think are ugly - is there not a more natural way to do this? Instead of taking some other variable Type and incorporating it into my definition, I just say to the user "give me a Type of things which I will think of as types in my theory, as long Unit, Omega are of that type and the Pow, Prod constructors make new types out of old ones". I am somewhat ambivalent to whether Unit and Omega are naturally a part of the type of types that the user creates or if they are just tacked on.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variable</span> <span class="err">\</span><span class="n">alpha</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">special</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="err">\</span><span class="n">alpha</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>
</code></pre></div>


<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">special</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>
</code></pre></div>



<a name="201357459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201357459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201357459">(Jun 19 2020 at 06:47)</a>:</h4>
<p>Regarding my 2 ideas, I have a feeling the second one is fundamentally different (perhaps the wrong idea).</p>



<a name="201357533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201357533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201357533">(Jun 19 2020 at 06:48)</a>:</h4>
<p>Perhaps my "give me.." idea is more in the spirit of a type class?</p>



<a name="201358699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358699">(Jun 19 2020 at 07:11)</a>:</h4>
<p>the second one should not typecheck</p>



<a name="201358701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358701">(Jun 19 2020 at 07:11)</a>:</h4>
<p>because there is a universe issue</p>



<a name="201358761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358761">(Jun 19 2020 at 07:12)</a>:</h4>
<p>You want the first one</p>



<a name="201358774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358774">(Jun 19 2020 at 07:12)</a>:</h4>
<blockquote>
<p>I just say to the user "give me a Type of things which I will think of as types in my theory, as long Unit, Omega are of that type and the Pow, Prod constructors make new types out of old ones".</p>
</blockquote>
<p><span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span> this</p>



<a name="201358803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358803">(Jun 19 2020 at 07:13)</a>:</h4>
<p>oh wait you mean it's not an inductive type at all</p>



<a name="201358816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358816">(Jun 19 2020 at 07:13)</a>:</h4>
<p>you can do that, and the interface will be nicer, but you will not be able to prove theorems about the PTS by induction anymore</p>



<a name="201358905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201358905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201358905">(Jun 19 2020 at 07:15)</a>:</h4>
<p>You could prove theorems relative to a partial recursor that the user also provides, but then every theorem is going to come with side conditions saying that the theorem already holds in some way for all the types the PTS doesn't know about</p>



<a name="201371137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201371137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201371137">(Jun 19 2020 at 09:56)</a>:</h4>
<p>Good to know, I think I'll stick with my pure type theory for now.</p>



<a name="201371730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201371730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201371730">(Jun 19 2020 at 10:04)</a>:</h4>
<p>I just realised I could do this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">nat_coe_var</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℕ</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">term</span><span class="bp">.</span><span class="n">var</span><span class="bp">⟩</span>
</code></pre></div>


<p>instead of this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>
</code></pre></div>


<p>is the coercion one a bad idea?</p>



<a name="201371878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201371878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201371878">(Jun 19 2020 at 10:06)</a>:</h4>
<p>Or is there any way I can do a unique term construction like <code>⟨0⟩</code> since there's only one term constructor that takes a single (nat) argument?</p>



<a name="201371919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201371919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201371919">(Jun 19 2020 at 10:07)</a>:</h4>
<p>It doesn't work out of the box, because it expects term to only have one term constructor.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
</code></pre></div>



<a name="201417617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201417617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201417617">(Jun 19 2020 at 17:14)</a>:</h4>
<p>I mean it's fine, but it will never be particularly nice to write terms with de bruijn variables</p>



<a name="201463189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201463189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201463189">(Jun 20 2020 at 05:26)</a>:</h4>
<p>Why does this happen? I write <code>rw append_nil Γ</code> in this state and it tells me</p>
<p><code>rewrite tactic failed, did not find instance of the pattern in the target expression
  Γ ++ nil</code></p>
<p>¿que?</p>
<div class="codehilite"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">),</span>
<span class="n">eq</span> <span class="o">:</span> <span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span>
<span class="err">⊢</span> <span class="n">WF</span> <span class="o">(</span><span class="err">Γ</span> <span class="bp">++</span> <span class="n">nil</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="201464178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201464178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201464178">(Jun 20 2020 at 06:01)</a>:</h4>
<p>Also how would I do <code>apply_rules</code> on all of the hypotheses? (to extract more hypotheses) Or on one hypothesis? Something like <code>simp at *</code></p>
<p>(Not for this goal state)</p>



<a name="201466023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201466023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201466023">(Jun 20 2020 at 07:06)</a>:</h4>
<p>I can't say offhand why that would fail. <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="201516521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201516521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201516521">(Jun 21 2020 at 04:41)</a>:</h4>
<p>I'll come back to this one.</p>



<a name="201516685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201516685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201516685">(Jun 21 2020 at 04:46)</a>:</h4>
<p>Is there any practical difference between these two code blocks? I'd like to treat <code>WF.foo : Prop</code> just like the inductively defined lemmas.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="mi">𝟙</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">WF</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">end</span>
</code></pre></div>


<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="mi">𝟙</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">foo</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="201516697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201516697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201516697">(Jun 21 2020 at 04:47)</a>:</h4>
<p>Related question - is <code>WF</code> a namespace in <code>WF.star</code>?</p>



<a name="201516700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201516700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201516700">(Jun 21 2020 at 04:47)</a>:</h4>
<p>In the same way that <code>WF</code> is a namespace in <code>WF.foo</code> in the first code block</p>



<a name="201516748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201516748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201516748">(Jun 21 2020 at 04:49)</a>:</h4>
<p>no difference, yes it is a namespace</p>



<a name="201516752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201516752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201516752">(Jun 21 2020 at 04:49)</a>:</h4>
<p>one difference is that the <code>WF</code> namespace is open inside the proof of <code>foo</code> in the first case but not the second</p>



<a name="201606364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201606364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201606364">(Jun 22 2020 at 13:39)</a>:</h4>
<p>Is there a proper way to write this meta definition? I'll do my best to render the backticks properly. <code>meta def WF_prover : tactic unit:= do `[apply_rules WF_rules]</code>.</p>
<p>It works for the most part but where I could previously do <code>apply_rules WF_rules; refl</code>, I cannot now do <code>WF_prover; refl</code>, with this error resulting.</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">WF_prover</span><span class="bp">;</span> <span class="n">refl</span>
<span class="n">term</span>
  <span class="n">refl</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="err">?</span><span class="n">m_1</span><span class="o">),</span> <span class="err">?</span><span class="n">m_2</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="err">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span>
</code></pre></div>


<p>I have to do <code>WF_prover, all_goals {refl}</code> (which works).</p>
<p>I'm guessing it's because I derived that meta definition from another one which sequenced several tactics, and I'm now just trying to rename one tactic.</p>



<a name="201607079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201607079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201607079">(Jun 22 2020 at 13:45)</a>:</h4>
<p>Here's a related <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (more like #mnwe)</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">my_split</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">split</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span><span class="n">assumption</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">my_split</span><span class="bp">;</span><span class="n">assumption</span> <span class="c1">-- doesn&#39;t work</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201607485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201607485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201607485">(Jun 22 2020 at 13:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">my_split</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">split</span><span class="o">]</span>
</code></pre></div>



<a name="201608502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201608502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201608502">(Jun 22 2020 at 13:57)</a>:</h4>
<p>I don't have a more minimal <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> for this, but the very last line here, it doesn't recognise <code>WF_prover</code></p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Definitions of a type theory</span>

<span class="cm">Author: Billy Price</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span>
<span class="kn">namespace</span> <span class="n">TT</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">𝕏</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>


<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="n">def</span> <span class="n">nat_coe_var</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℕ</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">term</span><span class="bp">.</span><span class="n">var</span><span class="bp">⟩</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">nat_coe_var</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>

<span class="n">def</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">⟹</span> <span class="err">⊥</span>
<span class="kn">prefix</span> <span class="bp">`</span><span class="err">∼</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">not</span> <span class="c1">-- input \~</span>

<span class="n">def</span> <span class="n">iff</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">iff</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">infix</span> <span class="err">∉</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">α</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">a</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="o">{{</span> <span class="bp">`</span> <span class="n">A</span> <span class="bp">`</span> <span class="bp">|</span> <span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="o">}}</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>

<span class="n">def</span> <span class="n">term</span><span class="bp">.</span><span class="n">all_chain</span> <span class="o">(</span><span class="err">Γ</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">:=</span> <span class="n">flip</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">A</span> <span class="n">ψ</span><span class="o">,</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span> <span class="n">A</span> <span class="n">ψ</span><span class="o">))</span> <span class="err">Γ</span>
<span class="n">def</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex_chain</span>  <span class="o">(</span><span class="err">Γ</span> <span class="o">:</span> <span class="n">list</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">:=</span> <span class="n">flip</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">A</span> <span class="n">ψ</span><span class="o">,</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span> <span class="n">A</span> <span class="n">ψ</span><span class="o">))</span> <span class="err">Γ</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">term</span><span class="bp">.</span><span class="n">unfold_all_chain</span> <span class="o">{</span><span class="n">A</span> <span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span><span class="bp">.</span><span class="n">all_chain</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="bp">=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">all_chain</span> <span class="err">Γ</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">term</span><span class="bp">.</span><span class="n">unfold_ex_chain</span> <span class="o">{</span><span class="n">A</span> <span class="err">Γ</span> <span class="n">φ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex_chain</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="bp">=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">ex_chain</span> <span class="err">Γ</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">notation</span> <span class="bp">`∀</span><span class="o">[</span><span class="bp">`</span> <span class="err">Γ</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all_chain</span> <span class="err">Γ</span>
<span class="kn">notation</span> <span class="bp">`∃</span><span class="o">[</span><span class="bp">`</span> <span class="err">Γ</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex_chain</span> <span class="err">Γ</span>

<span class="kn">section</span> <span class="n">substitution</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift_d</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift_d</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">{{</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="o">}}</span>     <span class="o">:=</span>   <span class="o">{{</span><span class="n">A</span> <span class="bp">|</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="o">}}</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift_d</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

  <span class="kn">notation</span> <span class="bp">`^`</span> <span class="o">:=</span> <span class="n">lift_d</span> <span class="mi">1</span> <span class="mi">0</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">c</span><span class="err">⟫</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">{{</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="o">}}</span>   <span class="o">:=</span>    <span class="o">{{</span><span class="n">A</span> <span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">}}</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

  <span class="kn">notation</span>  <span class="bp">`</span><span class="err">⁅</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span> <span class="bp">//</span> <span class="bp">`</span>  <span class="n">b</span> <span class="bp">`</span><span class="err">⁆</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="mi">0</span> <span class="n">b</span> <span class="n">φ</span>

  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span> <span class="err">↑</span><span class="mi">0</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>
  <span class="bp">#</span><span class="n">reduce</span> <span class="err">⁅</span> <span class="err">↑</span><span class="mi">1</span> <span class="bp">//</span> <span class="err">⊤</span> <span class="err">⋀</span> <span class="err">⊥⁆</span>

  <span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">finset</span> <span class="bp">ℕ</span>
  <span class="bp">|</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">∅</span>
  <span class="bp">|</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">∅</span>
  <span class="bp">|</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">∅</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">FV</span> <span class="n">p</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">q</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">FV</span> <span class="n">p</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">q</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">FV</span> <span class="n">p</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">q</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">FV</span> <span class="n">a</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="n">FV</span> <span class="n">a</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">singleton</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="o">{{</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="o">}}</span>   <span class="o">:=</span> <span class="o">((</span><span class="n">FV</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">erase</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred</span>
  <span class="bp">|</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">((</span><span class="n">FV</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">erase</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred</span>
  <span class="bp">|</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">((</span><span class="n">FV</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">erase</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred</span>


<span class="kn">end</span> <span class="n">substitution</span>



<span class="n">def</span> <span class="n">eq</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span><span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">$</span> <span class="o">((</span><span class="bp">^</span> <span class="n">a₁</span><span class="o">)</span> <span class="err">∈</span> <span class="err">↑</span><span class="mi">0</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="bp">^</span> <span class="n">a₂</span><span class="o">)</span> <span class="err">∈</span> <span class="err">↑</span><span class="mi">0</span><span class="o">)</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">≃</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">eq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">eq</span> <span class="mi">𝟙</span> <span class="err">↑</span><span class="mi">0</span> <span class="err">↑</span><span class="mi">0</span>

<span class="n">def</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{{</span><span class="n">A</span> <span class="bp">|</span> <span class="o">(</span><span class="bp">^</span> <span class="n">a</span><span class="o">)</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="err">↑</span><span class="mi">0</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">ex_unique</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">({{</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="o">}}</span> <span class="err">≃</span><span class="o">[</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">A</span> <span class="err">↑</span><span class="mi">0</span><span class="o">))</span>
<span class="kn">prefix</span> <span class="bp">`∃!</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">ex_unique</span>

<span class="n">def</span> <span class="n">subseteq</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">^</span> <span class="n">α</span><span class="o">))</span> <span class="err">⟹</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">^</span> <span class="n">β</span><span class="o">))</span>
<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="err">⊆</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="n">A</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">subseteq</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">def</span> <span class="n">term_prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
  <span class="o">{{</span> <span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span> <span class="bp">|</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">B</span> <span class="o">((</span><span class="err">↑</span><span class="mi">1</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="n">β</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="err">↑</span><span class="mi">2</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">]</span> <span class="err">⟪↑</span><span class="mi">1</span><span class="o">,</span><span class="err">↑</span><span class="mi">0</span><span class="err">⟫</span><span class="o">)))}}</span>
<span class="c1">-- notation α ` 𝕏[`:max A,B `] `:0 β := term_prod A B α β</span>

<span class="kn">section</span>
  <span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span>

  <span class="bp">#</span><span class="kn">check</span> <span class="n">p</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋁</span> <span class="n">r</span><span class="o">)</span>
  <span class="bp">#</span><span class="kn">check</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="err">𝒫</span> <span class="mi">𝟙</span><span class="o">)</span> <span class="o">((</span><span class="n">var</span> <span class="mi">2</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">var</span> <span class="mi">0</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">var</span> <span class="mi">0</span><span class="o">))))</span>
<span class="kn">end</span>


<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">subst</span><span class="bp">.</span><span class="n">subseteq</span> <span class="o">{</span><span class="n">x</span> <span class="n">n</span> <span class="n">α</span> <span class="n">β</span> <span class="n">A</span><span class="o">}:</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">α</span> <span class="err">⊆</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊆</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">sorry</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="kn">section</span> <span class="n">WellFormedness</span>

<span class="kn">open</span> <span class="n">term</span>
<span class="kn">open</span> <span class="n">list</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="n">l₁</span> <span class="n">l₂</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">variables</span> <span class="o">{</span><span class="err">Γ</span> <span class="err">Δ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">φ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">α</span> <span class="o">:</span> <span class="n">term</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="err">Ω&#39;</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">user_attribute</span><span class="o">]</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_rules</span> <span class="o">:</span> <span class="n">user_attribute</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">name</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">,</span>
  <span class="n">descr</span> <span class="o">:=</span> <span class="s2">&quot;lemmas usable to prove Well Formedness&quot;</span> <span class="o">}</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">WF_prover</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span><span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply_rules</span> <span class="n">WF_rules</span><span class="o">,</span> <span class="n">any_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}]</span>

<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="mi">𝟙</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="o">{{</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="o">}}</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span> <span class="n">WF</span><span class="bp">.</span><span class="n">top</span> <span class="n">WF</span><span class="bp">.</span><span class="n">bot</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">elem</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex</span>


<span class="c1">-- Ω&#39; is just a fake/variable version of Ω so we don&#39;t need to bother proving</span>
<span class="c1">-- that it must be Ω itself.&#39;</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">WF_cases</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or_left</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">or_right</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp_left</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp_right</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair_left</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">pair_right</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">comp_elim</span>  <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="o">{{</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="o">}}</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">all_elim</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">ex_elim</span>    <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω&#39;</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω&#39;</span> <span class="n">φ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">WF_cases</span>
<span class="bp">@</span><span class="o">[</span><span class="n">TT</span><span class="bp">.</span><span class="n">WF_rules</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">WF</span><span class="bp">.</span><span class="n">iff</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">WF_prover</span><span class="o">}</span>
</code></pre></div>



<a name="201610099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201610099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201610099">(Jun 22 2020 at 14:10)</a>:</h4>
<p>probably because you're in another namespace when you defined <code>WF_prover</code>?</p>



<a name="201610109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201610109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201610109">(Jun 22 2020 at 14:10)</a>:</h4>
<p>it's long and hard to tell</p>



<a name="201610667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201610667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201610667">(Jun 22 2020 at 14:15)</a>:</h4>
<p>that is, if you're inside <code>namespace TT</code> then <code>def foo.bar</code> defined <code>TT.foo.bar</code></p>



<a name="201610993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201610993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201610993">(Jun 22 2020 at 14:18)</a>:</h4>
<p><code>#where</code> will tell you which namespace you're in at a given point in a file (and also what variables you have defined, what you have open...)</p>



<a name="201716534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201716534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201716534">(Jun 23 2020 at 12:08)</a>:</h4>
<p>I'm failing to deconstruct the arguments to <code>comp</code> in this category definition - I think it's because the first 3 arguments are implicit in <code>comp</code> unlike in <code>hom</code>. The constants are there in place of actual things I've defined.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kn">constant</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">constant</span> <span class="n">tset</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="kn">constant</span> <span class="n">graph</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">constant</span> <span class="n">id_graph</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">α</span> <span class="n">α</span>

<span class="kn">constant</span> <span class="n">composition</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">tset</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">β</span> <span class="n">η</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">α</span> <span class="n">η</span>

<span class="kn">instance</span> <span class="n">category</span> <span class="o">:</span> <span class="n">small_category</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">tset</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">α</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">β</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">graph</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">α</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">id_graph</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">α</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">β</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">C</span><span class="o">,</span><span class="n">η</span><span class="bp">⟩</span> <span class="n">F</span> <span class="n">G</span><span class="o">,</span> <span class="n">composition</span> <span class="n">F</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">id_comp&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">comp_id&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">assoc&#39;</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>

<span class="kn">end</span> <span class="n">category_theory</span>
</code></pre></div>


<p>I thought it compile, even if I had underscores for the first three arguments - but I get this error.</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">composition</span> <span class="n">F</span>
<span class="n">term</span>
  <span class="n">F</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">_</span><span class="n">x</span> <span class="err">⟶</span> <span class="bp">_</span><span class="n">x_1</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">graph</span> <span class="err">?</span><span class="n">m_3</span> <span class="err">?</span><span class="n">m_4</span>
</code></pre></div>


<p>Evidently <code>composition</code> doesn't know that the hom-type is exactly the graph type it wants.</p>



<a name="201718236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201718236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201718236">(Jun 23 2020 at 12:28)</a>:</h4>
<p>You should write the instance this way:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">category</span> <span class="o">:</span> <span class="n">small_category</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">tset</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">graph</span> <span class="n">A</span><span class="bp">.</span><span class="mi">2</span> <span class="n">B</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">id_graph</span> <span class="n">A</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">F</span> <span class="n">G</span><span class="o">,</span> <span class="n">composition</span> <span class="n">F</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">id_comp&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">comp_id&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">assoc&#39;</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>
</code></pre></div>



<a name="201718497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201718497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201718497">(Jun 23 2020 at 12:31)</a>:</h4>
<p>In general, avoid <code>λ ⟨A,α⟩</code> except for proofs</p>



<a name="201718642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201718642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201718642">(Jun 23 2020 at 12:33)</a>:</h4>
<p>Cool thanks!</p>
<p>I would also like to know how to do deconstruction of terms in this way for hypotheses in a goal state. Something like this but for tactic mode?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="bp">⟩</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="n">hw</span><span class="bp">.</span><span class="n">left</span><span class="bp">⟩</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201718981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201718981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201718981">(Jun 23 2020 at 12:36)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw₁</span><span class="o">,</span> <span class="n">hw₂</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- or rcases h with ⟨w, hw₁, hw₂⟩,</span>
  <span class="n">exact</span> <span class="bp">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw₂</span><span class="o">,</span> <span class="n">hw₁</span><span class="bp">⟩</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201719358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201719358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201719358">(Jun 23 2020 at 12:40)</a>:</h4>
<p>Ah awesome, does the <code>r</code> in <code>rcases</code> and <code>rintros</code> refer to the deconstruction of the hypothesis being vaguely recursive?</p>



<a name="201719761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201719761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201719761">(Jun 23 2020 at 12:43)</a>:</h4>
<p>Yes, <code>rcases</code> = "recursive cases"</p>



<a name="201719886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201719886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201719886">(Jun 23 2020 at 12:44)</a>:</h4>
<p><code>rintro</code> = “recursive intro”</p>



<a name="201720266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/201720266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#201720266">(Jun 23 2020 at 12:48)</a>:</h4>
<p>Is it possible to print all definitions/lemmas using sorry?</p>



<a name="202076800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202076800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202076800">(Jun 26 2020 at 11:07)</a>:</h4>
<p>Here's something interesting, the first of these is very easy to prove,  but I don't know where to start on the second (I hope I'm not missing something obvious). I feel like perhaps I need to invoke classical reasoning, since I don't actually have anything to work with. I have a suspicion that it's just not true.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">ent_to_meta</span> <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span>  <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="n">ψ</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">entails</span><span class="bp">.</span><span class="n">cut</span> <span class="bp">_</span> <span class="n">φ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">tidy</span><span class="o">})</span>

<span class="kn">lemma</span> <span class="n">meta_to_ent</span> <span class="o">(</span><span class="n">wfφ</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">wfψ</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">ψ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="n">ψ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">φ</span> <span class="n">ψ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202076965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202076965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202076965">(Jun 26 2020 at 11:09)</a>:</h4>
<p>Here's what <code>entails</code> is.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">entails</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">axm</span>        <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span>       <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">vac</span>        <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span>       <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">abs</span>        <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span>       <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊥</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">and_intro</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and_left</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">and_right</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">or_intro</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">or_left</span>    <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">or_right</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">imp_to_and</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">and_to_imp</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">weakening</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">(</span><span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="err">Δ</span><span class="o">)</span> <span class="n">p</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">cut</span>        <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">c</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">c</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">all_elim</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">p</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">all_intro</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">p</span><span class="o">)</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex_elim</span>    <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">p</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">ex_intro</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">p</span><span class="o">)</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">extensionality</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span>       <span class="o">:</span> <span class="n">entails</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span> <span class="bp">∀</span><span class="o">[</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">,</span> <span class="err">𝒫</span> <span class="n">A</span><span class="o">]</span> <span class="err">$</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="err">↑</span><span class="mi">2</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="err">↑</span><span class="mi">1</span><span class="o">))</span> <span class="err">⟹</span> <span class="o">(</span><span class="err">↑</span><span class="mi">1</span> <span class="err">≃</span><span class="o">[</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">]</span> <span class="err">↑</span><span class="mi">0</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">prop_ext</span>                 <span class="o">:</span> <span class="n">entails</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span> <span class="bp">∀</span><span class="o">[</span><span class="err">Ω</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">$</span> <span class="o">(</span><span class="err">↑</span><span class="mi">1</span> <span class="err">⇔</span> <span class="err">↑</span><span class="mi">0</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="err">↑</span><span class="mi">1</span> <span class="err">≃</span><span class="o">[</span><span class="err">Ω</span><span class="o">]</span> <span class="err">↑</span><span class="mi">0</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">star_unique</span>              <span class="o">:</span> <span class="n">entails</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span> <span class="bp">∀</span><span class="o">[</span><span class="mi">𝟙</span><span class="o">]</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">≃</span><span class="o">[</span><span class="mi">𝟙</span><span class="o">]</span> <span class="err">⁎</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair_rep</span>      <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>      <span class="o">:</span> <span class="n">entails</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span> <span class="bp">∀</span><span class="o">[</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">]</span> <span class="err">$</span> <span class="bp">∃</span><span class="o">[</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">]</span> <span class="err">$</span> <span class="err">↑</span><span class="mi">2</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">]</span> <span class="err">⟪↑</span><span class="mi">1</span><span class="o">,</span><span class="err">↑</span><span class="mi">0</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">pair_distinct</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>      <span class="o">:</span> <span class="n">entails</span> <span class="o">[]</span> <span class="err">⊤</span> <span class="err">$</span> <span class="bp">∀</span><span class="o">[</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">,</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">]</span> <span class="err">$</span> <span class="o">(</span><span class="err">⟪↑</span><span class="mi">3</span><span class="o">,</span><span class="err">↑</span><span class="mi">2</span><span class="err">⟫</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span> <span class="err">𝕏</span> <span class="n">B</span><span class="o">]</span> <span class="err">⟪↑</span><span class="mi">1</span><span class="o">,</span><span class="err">↑</span><span class="mi">0</span><span class="err">⟫</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">((</span><span class="err">↑</span><span class="mi">3</span> <span class="err">≃</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="err">↑</span><span class="mi">2</span> <span class="err">≃</span><span class="o">[</span><span class="n">B</span><span class="o">]</span> <span class="err">↑</span><span class="mi">0</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">sub</span>      <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">⁅</span><span class="n">p</span> <span class="bp">//</span> <span class="n">b</span><span class="err">⁆</span><span class="o">)</span> <span class="o">(</span><span class="err">⁅</span><span class="n">q</span> <span class="bp">//</span> <span class="n">b</span><span class="err">⁆</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span>     <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span><span class="o">)</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="o">(</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">^</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span><span class="o">))</span> <span class="err">⇔</span> <span class="n">φ</span><span class="o">)</span>
</code></pre></div>



<a name="202079129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079129">(Jun 26 2020 at 11:35)</a>:</h4>
<p>It's not true</p>



<a name="202079269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079269">(Jun 26 2020 at 11:37)</a>:</h4>
<p>for example with <code>phi = p</code>, a variable of type Omega, and <code>psi = ⊥</code>, then the antecedent is true because <code>entails [p:Ω] ⊤ p</code> is false, but <code>entails [p:Ω] ⊤ (p -&gt; ⊥)</code> is also false</p>



<a name="202079369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079369">(Jun 26 2020 at 11:39)</a>:</h4>
<p>If you generalize the meta assumption to contexts extending Gamma then it is true</p>



<a name="202079482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079482">(Jun 26 2020 at 11:40)</a>:</h4>
<p>because then you can just instantiate it with context <code>(φ::Γ)</code> to derive <code>entails (φ::Γ) ⊤ ψ</code>, after which you can use imp intro to derive <code>entails Γ ⊤ (φ -&gt; ψ)</code></p>



<a name="202079489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079489">(Jun 26 2020 at 11:41)</a>:</h4>
<p>wait, where is your imp intro?</p>



<a name="202079541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079541">(Jun 26 2020 at 11:42)</a>:</h4>
<p>I suppose you could generalize the <code>⊤</code> in the antecedent instead, but it's kind of trivial at that point using axm</p>



<a name="202079629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079629">(Jun 26 2020 at 11:43)</a>:</h4>
<p>Oh I see, hypotheses don't go in the context like in DTT because this is a HOL like system</p>



<a name="202079647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079647">(Jun 26 2020 at 11:43)</a>:</h4>
<p>I think whatever you mean by imp intro is derivable. One of these?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">from_imp</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span> <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">entails</span><span class="bp">.</span><span class="n">cut</span> <span class="bp">_</span> <span class="o">(</span><span class="err">⊤</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">apply_rules</span> <span class="o">[</span><span class="n">entails</span><span class="bp">.</span><span class="n">and_intro</span><span class="o">,</span> <span class="n">entails</span><span class="bp">.</span><span class="n">vac</span><span class="o">,</span> <span class="n">entails</span><span class="bp">.</span><span class="n">axm</span><span class="o">]</span><span class="bp">;</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">WF</span><span class="bp">.</span><span class="n">imp_left</span> <span class="bp">_</span> <span class="n">q</span> <span class="n">r</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">WF</span><span class="bp">.</span><span class="n">proof_right</span> <span class="n">h₁</span>
    <span class="o">},</span>
  <span class="n">exact</span> <span class="n">entails</span><span class="bp">.</span><span class="n">imp_to_and</span> <span class="n">h₁</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">to_imp</span> <span class="o">{</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">}</span> <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">q</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">apply_rules</span> <span class="o">[</span><span class="n">entails</span><span class="bp">.</span><span class="n">and_to_imp</span><span class="o">,</span> <span class="n">entails</span><span class="bp">.</span><span class="n">cut</span> <span class="bp">_</span> <span class="n">q</span> <span class="bp">_</span><span class="o">,</span> <span class="n">entails</span><span class="bp">.</span><span class="n">and_right</span> <span class="bp">_</span> <span class="err">⊤</span> <span class="bp">_</span><span class="o">,</span> <span class="n">entails</span><span class="bp">.</span><span class="n">axm</span><span class="o">],</span>
  <span class="n">WF_prover</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">WF</span><span class="bp">.</span><span class="n">proof_left</span> <span class="n">h₁</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202079713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079713">(Jun 26 2020 at 11:44)</a>:</h4>
<p>So yeah you have to have the assumption <code>\all p, entails Γ p φ → entails Γ p ψ</code> at which point the theorem is trivial</p>



<a name="202079735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079735">(Jun 26 2020 at 11:44)</a>:</h4>
<p>Yeah this is from Lambek and Scott, Introduction to Higher Order Logic, (but really via these notes <a href="http://therisingsea.org/notes/ch2018-lecture9.pdf">http://therisingsea.org/notes/ch2018-lecture9.pdf</a>)</p>



<a name="202079915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202079915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202079915">(Jun 26 2020 at 11:47)</a>:</h4>
<p>Ah that makes sense, it's strengthening the hypotheses to ensure that the function <code>entails Γ p φ → entails Γ p ψ</code> doesn't just just rely on <code>entails Γ p φ</code> being false.</p>



<a name="202528039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202528039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202528039">(Jul 01 2020 at 03:41)</a>:</h4>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span> I switched to your induction branch by changing my mathlib <code>rev</code> and then I did <code>leanproject get-mathlib-cache</code>. Then when I tried to <code>import tactic.induction</code>, I get this message. <code>invalid import: control.basic
invalid object declaration, environment already has an object named 'simp_attr.functor_norm'</code></p>
<p>I then tried running <code>leanpkg configure</code>, after which I get this output. Any ideas? <a href="/user_uploads/3121/hidIuTJF5-WxxRbB0ZZ5nsVZ/output.txt">output.txt</a></p>



<a name="202535841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202535841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202535841">(Jul 01 2020 at 06:46)</a>:</h4>
<p>I just delete _target and start again when I get into situations like this, but I'm afraid I am a luddite (a busy one).</p>



<a name="202535868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202535868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202535868">(Jul 01 2020 at 06:47)</a>:</h4>
<p>Wait -- are you working on mathlib or in a repo with mathlib as a dependency?</p>



<a name="202555932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202555932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202555932">(Jul 01 2020 at 11:06)</a>:</h4>
<p>the latter</p>



<a name="202556432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202556432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202556432">(Jul 01 2020 at 11:14)</a>:</h4>
<p>Hmm - now when I redo <code>leanpkg configure</code>, I have a massive stream of warnings saying basically every file coming from mathlib uses sorry. My mathlib rev is this commit is <a href="https://github.com/leanprover-community/mathlib/commit/d05800077970a187c948f6e3e316aea2beac4e92">https://github.com/leanprover-community/mathlib/commit/d05800077970a187c948f6e3e316aea2beac4e92</a></p>



<a name="202556454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202556454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202556454">(Jul 01 2020 at 11:14)</a>:</h4>
<p>Do you use <code>elan</code>?</p>



<a name="202556469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202556469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202556469">(Jul 01 2020 at 11:15)</a>:</h4>
<p>I suggest using <code>leanproject</code> instead of <code>leanpkg</code></p>



<a name="202556741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202556741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202556741">(Jul 01 2020 at 11:18)</a>:</h4>
<p>Ah okay - I thought they were different tools because <code>leanproject configure</code> isn't a command</p>



<a name="202556761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202556761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202556761">(Jul 01 2020 at 11:18)</a>:</h4>
<p>What do I do instead of <code>leanpkg configure</code> with <code>leanproject</code>?</p>



<a name="202557109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202557109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202557109">(Jul 01 2020 at 11:24)</a>:</h4>
<p>Just straight to <code>leanproject build</code>?</p>



<a name="202557285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202557285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202557285">(Jul 01 2020 at 11:27)</a>:</h4>
<p>If I do so - I get the same errors. Namely lines like this</p>
<p><code>/Users/billy/gits/TL/_target/deps/mathlib/src/algebra/field.lean:173:6: error: invalid definition, a declaration named 'div_eq_one_iff_eq' has already been declared</code></p>
<p>and this</p>
<p><code>/Users/billy/gits/TL/_target/deps/mathlib/src/data/nat/pairing.lean:8:0: warning: imported file '/Users/billy/gits/TL/_target/deps/mathlib/src/tactic/doc_commands.lean' uses sorry</code></p>
<p>and this</p>
<p><code>/Users/billy/gits/TL/_target/deps/mathlib/src/data/list/intervals.lean:146:45: error: type mismatch at application
  lt_of_lt_of_le (mem.mp hk).right
term
  (mem.mp hk).right
has type
  k &lt; m
but is expected to have type
  ?m_3 &lt; ?m_4</code></p>
<p>Is this a problem with the commit?</p>



<a name="202557562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202557562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202557562">(Jul 01 2020 at 11:30)</a>:</h4>
<p>Okay I figured out how to retrieve the pre-compiled oleans with <code>get-mathlib-cache</code>, and now I'm back at my original problem. When I <code>import tactic.induction</code>, I get</p>
<p><code>invalid import: control.basic
invalid object declaration, environment already has an object named 'simp_attr.functor_norm'Lean</code></p>



<a name="202560064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202560064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202560064">(Jul 01 2020 at 12:03)</a>:</h4>
<p>Also <code>src/tactic/induction.lean</code> seems to be mostly commented out? Is this an unstable commit <span class="user-mention" data-user-id="256311">@Jannis Limperg</span> ? Is there another commit I should be using?</p>



<a name="202569883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202569883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202569883">(Jul 01 2020 at 13:40)</a>:</h4>
<p>Make sure your project's <code>leanpkg.toml</code> file specifies the same version of Lean as the mathlib version you're using (<code>"leanprover-community/lean:3.16.3"</code>)</p>



<a name="202571917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202571917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202571917">(Jul 01 2020 at 14:00)</a>:</h4>
<p>What Reid said. This recipe should work:</p>
<ul>
<li>Delete <code>_target</code>.</li>
<li>Put in your <code>leanpkg.toml</code>:<ul>
<li>Mathlib commit: f5d662fd391b7aa737506a490da11fd7467c0934</li>
<li>Lean version: leanprover-community/lean:3.16.5</li>
</ul>
</li>
<li><code>leanpkg configure</code></li>
<li><code>leanproject get-mathlib-cache</code></li>
</ul>
<p>The Lean update may require minor changes to your code.</p>



<a name="202572171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202572171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202572171">(Jul 01 2020 at 14:02)</a>:</h4>
<p>I didn't look through the history carefully enough to be confident that this is the issue, it's just something easy to mess up and easy to check.</p>



<a name="202572233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202572233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202572233">(Jul 01 2020 at 14:03)</a>:</h4>
<p>Aren't olean files versioned to a specific Lean release though? Or do we not always bump that?</p>



<a name="202638809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202638809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202638809">(Jul 02 2020 at 00:19)</a>:</h4>
<p>Hmm I'm guessing I just had the wrong version of lean or something? Here's my current <code>leanpkg.toml</code> before making any changes</p>
<div class="codehilite"><pre><span></span><code><span class="o">[</span><span class="n">package</span><span class="o">]</span>
<span class="n">name</span> <span class="bp">=</span> <span class="s2">&quot;TL&quot;</span>
<span class="n">version</span> <span class="bp">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">lean_version</span> <span class="bp">=</span> <span class="s2">&quot;leanprover-community/lean:3.9.0&quot;</span>
<span class="n">path</span> <span class="bp">=</span> <span class="s2">&quot;src&quot;</span>

<span class="o">[</span><span class="n">dependencies</span><span class="o">]</span>
<span class="n">mathlib</span> <span class="bp">=</span> <span class="o">{</span><span class="n">git</span> <span class="bp">=</span> <span class="s2">&quot;https://github.com/leanprover-community/mathlib&quot;</span><span class="o">,</span> <span class="n">rev</span> <span class="bp">=</span> <span class="s2">&quot;d05800077970a187c948f6e3e316aea2beac4e92&quot;</span><span class="o">}</span>
</code></pre></div>



<a name="202638905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/202638905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#202638905">(Jul 02 2020 at 00:20)</a>:</h4>
<p>Oh I just saw Reid's first reply</p>



<a name="203063893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203063893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203063893">(Jul 07 2020 at 03:26)</a>:</h4>
<p>I have a lot of questions to ask, and a lot of them might be easiest to answer with a mwe. However many questions genuinely need my whole project (or at least 80% of it) to either compile or give context. What's the best way to go about this? It feels wrong to paste all my code in every post (especially since I now have multiple files). I have a git repo - though I'm not sure about committing half-cooked code every time I need to ask a question - (also the need for others to clone/copy/pull changes). Is there a better option than that or would using git be feasible? How do you guys work around this?</p>



<a name="203064263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203064263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203064263">(Jul 07 2020 at 03:39)</a>:</h4>
<p>You could commit half cooked code to a different branch, then give people a oneliner to run with leanproject to get that branch on their computer like <code>leanproject get githubname/repo:branch</code> (or whatever the syntax is).</p>



<a name="203064526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203064526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203064526">(Jul 07 2020 at 03:48)</a>:</h4>
<p>Thanks for the suggestion - I'll look into that.</p>



<a name="203376748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203376748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203376748">(Jul 09 2020 at 11:58)</a>:</h4>
<p>(deleted)</p>



<a name="203377885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203377885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203377885">(Jul 09 2020 at 12:13)</a>:</h4>
<p>The work-in-progress branch of my project can be grabbed here <code>leanproject get https://github.com/billy-price/TL.git:WIP</code>. Definitions and syntax are in <code>src/definitions.lean</code> - but most of it should be readable or just ask me. Stuff mentioned in this question are in <code>src/entails.lean</code></p>
<p>The second half of the deduction rules and axioms of entailment in my type theory are quite unusable in their current state, so I'm trying to develop some more usable rules, for example I'm guessing I'd need something like this</p>
<p><code>lemma all_sub {A φ a} : WF (A :: Γ) Ω φ → entails (A::Γ) (^ (∀' A φ)) (φ⁅a⁆)</code></p>
<p>(the <code>^</code> means <code>lift 1 0</code>).</p>
<p>My guess is that would be much more usable than the current axioms relating to universal quantification, which are</p>
<div class="codehilite"><pre><span></span><code><span class="bp">|</span> <span class="n">all_elim</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">φ</span> <span class="n">A</span><span class="o">}</span>   <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">p</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">all_intro</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">φ</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">p</span><span class="o">)</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">sub</span>      <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">B</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">p</span><span class="err">⁅</span><span class="n">b</span><span class="err">⁆</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span><span class="err">⁅</span><span class="n">b</span><span class="err">⁆</span><span class="o">)</span>
</code></pre></div>


<p>This is the proof so far,</p>
<div class="codehilite"><pre><span></span><code><span class="k">begin</span>
  <span class="n">intro</span> <span class="n">wf</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">cut</span> <span class="n">φ</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply_rules</span> <span class="o">[</span><span class="n">all_elim</span><span class="o">,</span> <span class="n">axm</span><span class="o">],</span> <span class="n">WF_prover</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">sorry</span>
     <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>I've managed to reduce it to this goal state, which seems closer to applying <code>sub</code> somewhere, but doesn't quite match</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="err">Γ</span><span class="o">:</span> <span class="kn">context</span>
<span class="n">A</span><span class="o">:</span> <span class="n">type</span>
<span class="n">φa</span><span class="o">:</span> <span class="n">term</span>
<span class="n">wf</span><span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span>
<span class="err">⊢</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">φ</span> <span class="n">φ</span><span class="err">⁅</span><span class="n">a</span><span class="bp">//</span><span class="mi">0</span><span class="err">⁆</span>
</code></pre></div>


<p>It was possible to prove a slight variation of this here</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">meta_all_sub</span> <span class="o">{</span><span class="n">A</span> <span class="n">φ</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="err">⊤</span> <span class="o">(</span><span class="n">φ</span><span class="err">⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">wfa</span> <span class="n">ent_all</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="bp">=</span>  <span class="err">⊤⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">,</span> <span class="k">by</span> <span class="n">refl</span><span class="o">,</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">sub</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">wfa</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">^</span> <span class="err">⊤</span><span class="o">,</span> <span class="k">by</span> <span class="n">refl</span><span class="o">,</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">all_elim</span> <span class="n">ent_all</span>
<span class="kn">end</span>
</code></pre></div>


<p>but I don't believe this is equivalent, I'd have to prove it for all hypotheses on both entailments, not just <code>⊤</code>, which is just as difficult</p>



<a name="203378275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378275">(Jul 09 2020 at 12:18)</a>:</h4>
<p>what's the theorem?</p>



<a name="203378300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378300">(Jul 09 2020 at 12:18)</a>:</h4>
<p><code>lemma all_sub {A φ a} : WF (A :: Γ) Ω φ → entails (A::Γ) (^ (∀' A φ)) (φ⁅a⁆)</code></p>



<a name="203378440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378440">(Jul 09 2020 at 12:20)</a>:</h4>
<p>You need <code>a</code> to be well typed, right? Why not</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">all_sub</span> <span class="o">{</span><span class="n">A</span> <span class="n">φ</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">a</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span><span class="err">⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">)</span>
</code></pre></div>



<a name="203378469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378469">(Jul 09 2020 at 12:20)</a>:</h4>
<p>Yep that's an oversight</p>



<a name="203378504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378504">(Jul 09 2020 at 12:21)</a>:</h4>
<p>It should be provable without induction</p>



<a name="203378767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378767">(Jul 09 2020 at 12:24)</a>:</h4>
<p>Do you agree that <code>all_elim, all_intro, sub</code> are the main relevant deduction rules or am I missing one?</p>



<a name="203378813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378813">(Jul 09 2020 at 12:25)</a>:</h4>
<p>(those are all <code>entails.*</code>)</p>



<a name="203378826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203378826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203378826">(Jul 09 2020 at 12:25)</a>:</h4>
<p>From all_elim and identity, you have <code>(^ (all A ph)) -&gt; ph</code>, and from <code>sub</code> you get <code>(^ (all A ph))[a] -&gt; ph[a]</code>, which simplifies to <code>(all A ph) -&gt; ph[a]</code></p>



<a name="203380703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203380703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203380703">(Jul 09 2020 at 12:47)</a>:</h4>
<p>Thank you, that seems like a general pattern to think about for other proofs. Here's my implementation - I kinda think the <code>have</code> line sucks. I'm finding myself going through a lot of effort to dress up my entailments to something that I can apply an entailment rule too. How do I make this easier?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">all_sub</span> <span class="o">{</span><span class="n">A</span> <span class="n">φ</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">entails</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">))</span> <span class="o">(</span><span class="n">φ</span><span class="err">⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">wfa</span> <span class="n">wfφ</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">^</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">^</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">))</span><span class="err">⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">,</span> <span class="k">by</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">sub</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">wfa</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">all_elim</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">axm</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">WF_prover</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203452000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203452000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203452000">(Jul 09 2020 at 22:51)</a>:</h4>
<p>the have line should be <code>(^ (∀' A φ))⁅a⁆ = (∀' A φ)</code></p>



<a name="203452082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203452082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203452082">(Jul 09 2020 at 22:52)</a>:</h4>
<p>which is a special case of the theorem <code>(^ e)⁅a⁆ = e</code></p>



<a name="203463581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203463581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203463581">(Jul 10 2020 at 02:28)</a>:</h4>
<p>I got the contexts wrong and that led me to the wrong equality, though isn't the theorem <code>(^ e)⁅a⁆ = ^ e</code>?</p>



<a name="203463763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203463763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203463763">(Jul 10 2020 at 02:32)</a>:</h4>
<p>No, <code>p⁅a⁆</code> lives in context <code>Γ</code> if <code>p</code> is in context <code>A :: Γ</code> and <code>a : A</code></p>



<a name="203463792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203463792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203463792">(Jul 10 2020 at 02:33)</a>:</h4>
<p>At least the way it's usually defined, substitution on de bruijn terms substitutes variable 0 and reduces all other variables by 1</p>



<a name="203464767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203464767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203464767">(Jul 10 2020 at 02:55)</a>:</h4>
<p>Oh lol, I didn't define it like that and that might need some refactoring</p>



<a name="203464895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203464895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203464895">(Jul 10 2020 at 02:58)</a>:</h4>
<p>In non-de bruijn world I would expect something like phi[x:=x] = phi, and that's clearly ruled out in de-bruijn world according to what you just said</p>



<a name="203467471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203467471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203467471">(Jul 10 2020 at 04:02)</a>:</h4>
<p>no, that's not a thing with de bruijn because the x:=x part is not well scoped</p>



<a name="203467482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203467482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203467482">(Jul 10 2020 at 04:03)</a>:</h4>
<p>the nearest equivalent is something like <code>(lift phi 1 1)[0] = phi</code></p>



<a name="203471418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203471418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203471418">(Jul 10 2020 at 05:46)</a>:</h4>
<p>Tada here's my proof (of an appropriate generalization), was scratching my head for a while wondering why I couldn't use <code>add_sub (a b c) : a + (b-c) = a+b-c</code>, it's not true for naturals! </p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">sub_lift</span> <span class="o">{</span><span class="n">d</span> <span class="n">k</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">term</span><span class="o">}</span> <span class="o">{</span><span class="n">hd</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">lift</span> <span class="n">d</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span><span class="err">⁅</span><span class="n">b</span> <span class="bp">//</span> <span class="n">k</span><span class="err">⁆</span> <span class="bp">=</span> <span class="n">lift</span> <span class="o">(</span><span class="n">d</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">k</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction&#39;</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">any_goals</span> <span class="o">{</span><span class="n">tidy</span><span class="o">},</span>
  <span class="n">case</span> <span class="n">var</span> <span class="o">:</span>
    <span class="o">{</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">if_neg</span><span class="o">,</span> <span class="n">if_pos</span><span class="o">]</span><span class="bp">;</span> <span class="o">{</span><span class="n">linarith</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span><span class="n">cases</span> <span class="n">hd</span><span class="bp">;</span><span class="n">refl</span><span class="o">}}</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">rw</span> <span class="n">if_neg</span><span class="o">,</span> <span class="n">rw</span> <span class="n">if_neg</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span> <span class="n">linarith</span><span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203471789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203471789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203471789">(Jul 10 2020 at 05:55)</a>:</h4>
<p>is there a direct term or tactic equivalent to <code>cases h with x, exact x</code>?  Assuming h has one possible case?</p>



<a name="203471794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203471794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203471794">(Jul 10 2020 at 05:55)</a>:</h4>
<p>(Unrelated to the proof i just posted)</p>



<a name="203472258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203472258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203472258">(Jul 10 2020 at 06:05)</a>:</h4>
<p>Only if <code>h</code> is a structure</p>



<a name="203472318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203472318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203472318">(Jul 10 2020 at 06:06)</a>:</h4>
<p><code>match h with | (foo x) := x end</code></p>



<a name="203472333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203472333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203472333">(Jul 10 2020 at 06:07)</a>:</h4>
<p><code>let \&lt;x\&gt; := h in x</code></p>



<a name="203472385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203472385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203472385">(Jul 10 2020 at 06:08)</a>:</h4>
<p>Usually, if that proof works, it should be a structure field, in which case you can write <code>foo.out h</code> or the like</p>



<a name="203472416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203472416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203472416">(Jul 10 2020 at 06:09)</a>:</h4>
<p>However it's also possible that your <code>h</code> has a type with many constructors, and the others are being excluded for being impossible. In that case the <code>match</code> proof of Kenny's will work but the <code>let</code> will not and the field also will not</p>



<a name="203473877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203473877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203473877">(Jul 10 2020 at 06:39)</a>:</h4>
<p>Thanks, it's the inductive WF type so I don't think this applies.</p>



<a name="203474685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203474685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203474685">(Jul 10 2020 at 06:55)</a>:</h4>
<p>In light of the new substitution rule, does my axiom of comprehension still make sense? <br>
<code>| comp     {Γ} (A) (φ)     : WF (A::Γ) Ω φ → entails Γ ⊤ (∀' A $ (↑0 ∈ (^ ⟦A | φ⟧)) ⇔ φ)</code></p>
<p>I'm lifting the set in order to prevent Russell's paradox and the like, but then when I try and prove this lemma I run into trouble</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">elem_comp</span> <span class="o">{</span><span class="n">H</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">φ</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">H</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">^</span> <span class="o">(</span><span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span><span class="o">)))</span> <span class="bp">→</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">H</span> <span class="o">(</span><span class="n">φ</span><span class="err">⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">ent_elem</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">cut</span> <span class="bp">_</span> <span class="n">ent_elem</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">from_imp</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="err">∈</span> <span class="bp">^</span> <span class="o">(</span><span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span><span class="o">))</span> <span class="err">⟹</span> <span class="n">φ</span><span class="err">⁅</span><span class="n">a</span><span class="bp">//</span><span class="mi">0</span><span class="err">⁆</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="err">↑</span><span class="mi">0</span> <span class="err">∈</span> <span class="bp">^</span> <span class="o">(</span><span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span><span class="o">))</span> <span class="err">⟹</span> <span class="n">φ</span><span class="o">)</span><span class="err">⁅</span><span class="n">a</span><span class="err">⁆</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>the state before the first sorry is, in which the right conjunct isn't true. </p>
<div class="codehilite"><pre><span></span><code><span class="err">Γ</span><span class="o">:</span> <span class="kn">context</span>
<span class="n">H</span><span class="o">:</span> <span class="n">term</span>
<span class="n">A</span><span class="o">:</span> <span class="n">type</span>
<span class="n">φa</span><span class="o">:</span> <span class="n">term</span>
<span class="n">ent_elem</span><span class="o">:</span> <span class="n">entails</span> <span class="err">Γ</span> <span class="n">H</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">lift</span> <span class="mi">1</span> <span class="mi">0</span> <span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">a</span> <span class="bp">=</span> <span class="err">↑</span><span class="mi">0</span><span class="err">⁅</span><span class="n">a</span><span class="bp">//</span><span class="mi">0</span><span class="err">⁆</span> <span class="bp">∧</span> <span class="n">lift</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">φ</span>
</code></pre></div>


<p>Do I just need to change <code>comp</code> to this? (lifting the last phi)<br>
<code>| comp     {Γ} (A) (φ)     : WF (A::Γ) Ω φ → entails Γ ⊤ (∀' A $ (↑0 ∈ (^ ⟦A | φ⟧)) ⇔ (lift 1 1 φ))</code></p>
<p>or is there a better alternative?</p>



<a name="203544182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203544182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203544182">(Jul 10 2020 at 18:49)</a>:</h4>
<p>What does <code>⟦A | φ⟧</code> mean?</p>



<a name="203544342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203544342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203544342">(Jul 10 2020 at 18:51)</a>:</h4>
<p>oh I see it's your comprehension operator, i.e <code>{x : A | φ}</code></p>



<a name="203544665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203544665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203544665">(Jul 10 2020 at 18:53)</a>:</h4>
<p>your <code>elem_comp</code> is missing <code>WF</code> assumptions again. I suggest you put them in because it makes it clearer where to put the lifts</p>



<a name="203544832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203544832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203544832">(Jul 10 2020 at 18:55)</a>:</h4>
<p>In this case <code>a</code>, <code>A</code> and live in context <code>Γ</code> and  <code>φ</code> is in context <code>A::Γ</code> so <code>a</code> and <code>⟦A | φ⟧</code> live in the same context and no lifting is necessary</p>



<a name="203580072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203580072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203580072">(Jul 11 2020 at 04:29)</a>:</h4>
<p>I did end up figuring that out! I was thinking I'd need to lift in order to match with the comprehension axiom, but that is taken care of by reducing all the higher indices during substitution!</p>
<p>I can actually pull the well-formedness of <code>a</code> and <code>phi</code> out of the hypothesis <code>entails Γ H (a ∈ (^ ⟦A | φ⟧))</code>, however I did put them in  because I changed it to an if and only if lemma and you can't pull well-formedness out of the other entailment.</p>



<a name="203580819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203580819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203580819">(Jul 11 2020 at 04:52)</a>:</h4>
<p>I've been doing a bunch of lemmas relating to compositions of lift and substitution operations, and it reminds me of order preserving maps. Specifically I've come across the simplex category of finite ordinals and order preserving maps, and I remember a theorem stating any order preserving map can be decomposed into a composition of these two classes of maps.<br>
<a href="/user_uploads/3121/5MFpW5AaRWQ4FvX4Scr3-d8Q/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/5MFpW5AaRWQ4FvX4Scr3-d8Q/image.png" title="image.png"><img src="/user_uploads/3121/5MFpW5AaRWQ4FvX4Scr3-d8Q/image.png"></a></div><p>These are just like how <code>lift 1 i</code> and <code>subst i (var i)</code> act on de-bruijn indices/vars. <code>lift</code> and <code>subst</code> are defined like this</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">lift</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">k</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">k</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">k</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">lift</span> <span class="n">k</span> <span class="n">a</span><span class="o">,</span> <span class="n">lift</span> <span class="n">k</span> <span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span><span class="bp">≥</span><span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">k</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span><span class="err">⟧</span>  <span class="o">:=</span>   <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="err">$</span> <span class="n">lift</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>

<span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊤</span>          <span class="o">:=</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⊥</span>          <span class="o">:=</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⋁</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>      <span class="o">:=</span> <span class="err">⟪</span><span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">subst</span> <span class="n">n</span> <span class="n">x</span> <span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span><span class="bp">=</span><span class="n">m</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="o">(</span><span class="k">if</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">var</span> <span class="o">(</span><span class="n">m</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="n">var</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="err">⟦</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">φ</span> <span class="err">⟧</span>   <span class="o">:=</span> <span class="err">⟦</span><span class="n">A</span> <span class="bp">|</span> <span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">^</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>
</code></pre></div>


<p>So far I've found it difficult to visualise compositions of <code>lift</code> and <code>subst</code> and come up with the right lemmas to prove, so maybe some practice in the theory of finite order-preserving maps will help. Is this a known connection?</p>



<a name="203581794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203581794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203581794">(Jul 11 2020 at 05:27)</a>:</h4>
<p>I believe that the semantics of type theories leads to the structure of <a href="https://ncatlab.org/nlab/show/categorical+model+of+dependent+types#contextual_categories_or_csystems">contextual categories</a>. If you simplify away the types, so that contexts are basically <code>list unit</code> (which is just <code>nat</code>), as in untyped (but well scoped) lambda calculus, then I think you can use the simplex category to represent the contexts.</p>



<a name="203596104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203596104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203596104">(Jul 11 2020 at 13:11)</a>:</h4>
<p>Very interesting, thanks :)</p>



<a name="203634580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203634580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203634580">(Jul 12 2020 at 08:47)</a>:</h4>
<p>I've proved <code>@[simp] lemma sub_lift {d n k} {a b : term} {hd : d ≥ 1} {hn : n &lt; d} : (lift d k a)⁅b // n+k⁆ = lift (d-1) k a</code> and I'd like to show the following as a simple corollary, since <code>simp</code> won't recognise the first case when <code>n</code> is <code>0</code>,  <code>@[simp] lemma sub_lift' {d k} {a b : term} {hd : d ≥ 1} : (lift d k a)⁅b // k⁆ = lift (d-1) k a</code></p>
<p>However I can't use <code>rw &lt;-zero_add k</code>, since it will rewrite both <code>k</code> to <code>0+k</code>, and I just want the second one to be <code>0+k</code>.</p>



<a name="203635159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203635159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203635159">(Jul 12 2020 at 09:08)</a>:</h4>
<p>Try the conv mode docs?</p>



<a name="203635202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/203635202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#203635202">(Jul 12 2020 at 09:09)</a>:</h4>
<p><a href="https://leanprover-community.github.io/extras/conv.html">https://leanprover-community.github.io/extras/conv.html</a></p>



<a name="205316352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205316352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205316352">(Jul 29 2020 at 04:04)</a>:</h4>
<p>I have a compactness theorem (for a different theory) that looks like this <code>theorem compactness {X : set Form} {A : Form} : (X ⊢I A) → ∃ X' ⊆ X, X'.finite ∧ (X' ⊢I A)</code>, but the proof is entirely constructive. Am I correct in understanding that I won't be able to recover the finite set X' from the exists? I tried to change it to sigma in the hopes of making it recoverable, but it looks like the sigma type doesn't want the second thing to be a proposition?</p>



<a name="205326259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205326259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205326259">(Jul 29 2020 at 07:37)</a>:</h4>
<p>constructive exists is called subtype (<code>{ x // p x }</code>)</p>



<a name="205326329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205326329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205326329">(Jul 29 2020 at 07:38)</a>:</h4>
<p>and I wouldn't call that theorem compactness?</p>



<a name="205449334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449334">(Jul 30 2020 at 07:37)</a>:</h4>
<p>I'm not quite sure how to utilise subtype in my situation I have the following types/props</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">deduction</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">provable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">provable</span>
</code></pre></div>


<p>There's are the three potential subtypes I thought of, but it's not clear how to state the theorem using them, since there's no subset constraint.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">fin_deduction</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">d</span> <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">//</span> <span class="n">X</span><span class="bp">.</span><span class="n">finite</span> <span class="o">}</span>

<span class="kn">inductive</span> <span class="n">fin_provable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">fin_deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">fin_provable</span>

<span class="kn">inductive</span> <span class="n">fin_provable&#39;</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">provable</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">X</span><span class="bp">.</span><span class="n">finite</span> <span class="bp">→</span> <span class="n">fin_provable&#39;</span>
</code></pre></div>


<p>Also the comment about the name compactness, is that just because compactness is about models, not provability? I'm just formalising the natural deduction section of the class I'm taking, and this theorem appeared in the textbook.</p>



<a name="205449459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449459">(Jul 30 2020 at 07:39)</a>:</h4>
<p>the thing is, you can't go from Prop to data</p>



<a name="205449480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449480">(Jul 30 2020 at 07:39)</a>:</h4>
<p>so from a <code>deduction</code> you can produce a finite <code>set Form</code></p>



<a name="205449489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449489">(Jul 30 2020 at 07:39)</a>:</h4>
<p>but once you go to <code>provable</code>, you can't go back to data</p>



<a name="205449689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449689">(Jul 30 2020 at 07:41)</a>:</h4>
<p>so you can produce:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">axioms_used</span> <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">{</span> <span class="n">X&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span> <span class="bp">//</span> <span class="n">X&#39;</span><span class="bp">.</span><span class="n">finite</span> <span class="o">}</span>
</code></pre></div>



<a name="205449769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449769">(Jul 30 2020 at 07:42)</a>:</h4>
<p>of course, the actual signature depends on your implementation and usage etc</p>



<a name="205449782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449782">(Jul 30 2020 at 07:42)</a>:</h4>
<p>for example you might want to generalize <code>A</code>, i.e. put <code>A</code> after the colon</p>



<a name="205449832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449832">(Jul 30 2020 at 07:43)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">extract_axioms</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">},</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">{</span> <span class="n">X&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span> <span class="bp">//</span> <span class="n">X&#39;</span><span class="bp">.</span><span class="n">finite</span> <span class="bp">∧</span> <span class="n">X&#39;</span> <span class="err">⊆</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">deduction</span> <span class="n">X&#39;</span> <span class="n">A</span> <span class="o">}</span>
</code></pre></div>



<a name="205449903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205449903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205449903">(Jul 30 2020 at 07:44)</a>:</h4>
<p>why not use <code>finset</code>?</p>



<a name="205457920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205457920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205457920">(Jul 30 2020 at 09:27)</a>:</h4>
<p>You can probably define a function from <code>deduction X A</code> to <code>{ X' : finset Form // X' \sub X }</code>, based on my guess of how <code>deduction</code> is defined</p>



<a name="205458007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205458007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205458007">(Jul 30 2020 at 09:28)</a>:</h4>
<p>And therefore you can also go from <code>provable X A</code> to <code>\ex X' : finset Form, X' \sub X</code></p>



<a name="205473184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205473184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205473184">(Jul 30 2020 at 12:43)</a>:</h4>
<p>I didn't use <code>finset</code> because subset doesn't seem to work between <code>finset</code> and <code>set</code>. Also could you explain what putting the <code>A</code> after the colon does? Why does that generalise it?</p>



<a name="205475891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205475891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205475891">(Jul 30 2020 at 13:09)</a>:</h4>
<p>You can cast the finset to a set</p>



<a name="205476075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205476075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205476075">(Jul 30 2020 at 13:11)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span> I think Kenny means that if you put the <code>A</code> after the colon then in the recursive definition you can change <code>A</code></p>



<a name="205477769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205477769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205477769">(Jul 30 2020 at 13:25)</a>:</h4>
<p>I see, not sure if I need that but maybe</p>



<a name="205477826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205477826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205477826">(Jul 30 2020 at 13:25)</a>:</h4>
<p>What does this error mean? The line that triggered it is <code>use XA' ∪ XB'</code></p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">instantiate</span> <span class="n">goal</span> <span class="k">with</span> <span class="o">(</span><span class="n">frozen_name</span> <span class="n">has_union</span><span class="bp">.</span><span class="n">union</span><span class="o">)</span> <span class="n">XA&#39;</span> <span class="n">XB&#39;</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">dXA</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">A</span><span class="o">,</span>
<span class="n">dXB</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">B</span><span class="o">,</span>
<span class="n">XA&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">AsubX</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XA&#39;</span> <span class="err">⊆</span> <span class="n">X</span><span class="o">,</span>
<span class="n">XA&#39;A</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XA&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">A</span><span class="o">,</span>
<span class="n">XB&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">BsubX</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XB&#39;</span> <span class="err">⊆</span> <span class="n">X</span><span class="o">,</span>
<span class="n">XB&#39;B</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XB&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">B</span>
<span class="err">⊢</span> <span class="o">{</span><span class="n">X&#39;</span> <span class="bp">//</span> <span class="err">↑</span><span class="n">X&#39;</span> <span class="err">⊆</span> <span class="n">X</span> <span class="bp">∧</span> <span class="err">↑</span><span class="n">X&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">}</span>
</code></pre></div>



<a name="205478468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205478468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205478468">(Jul 30 2020 at 13:31)</a>:</h4>
<p>try <code>existsi</code></p>



<a name="205478670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205478670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205478670">(Jul 30 2020 at 13:33)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">dXA</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">A</span><span class="o">,</span>
<span class="n">dXB</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">B</span><span class="o">,</span>
<span class="n">XA&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">AsubX</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XA&#39;</span> <span class="err">⊆</span> <span class="n">X</span><span class="o">,</span>
<span class="n">XA&#39;A</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XA&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">A</span><span class="o">,</span>
<span class="n">XB&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">BsubX</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XB&#39;</span> <span class="err">⊆</span> <span class="n">X</span><span class="o">,</span>
<span class="n">XB&#39;B</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XB&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">B</span>
<span class="err">⊢</span> <span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">Form</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">dXA</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">A</span><span class="o">,</span>
<span class="n">dXB</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">B</span><span class="o">,</span>
<span class="n">XA&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">AsubX</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XA&#39;</span> <span class="err">⊆</span> <span class="n">X</span><span class="o">,</span>
<span class="n">XA&#39;A</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XA&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">A</span><span class="o">,</span>
<span class="n">XB&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">BsubX</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XB&#39;</span> <span class="err">⊆</span> <span class="n">X</span><span class="o">,</span>
<span class="n">XB&#39;B</span> <span class="o">:</span> <span class="err">↑</span><span class="n">XB&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">B</span>
<span class="err">⊢</span> <span class="o">{</span><span class="n">X&#39;</span> <span class="bp">//</span> <span class="err">↑</span><span class="n">X&#39;</span> <span class="err">⊆</span> <span class="n">X</span> <span class="bp">∧</span> <span class="err">↑</span><span class="n">X&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">}</span>
</code></pre></div>



<a name="205479944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205479944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205479944">(Jul 30 2020 at 13:45)</a>:</h4>
<p>Same thing also happens with <code>constructor, swap, exact XA' ∪ XB',</code></p>



<a name="205480740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205480740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205480740">(Jul 30 2020 at 13:52)</a>:</h4>
<p>Here's a mwe</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">induction</span>

<span class="kn">namespace</span> <span class="n">nat_deduction</span>

<span class="c">/-</span><span class="cm">- The type of Formulas, defined inductively</span>
<span class="cm">-/</span>
<span class="kn">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="c1">-- Atomic Formulas are introduced via natural numbers (atom 0, atom 1, atom 2)</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="c1">-- conjunction</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="c1">-- disjunction</span>
<span class="bp">|</span> <span class="n">or</span>  <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="c1">-- implication</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="c1">-- ⊥ is atom 0</span>
<span class="n">def</span> <span class="n">Form</span><span class="bp">.</span><span class="n">bot</span> <span class="o">:</span> <span class="n">Form</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">atom</span> <span class="mi">0</span>
<span class="c1">-- we define `¬A` as `A ⟹ ⊥`</span>
<span class="n">def</span> <span class="n">Form</span><span class="bp">.</span><span class="n">neg</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">imp</span> <span class="n">A</span> <span class="err">$</span> <span class="n">Form</span><span class="bp">.</span><span class="n">atom</span> <span class="mi">0</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">We now define notation and coercions for nicer looking formulas</span>
<span class="cm">-/</span>

<span class="c1">-- Coerce natural numbers to Formulas as atoms</span>
<span class="c1">-- Given p : ℕ, just write `p` or `↑p` instead of `atom p`</span>
<span class="c1">-- (`↑p` forces the coercion)</span>
<span class="kn">instance</span> <span class="n">nat_coe_Form</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℕ</span> <span class="n">Form</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">Form</span><span class="bp">.</span><span class="n">atom</span><span class="bp">⟩</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">and</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span><span class="o">:</span><span class="mi">74</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">or</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">imp</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">atom</span> <span class="mi">0</span>
<span class="kn">prefix</span> <span class="bp">`¬`</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">Form</span><span class="bp">.</span><span class="n">imp</span> <span class="n">A</span> <span class="err">⊥</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">¬</span><span class="err">⊥</span> <span class="c1">-- the simplest tautology</span>

<span class="kn">open</span> <span class="n">Form</span>

<span class="c">/-</span><span class="cm">- Inductive definition of a deduction X ≻ A (argument) from a set of Formulas X</span>
<span class="cm">to a Formula A. This is equivalent to the usual proof tree presentation, however,</span>
<span class="cm">there is no need to &quot;discharge&quot; Formulas - we just choose to keep them as assumptions</span>
<span class="cm">or not. This forces us to add a weakening rule to the usual collection of rules.</span>
<span class="cm">-/</span>
<span class="kn">inductive</span> <span class="n">deduction</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">weakening</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">Y</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="n">Y</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">assumption</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span>       <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">and_intro</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and_left</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">and_right</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span>
<span class="c1">-- note X may or may not contain A, which corresponds to the ability to</span>
<span class="c1">-- discharge formulas which are no longer assumptions (or not).</span>
<span class="bp">|</span> <span class="n">imp_intro</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="o">{</span><span class="n">A</span><span class="o">})</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⟹</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp_elim</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">{</span><span class="n">B</span><span class="o">}</span>   <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⟹</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span>
<span class="bp">|</span> <span class="n">or_left</span>    <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or_right</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or_elim</span>    <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="o">{</span><span class="n">A</span><span class="o">})</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="o">{</span><span class="n">B</span><span class="o">})</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">C</span>
<span class="bp">|</span> <span class="n">falsum</span>     <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span>       <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="err">⊥</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≻</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">deduction</span>

<span class="kn">end</span> <span class="n">nat_deduction</span>

<span class="c">/-</span><span class="cm">- A tactic to produce a deduction of something like `X ∪ {A} ≻ A`,</span>
<span class="cm">via the assumption rule and an automated proof of `A ∈ X ∪ {A}`</span>
<span class="cm">-/</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">assump</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">nat_deduction</span><span class="bp">.</span><span class="n">deduction</span><span class="bp">.</span><span class="n">assumption</span> <span class="bp">_;</span> <span class="n">obviously</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">nat_deduction</span>

<span class="kn">inductive</span> <span class="n">provable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">provable</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⊢</span><span class="n">I</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">provable</span>

<span class="n">def</span> <span class="n">compactify</span> <span class="o">{</span><span class="n">X</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≻</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">{</span><span class="n">X&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span> <span class="bp">//</span> <span class="err">↑</span><span class="n">X&#39;</span> <span class="err">⊆</span> <span class="n">X</span> <span class="bp">∧</span> <span class="err">↑</span><span class="n">X&#39;</span> <span class="err">⊢</span><span class="n">I</span> <span class="n">A</span> <span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">dXA</span><span class="o">,</span>
  <span class="n">induction&#39;</span> <span class="n">dXA</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">weakening</span> <span class="o">:</span>
    <span class="o">{</span> <span class="n">rcases</span> <span class="n">ih</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">X&#39;</span><span class="o">,</span> <span class="n">subX</span><span class="o">,</span> <span class="n">X&#39;pA</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">X&#39;</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_union_of_subset_left</span><span class="o">,</span>
      <span class="n">tidy</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">assumption</span> <span class="o">:</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">{</span><span class="n">A</span><span class="o">},</span> <span class="n">tidy</span><span class="o">,</span>
      <span class="n">assump</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">and_intro</span> <span class="o">:</span> <span class="n">X</span> <span class="n">A</span> <span class="n">B</span> <span class="n">dXA</span> <span class="n">dXB</span> <span class="n">ih₁</span> <span class="n">ih₂</span>
    <span class="o">{</span> <span class="n">rcases</span> <span class="n">ih₁</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">XA&#39;</span><span class="o">,</span> <span class="n">AsubX</span><span class="o">,</span> <span class="n">XA&#39;pA</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">ih₂</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">XB&#39;</span><span class="o">,</span> <span class="n">BsubX</span><span class="o">,</span> <span class="n">XB&#39;pB</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">existsi</span> <span class="n">XA&#39;</span> <span class="err">∪</span> <span class="n">XB&#39;</span><span class="o">,</span>
      <span class="n">sorry</span> <span class="o">}</span>

<span class="kn">end</span>
</code></pre></div>



<a name="205487112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205487112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205487112">(Jul 30 2020 at 14:43)</a>:</h4>
<p>Ah, you forgot to prove <code>decidable_eq Form</code></p>



<a name="205489064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205489064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205489064">(Jul 30 2020 at 14:57)</a>:</h4>
<p>use <code>@[derive decidable_eq]</code></p>



<a name="205547761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205547761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205547761">(Jul 31 2020 at 00:37)</a>:</h4>
<p>Interesting, how do I know when I need to show decidable equality?</p>



<a name="205547850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205547850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205547850">(Jul 31 2020 at 00:39)</a>:</h4>
<p>Also when defining an inductive type, is it possible to have a constructor whose target type is a product of the inductive type?<br>
For example,</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">deduction</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">and_elim</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="err">⨯</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span>
</code></pre></div>



<a name="205547906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205547906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205547906">(Jul 31 2020 at 00:40)</a>:</h4>
<p>This gives me <code>unexpected token</code> on the <code>\times</code></p>



<a name="205563307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205563307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205563307">(Jul 31 2020 at 06:59)</a>:</h4>
<p>No, each constructor must produce a <code>deduction</code>. For this example you need <code>and_left</code> and <code>and_right</code>.</p>



<a name="205592807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205592807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205592807">(Jul 31 2020 at 13:59)</a>:</h4>
<p>Yeah that's what I had, just trying to invest in less cases for the inductive proofs to follow. Could this be added to the functionality of <code>inductive</code>? (where in the background, it just splits it into two constructors). I had the same thought about and <code>\iff</code> kind of constructor for inductive propositions.</p>



<a name="205614208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205614208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205614208">(Jul 31 2020 at 16:54)</a>:</h4>
<p>Even if <code>inductive</code> had this functionality, how would this reduce the number of cases for induction proofs? What induction step do you think you would get from the constructor <code>and_elim</code>?</p>



<a name="205659279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205659279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205659279">(Aug 01 2020 at 02:18)</a>:</h4>
<p>I suppose it wouldn't make sense to collect an <code>\iff</code> induction into single case, since there's different inductive hypotheses for each direction, but for the <code>\times</code> situation like <code>and_elim</code> it would just be like <code>and_left</code> and <code>and_right</code>, and you just produce both within the same case.</p>



<a name="205659610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205659610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205659610">(Aug 01 2020 at 02:28)</a>:</h4>
<p>you can of course write these induction principles if you want to use them</p>



<a name="205659713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205659713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205659713">(Aug 01 2020 at 02:31)</a>:</h4>
<p>I assumed that something <code>inductive</code> would be core and untouchable?</p>



<a name="205660745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205660745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205660745">(Aug 01 2020 at 03:03)</a>:</h4>
<p>This is my attempt at formalising boolean models (this code is self contained). I had to add the <code>reducible</code> tag to <code>Model</code> otherwise it didn't understand <code>n ∈ M</code>, and it wouldn't recognise <code>{p,q}</code> as a <code>Model</code>. I did some reading on <code>reducible</code> <code>semireducible</code> and <code>irreducible</code> but I'm not sure if this is the correct usage - why do I need any tag at all? Isn't it obvious that a model satisfies <code>has_elem</code> and all the other properties of <code>finset Form</code>?</p>
<p>My main question however is that my use of <code>finset.fold</code> does not work properly when I use variable atoms. Specifically the first <code>#reduce</code> command successfully evaluates to <code>tt</code>, but the second is some giant mess with lots of <code>decidable.rec</code>. I do understand somewhat why this relates to decidability, but I have no idea how to fix it.</p>
<p>I am open to suggestions of betters ways of formalising models in Lean, I just did it this way because its very concise to state a model (just declare the set of true atoms). I tried looking through the flypitch project but I didn't find anything I could recognise as a model.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">or</span>  <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">and</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span><span class="o">:</span><span class="mi">74</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">or</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">imp</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">bot</span>

<span class="kn">instance</span> <span class="n">nat_coe_Form</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℕ</span> <span class="n">Form</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">Form</span><span class="bp">.</span><span class="n">atom</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">Model</span> <span class="o">:=</span> <span class="n">finset</span> <span class="bp">ℕ</span>

<span class="n">def</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Model</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="err">⊥</span>       <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="err">∈</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">A</span> <span class="bp">&amp;&amp;</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">B</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">A</span> <span class="bp">||</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">B</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">A</span> <span class="err">⟹</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">bnot</span> <span class="err">$</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">B</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">is_commutative</span> <span class="n">bool</span> <span class="n">band</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>   <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">is_associative</span> <span class="n">bool</span> <span class="n">band</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">eval_model</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Model</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="n">band</span> <span class="n">tt</span> <span class="o">(</span><span class="n">Form</span><span class="bp">.</span><span class="n">eval_model</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">eval_model</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span> <span class="o">{</span><span class="err">↑</span><span class="mi">0</span> <span class="err">⋁</span> <span class="err">↑</span><span class="mi">1</span><span class="o">,</span> <span class="err">↑</span><span class="mi">1</span><span class="o">}</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">eval_model</span> <span class="o">{</span><span class="n">p</span><span class="o">,</span><span class="n">q</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">,</span> <span class="n">q</span><span class="o">}</span>
</code></pre></div>



<a name="205751648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205751648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205751648">(Aug 03 2020 at 01:08)</a>:</h4>
<p>I've attempted to simplify my question, but this simpler version now gives <code>deterministic timeout</code> on the last line. I know in general it probably isn't possible to "compute" elementhood for any set, but surely it's possible to do so with finite sets and natural numbers, which have decidable equality.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">is_commutative</span> <span class="n">bool</span> <span class="n">band</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>   <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">is_associative</span> <span class="n">bool</span> <span class="n">band</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span><span class="bp">⟩</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="n">def</span> <span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span>
<span class="n">def</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="n">band</span> <span class="n">tt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="n">band</span> <span class="n">tt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">}</span>
</code></pre></div>



<a name="205751736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205751736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205751736">(Aug 03 2020 at 01:10)</a>:</h4>
<p>The last line involves open terms--I'm not sure what you're expecting to happen here?</p>



<a name="205751757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205751757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205751757">(Aug 03 2020 at 01:11)</a>:</h4>
<p>It will probably generate something pretty big before getting stuck.</p>



<a name="205751953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205751953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205751953">(Aug 03 2020 at 01:16)</a>:</h4>
<p>Well the answer is <code>tt</code> right?</p>



<a name="205751957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205751957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205751957">(Aug 03 2020 at 01:17)</a>:</h4>
<p>nope!</p>



<a name="205752026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752026">(Aug 03 2020 at 01:18)</a>:</h4>
<p>Is that because something like <code>p \in {p}</code> isn't definitionally equal to <code>true</code> or something? Even though it's logically equivalent?</p>



<a name="205752042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752042">(Aug 03 2020 at 01:19)</a>:</h4>
<p>yes, that is a simpler example</p>



<a name="205752088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752088">(Aug 03 2020 at 01:20)</a>:</h4>
<p><code>p \in {p}</code> is definitionally equal to something like <code>p = p</code> I guess</p>



<a name="205752097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752097">(Aug 03 2020 at 01:20)</a>:</h4>
<p>but this isn't definitionally equal to <code>true</code>, you need an axiom for that</p>



<a name="205752169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752169">(Aug 03 2020 at 01:22)</a>:</h4>
<p>similarly, to know what <code>{p, q}</code> even means (which controls the structure of the computation of <code>finset.fold</code>), you need to know whether <code>p</code> equals <code>q</code></p>



<a name="205752171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752171">(Aug 03 2020 at 01:22)</a>:</h4>
<p>so you'll get stuck on that front fairly quickly</p>



<a name="205752228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752228">(Aug 03 2020 at 01:24)</a>:</h4>
<p>there is an algorithm for computing <code>{p, q}</code>, which uses the decision procedure for equality on <code>nat</code>, which will try to apply induction to the variable <code>p</code> (or <code>q</code>) and get stuck there</p>



<a name="205752508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752508">(Aug 03 2020 at 01:33)</a>:</h4>
<p>How do workaround this, so that I can apply a model to a set of formulas, and have it separate into a bunch of facts about the valuations of each formula. For example take the model <code>v(p)=1, v(q)=0</code> (and everything other atom gets <code>0</code>) (represented however), then on this set of formulas <code>{p, p V q, p &amp; q}</code> I want to automatically introduce these facts into the goal state: <code>v(p)=1, v(p V q) = 1, v(p &amp; q) = 0</code>.</p>



<a name="205752555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752555">(Aug 03 2020 at 01:34)</a>:</h4>
<p>Whoops instead of 0 and 1 I mean <code>ff</code> and <code>tt</code></p>



<a name="205752692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752692">(Aug 03 2020 at 01:38)</a>:</h4>
<p>Sorry I just realised this is different since I'm not <code>band</code>ing the results all together, but both of these are objectives of mine</p>



<a name="205752724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205752724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205752724">(Aug 03 2020 at 01:39)</a>:</h4>
<p>Oh wait I should just do <code>\forall A \in {p,q}, &lt;model assigns tt to A&gt;</code> right?</p>



<a name="205753368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205753368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205753368">(Aug 03 2020 at 01:53)</a>:</h4>
<p>definitional equality is overrated</p>



<a name="205753371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205753371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205753371">(Aug 03 2020 at 01:53)</a>:</h4>
<p>just use a bunch of simp lemmas</p>



<a name="205753420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205753420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205753420">(Aug 03 2020 at 01:54)</a>:</h4>
<p>yes that will work</p>



<a name="205754959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205754959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205754959">(Aug 03 2020 at 02:31)</a>:</h4>
<p>Is there a <code>simp</code> lemma that would convert <code>\forall A \in {p,q,r}, P A</code> to <code>P p \and  \forall A \in {q,r}</code> (where repeated application would yield the conjunction <code>P p \and P q \and P r</code>) ? I'm guessing this would come down to how that finset notation is defined, but I couldn't find anything in the finset folder.</p>



<a name="205755683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205755683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205755683">(Aug 03 2020 at 02:51)</a>:</h4>
<p><code>rw mem_insert_iff</code>  then something about <code>forall_or</code>?</p>



<a name="205755745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205755745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205755745">(Aug 03 2020 at 02:53)</a>:</h4>
<p><code>finset.forall_mem_insert</code>. (not <code>@[simp]</code> btw)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="o">({</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">A</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">P</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="o">({</span><span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">forall_mem_insert</span>
</code></pre></div>



<a name="205755807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205755807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205755807">(Aug 03 2020 at 02:55)</a>:</h4>
<p>and your example yielding a conjunction:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="o">({</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">A</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">P</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">forall_mem_insert</span><span class="o">,</span> <span class="n">forall_eq</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_singleton</span><span class="o">]</span>
</code></pre></div>



<a name="205755917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205755917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205755917">(Aug 03 2020 at 02:58)</a>:</h4>
<p>Cool! Thanks for that :)</p>



<a name="205759820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205759820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205759820">(Aug 03 2020 at 04:50)</a>:</h4>
<p>Why isn't this a <code>set</code> theorem?</p>



<a name="205759897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205759897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205759897">(Aug 03 2020 at 04:53)</a>:</h4>
<p>Because it's not true for some subtle reason I'm missing or it just hasn't been written yet?</p>



<a name="205760539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/205760539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#205760539">(Aug 03 2020 at 05:12)</a>:</h4>
<p>Oh nevermind it's called <code>ball_insert_iff</code></p>



<a name="206217756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/206217756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#206217756">(Aug 07 2020 at 02:04)</a>:</h4>
<p>Why does notation not work properly in the goal-view for <code>𝕏</code> but it works as expected for <code>𝕐</code>?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">foo</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝕏</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">foo</span><span class="bp">.</span><span class="n">bar</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝕐</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">foo</span><span class="bp">.</span><span class="n">baz</span>

<span class="bp">#</span><span class="kn">check</span> <span class="err">𝕏</span> <span class="c1">-- foo.bar 0 : foo</span>
<span class="bp">#</span><span class="kn">check</span> <span class="err">𝕐</span> <span class="c1">-- 𝕐 : foo</span>
</code></pre></div>



<a name="206257439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/206257439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#206257439">(Aug 07 2020 at 13:39)</a>:</h4>
<p>Is it because the there's no general notation for <code>foo.bar n</code>?</p>



<a name="206259193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/206259193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#206259193">(Aug 07 2020 at 13:55)</a>:</h4>
<p>Lean has to have an "unparser" to be able to do printing like this, and apparently it only works on constants, not composite terms</p>



<a name="206259434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/206259434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#206259434">(Aug 07 2020 at 13:57)</a>:</h4>
<p>:(</p>



<a name="206259869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/206259869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#206259869">(Aug 07 2020 at 14:00)</a>:</h4>
<p>Ah I see how to fix it, </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">zero_bar</span> <span class="o">:=</span> <span class="n">foo</span><span class="bp">.</span><span class="n">bar</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝕏</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">zero_bar</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/index.html">Berkeley Lean Seminar</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html">Cycle Types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="232674603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232674603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232674603">(Mar 31 2021 at 22:21)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Here are a few questions about cycle types:<br>
1) Do you want to include 1's in the cycle type or not?<br>
2) Should the cycle type be a partition, a multiset, a sorted list, or something else?</p>



<a name="232674843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232674843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232674843">(Mar 31 2021 at 22:23)</a>:</h4>
<p>There should certainly be a partition version of it, and I think there are advantages to including 1s.</p>



<a name="232674909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232674909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232674909">(Mar 31 2021 at 22:24)</a>:</h4>
<p>(If we include 1s, it should be very easy to make it a partition).</p>



<a name="232674940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232674940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232674940">(Mar 31 2021 at 22:24)</a>:</h4>
<p>I agree that there advantages to including 1's. One disadvantage of including 1's is that it makes it painful to state things like "is_swap corresponds to this cycle type" or "an element of order p has a cycle type of this form"</p>



<a name="232675082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675082">(Mar 31 2021 at 22:25)</a>:</h4>
<p>Would it make sense to have two versions? A partition including 1's, and something (maybe a multiset or sorted list?) not including 1's.</p>



<a name="232675157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675157">(Mar 31 2021 at 22:26)</a>:</h4>
<p>I'd probably say a multiset not including 1s and then a partition including 1s makes sense.</p>



<a name="232675198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675198">(Mar 31 2021 at 22:26)</a>:</h4>
<p>If you derive it from <code>same_cycle</code>, you get 1s, and if you derive it from <code>cycle_factors</code>, you get no 1s.</p>



<a name="232675288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675288">(Mar 31 2021 at 22:27)</a>:</h4>
<p>The advantage I see to including 1s is that it might make it easier to produce the bijection between cycles that I think you need for conjugacy.</p>



<a name="232675481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675481">(Mar 31 2021 at 22:29)</a>:</h4>
<p>However, <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>'s work in <a href="https://github.com/leanprover-community/mathlib/issues/6959">#6959</a> may obviate the need to consider the 1s at all in the conjugacy argument.</p>



<a name="232675630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675630">(Mar 31 2021 at 22:30)</a>:</h4>
<p>I hadn't though about going from <code>same_cycle</code> (although I can't quite see how to do it nicely). If you go from <code>cycle_factors</code>, is there a nice way to avoid the <code>linear_order</code> assumption?</p>



<a name="232675659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675659">(Mar 31 2021 at 22:30)</a>:</h4>
<p>On one of my recent PRs I threw in a <code>trunc</code> version...</p>



<a name="232675759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675759">(Mar 31 2021 at 22:31)</a>:</h4>
<p>Yeah, <code>trunc_cycle_factors</code> in <a href="https://github.com/leanprover-community/mathlib/issues/6951">#6951</a></p>



<a name="232675818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675818">(Mar 31 2021 at 22:32)</a>:</h4>
<p>We should be able to use that to computably define a <code>cycle_type</code> multiset.</p>



<a name="232675944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232675944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232675944">(Mar 31 2021 at 22:33)</a>:</h4>
<p>Ok, I'll take a stab at this today, and I'll let you know when I've got something.</p>



<a name="232676092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232676092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232676092">(Mar 31 2021 at 22:34)</a>:</h4>
<p>As far as the partition, I might even suggest saving that for when we have conjugacy (and conjugacy classes, from <a href="https://github.com/leanprover-community/mathlib/issues/6896">#6896</a>) and defining an <code>equiv</code> between <code>conj_classes</code> and partitions.</p>



<a name="232676305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232676305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232676305">(Mar 31 2021 at 22:36)</a>:</h4>
<p>As far as proving that the same cycle type implies conjugacy, I feel like we can maybe manage to prove it for cycles, and inductively for products of disjoint permutations.</p>



<a name="232818783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232818783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232818783">(Apr 01 2021 at 20:19)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> I've made a start at constructing <code>cycles_type</code> from <code>trunc_cycle_factors</code>, from which it shouldn't be too hard to make the partition. It look doable, but let me know if you see an easier to prove that the <code>cycle_type</code> doesn't depend on the choice of <br>
<code>cycle_factors</code>.</p>



<a name="232824226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232824226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232824226">(Apr 01 2021 at 20:59)</a>:</h4>
<p>Where are you working on this?</p>



<a name="232824375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232824375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232824375">(Apr 01 2021 at 21:00)</a>:</h4>
<p>I think we want the lemma anyway that any two lists that satisfy the requirements of cycle factors are related by <code>list.perm</code>.</p>



<a name="232824498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232824498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232824498">(Apr 01 2021 at 21:01)</a>:</h4>
<p>That should be enough to appease the <code>trunc</code>, and it is a nicer place to put the <code>sorry</code>, but Idk how to prove it yet</p>



<a name="232825551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232825551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232825551">(Apr 01 2021 at 21:09)</a>:</h4>
<p>ah, sorry, I forgot the link: <a href="https://github.com/leanprover-community/mathlib/compare/cycle_type">https://github.com/leanprover-community/mathlib/compare/cycle_type</a></p>



<a name="232825585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232825585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232825585">(Apr 01 2021 at 21:09)</a>:</h4>
<p>Good point that we should prove the permutation fact</p>



<a name="232829426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232829426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232829426">(Apr 01 2021 at 21:44)</a>:</h4>
<p>Actually, not that sure it does help, because we know the <code>list</code>s each satisfy <code>list.erase_dup</code>, so we can turn them into finsets and use <code>finset.ext</code>. I think we need to show that a member of one is a member of the other anyway.</p>



<a name="232833688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232833688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232833688">(Apr 01 2021 at 22:25)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Would it make sense to prove something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">main_theorem</span>
  <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">perm</span> <span class="n">α</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">,</span> <span class="n">σ</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">σ.is_cycle</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="n">disjoint</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">c</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">l.prod.cycle_of</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
</code></pre></div>



<a name="232839915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232839915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232839915">(Apr 01 2021 at 23:34)</a>:</h4>
<p>Yes, then you can just hit it with <code>list.perm_ext</code></p>



<a name="232839935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232839935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232839935">(Apr 01 2021 at 23:34)</a>:</h4>
<p>I just pushed this approach to the branch. There's just one sorry left, but it's a bit of a doozy.</p>



<a name="232839946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232839946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232839946">(Apr 01 2021 at 23:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">thm2</span>
  <span class="o">(</span><span class="n">σ</span> <span class="n">τ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">σ</span> <span class="n">τ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">σ</span> <span class="bp">*</span> <span class="n">τ</span><span class="o">)</span><span class="bp">.</span><span class="n">cycle_of</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">σ.cycle_of</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">∨</span> <span class="n">τ.cycle_of</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232869296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232869296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232869296">(Apr 02 2021 at 07:21)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> The branch now is now sorry-free<br>
<a href="https://github.com/leanprover-community/mathlib/compare/cycle_type">https://github.com/leanprover-community/mathlib/compare/cycle_type</a></p>



<a name="232870919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/232870919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#232870919">(Apr 02 2021 at 07:43)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6999">#6999</a></p>



<a name="233030789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233030789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233030789">(Apr 03 2021 at 20:30)</a>:</h4>
<p>Check out <a href="https://github.com/leanprover-community/mathlib/tree/cycle_conj">branch#cycle_conj</a></p>



<a name="233030801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233030801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233030801">(Apr 03 2021 at 20:31)</a>:</h4>
<p>I have a proof (although some things need to be cleaned up) that two cycles of the same size are conjugate</p>



<a name="233033744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233033744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233033744">(Apr 03 2021 at 21:17)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7024">#7024</a></p>



<a name="233036225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036225">(Apr 03 2021 at 22:02)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Great! I'm wondering whether we can get the full conjugate/partition theorem from the induction lemma?</p>



<a name="233036413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036413">(Apr 03 2021 at 22:05)</a>:</h4>
<p>If you look at my proof, it basically glues two <code>equiv</code>s together</p>



<a name="233036508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036508">(Apr 03 2021 at 22:07)</a>:</h4>
<p>Actually, so I'm curious. Do you think that this result will be useful in proving the full theorem? I'm starting to get worried that a cycle induction strategy won't work.</p>



<a name="233036522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036522">(Apr 03 2021 at 22:07)</a>:</h4>
<p>For two disjoint <code>perm</code>s, you could glue together <code>equiv</code>s between their supports with one between the rest of the elements</p>



<a name="233036524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036524">(Apr 03 2021 at 22:07)</a>:</h4>
<p>I think it will work.</p>



<a name="233036605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036605">(Apr 03 2021 at 22:08)</a>:</h4>
<p>Would that require passing permutations back and forth between subtypes? I'm worried that it might be a bit painful.</p>



<a name="233036682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233036682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233036682">(Apr 03 2021 at 22:10)</a>:</h4>
<p>Not more painful than the cycle proof, and I’m not sure I see a better option</p>



<a name="233037036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233037036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233037036">(Apr 03 2021 at 22:16)</a>:</h4>
<p>Is it conceivable that you could prove a lemma along these lines?</p>
<p>Let a,b,c,d be permutations. Assume a and b are disjoint, c and d are disjoint, a is conjugate to c, b is conjugate to d. Then <code>a*b</code> is conjugate to <code>c*d</code>.</p>



<a name="233037051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233037051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233037051">(Apr 03 2021 at 22:16)</a>:</h4>
<p>Yes, that’s what I had in mind.</p>



<a name="233037071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233037071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233037071">(Apr 03 2021 at 22:16)</a>:</h4>
<p>If so, then you could make a plain induction work, without the need for any more subtype mess (outside of the proof of the lemma)</p>



<a name="233037096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233037096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233037096">(Apr 03 2021 at 22:17)</a>:</h4>
<p>I think the alternative is creating some other data structure that represents cycle notation</p>



<a name="233113233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233113233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233113233">(Apr 04 2021 at 21:15)</a>:</h4>
<p>I have that lemma proven at <a href="https://github.com/leanprover-community/mathlib/tree/disjoint_conj">branch#disjoint_conj</a>.</p>



<a name="233113407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233113407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233113407">(Apr 04 2021 at 21:16)</a>:</h4>
<p>Again, messy, and I should really think more about how I'm going to organize all of these random permutation facts and long proofs, but the statement is there in case you want to <code>sorry</code> it and work on proving the <code>cycle_type</code> induction.</p>



<a name="233169334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233169334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233169334">(Apr 05 2021 at 13:07)</a>:</h4>
<p>Kevin just let me know about this stream! I've been doing some parallel/complementary work. I've been trying to make it possible to specify explicit perm cycles using lists. Here's a smattering of what I have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">perm.commutes_of_disjoint</span> <span class="o">(</span><span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">_root_.disjoint</span> <span class="o">(</span><span class="n">function.fixed_points</span> <span class="n">e₁</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="o">(</span><span class="n">function.fixed_points</span> <span class="n">e₂</span><span class="o">)</span><span class="bp">ᶜ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">commute</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">ht₁</span> <span class="o">:</span> <span class="n">function.is_fixed_pt</span> <span class="n">e₁</span> <span class="n">t</span><span class="bp">;</span>
  <span class="n">by_cases</span> <span class="n">ht₂</span> <span class="o">:</span> <span class="n">function.is_fixed_pt</span> <span class="n">e₂</span> <span class="n">t</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ht₁.eq</span><span class="o">,</span> <span class="n">ht₂.eq</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">function.is_fixed_pt</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">e₂</span> <span class="n">t</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">function.mem_fixed_points</span><span class="o">,</span> <span class="bp">←</span><span class="n">set.not_mem_compl_iff</span><span class="o">],</span>
        <span class="n">refine</span> <span class="n">set.mem_disjoint_imp</span> <span class="n">_</span> <span class="n">h.symm</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">set.mem_compl_iff</span><span class="o">,</span> <span class="n">function.mem_fixed_points</span><span class="o">],</span>
        <span class="n">contrapose</span><span class="bp">!</span> <span class="n">ht₂</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">function.is_fixed_pt</span> <span class="n">at</span> <span class="n">ht₂</span> <span class="bp">⊢</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">e₂.injective</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">ht₂</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">ht₁.eq</span><span class="o">,</span> <span class="n">this.eq</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- how does one use wlog to skip this?</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">function.is_fixed_pt</span> <span class="n">e₂</span> <span class="o">(</span><span class="n">e₁</span> <span class="n">t</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">function.mem_fixed_points</span><span class="o">,</span> <span class="bp">←</span><span class="n">set.not_mem_compl_iff</span><span class="o">],</span>
        <span class="n">refine</span> <span class="n">set.mem_disjoint_imp</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">set.mem_compl_iff</span><span class="o">,</span> <span class="n">function.mem_fixed_points</span><span class="o">],</span>
        <span class="n">contrapose</span><span class="bp">!</span> <span class="n">ht₁</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">function.is_fixed_pt</span> <span class="n">at</span> <span class="n">ht₁</span> <span class="bp">⊢</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">e₁.injective</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">ht₁</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">ht₂.eq</span><span class="o">,</span> <span class="n">this.eq</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">set.mem_inter</span> <span class="n">ht₁</span> <span class="n">ht₂</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">is_rotated</span> <span class="o">(</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">l.rotate</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">l'</span>

<span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">~</span><span class="n">r</span> <span class="bp">`</span><span class="o">:</span><span class="mi">1000</span> <span class="o">:=</span> <span class="n">is_rotated</span>

<span class="kd">def</span> <span class="n">cycle</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_rotated.setoid</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>



<a name="233169440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233169440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233169440">(Apr 05 2021 at 13:08)</a>:</h4>
<p>With the goal of proving things like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">form_perm_rotation_invariant</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">form_perm</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">form_perm</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">is_cycle_form_perm</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">is_cycle</span> <span class="o">(</span><span class="n">form_perm</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">l</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="233169457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233169457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233169457">(Apr 05 2021 at 13:08)</a>:</h4>
<p>(not including a lot of API)</p>



<a name="233169874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233169874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233169874">(Apr 05 2021 at 13:12)</a>:</h4>
<p>Which, looking at your code, is similar to <code>cycle_type</code></p>



<a name="233171728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233171728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233171728">(Apr 05 2021 at 13:30)</a>:</h4>
<p>If you'd like any contribution or if you have any suggestions on refactoring, let me know!</p>



<a name="233177150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233177150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233177150">(Apr 05 2021 at 14:16)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/set.not_mem_compl_iff">docs#set.not_mem_compl_iff</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/set.mem_disjoint_imp">docs#set.mem_disjoint_imp</a> seem not to exist</p>



<a name="233178431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233178431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233178431">(Apr 05 2021 at 14:26)</a>:</h4>
<p>Yeah, I just wanted to share a snippet of what I had.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">set.mem_disjoint_imp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∉</span> <span class="n">t</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hd</span> <span class="o">(</span><span class="n">set.mem_inter</span> <span class="n">h</span> <span class="n">ht</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">set.not_mem_compl_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">set.not_not_mem</span>
</code></pre></div>



<a name="233182121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182121">(Apr 05 2021 at 14:56)</a>:</h4>
<p>Hrm, I think that means we need to do a lot more coordination work, <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span></p>



<a name="233182197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182197">(Apr 05 2021 at 14:57)</a>:</h4>
<p>I'm not sure I see the benefit of this version of <code>perm.commutes_of_disjoint</code> over the existing proof of <code>perm.disjoint.mul_comm</code></p>



<a name="233182288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182288">(Apr 05 2021 at 14:58)</a>:</h4>
<p>but if you can represent cycles as lists, then that probably means you can give a much more intuitive proof of the conjugacy results</p>



<a name="233182479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182479">(Apr 05 2021 at 15:00)</a>:</h4>
<p>I haven't merged any of your branches -- just discovered them!</p>



<a name="233182635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182635">(Apr 05 2021 at 15:00)</a>:</h4>
<p>Is there a particular PR or branch I should rebase on?</p>



<a name="233182818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182818">(Apr 05 2021 at 15:00)</a>:</h4>
<p>I'm not sure, <code>equiv.perm.disjoint.mul_comm</code>is in master, just in the <code>group_theory.perm.sign</code> file, where it maybe shouldn't be</p>



<a name="233182938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233182938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233182938">(Apr 05 2021 at 15:01)</a>:</h4>
<p>Most of my random-helpful-lemmas are in <a href="https://github.com/leanprover-community/mathlib/tree/card_support_perm">branch#card_support_perm</a></p>



<a name="233183139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233183139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233183139">(Apr 05 2021 at 15:02)</a>:</h4>
<p>which is <a href="https://github.com/leanprover-community/mathlib/issues/6951">#6951</a></p>



<a name="233183596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233183596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233183596">(Apr 05 2021 at 15:03)</a>:</h4>
<p>but the work on <a href="https://github.com/leanprover-community/mathlib/tree/cycle_conj">branch#cycle_conj</a> (<a href="https://github.com/leanprover-community/mathlib/issues/7024">#7024</a>) which I've improved at <a href="https://github.com/leanprover-community/mathlib/tree/disjoint_conj">branch#disjoint_conj</a> involves some subtype shenanigans and long composition chains of <code>equiv</code>s</p>



<a name="233183647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233183647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233183647">(Apr 05 2021 at 15:03)</a>:</h4>
<p>and the goal is just to prove the result that two permutations with the same cycle type are conjugate</p>



<a name="233183748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233183748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233183748">(Apr 05 2021 at 15:04)</a>:</h4>
<p>which is a 1-line proof on paper</p>



<a name="233183908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233183908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233183908">(Apr 05 2021 at 15:04)</a>:</h4>
<p>and it might be possible to get closer to that 1-line proof, and perhaps skip the induction, if you have both permutations represented as products of disjoint cycles which are represented as lists</p>



<a name="233184261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233184261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233184261">(Apr 05 2021 at 15:06)</a>:</h4>
<p>Yeah, and a perm cycle should be representable as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">form_perm</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zip_with</span> <span class="n">equiv.swap</span> <span class="n">l</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">tail.prod</span>
</code></pre></div>



<a name="233184302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233184302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233184302">(Apr 05 2021 at 15:06)</a>:</h4>
<p>Where it behave as expected if <code>nodup l</code></p>



<a name="233184351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233184351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233184351">(Apr 05 2021 at 15:07)</a>:</h4>
<p>(Or just define it with <code>erase_dup</code> in there)</p>



<a name="233184423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233184423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233184423">(Apr 05 2021 at 15:07)</a>:</h4>
<p>Then disjointedness has to do with a statement about some sublists being disjoint or not</p>



<a name="233184579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233184579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233184579">(Apr 05 2021 at 15:08)</a>:</h4>
<p>I guess my question is</p>



<a name="233184985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233184985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233184985">(Apr 05 2021 at 15:10)</a>:</h4>
<p>If I give you two lists of disjoint cycles, with the cycles represented as lists, and the lists of the lengths of the cycles are the same, how hard might it be to define the equiv mapping from the ith element of the jth cycle of one list to the ith element of the jth cycle of the other list?</p>



<a name="233185362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233185362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233185362">(Apr 05 2021 at 15:11)</a>:</h4>
<p>Do you know that each of the cycle elements are paired in length?</p>



<a name="233185429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233185429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233185429">(Apr 05 2021 at 15:12)</a>:</h4>
<p>Yes, but I did a bad job of describing that condition.</p>



<a name="233185440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233185440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233185440">(Apr 05 2021 at 15:12)</a>:</h4>
<p>Then it's just a stacked zip_with</p>



<a name="233185681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233185681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233185681">(Apr 05 2021 at 15:14)</a>:</h4>
<p>I'm not sure I follow.  <code>list.zip_with</code> seems to be a tool for applying a binary function pointwise to two lists to get a third list.</p>



<a name="233185784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233185784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233185784">(Apr 05 2021 at 15:15)</a>:</h4>
<p>I'm trying to find a permutation <code>f</code> such that when I apply <code>list.map f</code> to every cycle element in the first list, I get the second list</p>



<a name="233186004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233186004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233186004">(Apr 05 2021 at 15:16)</a>:</h4>
<p>Because <code>list.map</code> will correspond to conjugation for a given cycle, as in lemma <code>conjugation_of_cycle</code> at <a href="https://isabelle.in.tum.de/website-Isabelle2018/dist/library/HOL/HOL-Algebra/Cycles.html">https://isabelle.in.tum.de/website-Isabelle2018/dist/library/HOL/HOL-Algebra/Cycles.html</a></p>



<a name="233186761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233186761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233186761">(Apr 05 2021 at 15:20)</a>:</h4>
<p>My first question is when you say "list of cycles" you mean <code>{ l : list (equiv.perm α) // ∀ p ∈ l, is_cycle p }</code>?</p>



<a name="233186926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233186926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233186926">(Apr 05 2021 at 15:21)</a>:</h4>
<p>I mean an element of that, yes, or else a list of lists, such that each element represents a disjoint cycle (so I suppose, a list such that if you concatenated all the elements it'd be <code>nodup</code>)</p>



<a name="233186982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233186982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233186982">(Apr 05 2021 at 15:22)</a>:</h4>
<p>Right. So I think trying to map element to element will be wonky because of the rotational invariance</p>



<a name="233187066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233187066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233187066">(Apr 05 2021 at 15:22)</a>:</h4>
<p>So, if you have to map element to element, then you have to escape the rotational invariance, probably via choosing the lexicographically smallest representation of that cycle</p>



<a name="233187186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233187186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233187186">(Apr 05 2021 at 15:23)</a>:</h4>
<p>I think we can get around that. I don't need this to be computable, although having a computable version under extra assumptions would potentially be useful.</p>



<a name="233187458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233187458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233187458">(Apr 05 2021 at 15:25)</a>:</h4>
<p>Ah. My goal has precisely been computability here, which is why I've been building "bottom-up" from lists</p>



<a name="233187543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233187543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233187543">(Apr 05 2021 at 15:26)</a>:</h4>
<p>Yeah, I can tell... that's why I tried to phrase it in terms of assuming we already have two lists of lists, rather than two lists of cycles.</p>



<a name="233187610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233187610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233187610">(Apr 05 2021 at 15:26)</a>:</h4>
<p>Assuming we've already got past that choice hurdle.</p>



<a name="233187675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233187675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233187675">(Apr 05 2021 at 15:26)</a>:</h4>
<p>There's still going to have to be choice involved, in order to map the fixed points of one permutation to the other.</p>



<a name="233188007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233188007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233188007">(Apr 05 2021 at 15:29)</a>:</h4>
<p>One conclusion I have is that I should probably recall (or reduce the scope of) <a href="https://github.com/leanprover-community/mathlib/issues/7024">#7024</a></p>



<a name="233188597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233188597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233188597">(Apr 05 2021 at 15:33)</a>:</h4>
<p>I'm not too familiar with HOL syntax. Is this describing that conjugating a [perm represented by disjoint cycles] by a perm is equal to [perm represented by disjoint cycles, [each trans that perm]]?</p>



<a name="233189211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233189211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233189211">(Apr 05 2021 at 15:37)</a>:</h4>
<p>I believe it’s more like [perm represented by disjoint cycles, [each <code>list.map</code>ped by that perm]</p>



<a name="233189415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233189415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233189415">(Apr 05 2021 at 15:39)</a>:</h4>
<p>Proving that should probably be easy enough, but proving sufficient conditions for there to exist a perm that does that particular conjugation is harder</p>



<a name="233189790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233189790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233189790">(Apr 05 2021 at 15:42)</a>:</h4>
<p>Right, each of the disjoint cycles is conjugated by that perm, if I understand correctly</p>



<a name="233189822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233189822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233189822">(Apr 05 2021 at 15:42)</a>:</h4>
<p>So can't you prove that it's the case for one, so it's the care for all?</p>



<a name="233189855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233189855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233189855">(Apr 05 2021 at 15:42)</a>:</h4>
<p>(which is your "easy to prove" statement)</p>



<a name="233205059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233205059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233205059">(Apr 05 2021 at 17:47)</a>:</h4>
<p>Actually, I have an idea for how to do the harder statement. To construct such a permutation, we first concatenate both lists of lists, and then pad them both with all the fixed points (using <code>list.filter</code> or something) so that the domain of our permutations is listed out twice. Then, using <code>fintype.equiv_fin.of_forall_mem_list</code>, we can construct a permutation that sends the <code>i</code>th entry of one list to the <code>i</code>th entry of the other.</p>



<a name="233251623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233251623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233251623">(Apr 06 2021 at 00:55)</a>:</h4>
<p>Why should <code>perm.support</code> be defined solely for <code>fintype</code>?</p>



<a name="233252212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233252212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233252212">(Apr 06 2021 at 01:03)</a>:</h4>
<p>Because re-reading the code, I see that my <code>commute</code> lemma above works for non-fintype too.</p>



<a name="233264799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233264799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233264799">(Apr 06 2021 at 04:20)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> In general, the support of a permutation won't be a finset. But I suppose you could try to refactor support to be a set.</p>



<a name="233264904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/233264904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#233264904">(Apr 06 2021 at 04:22)</a>:</h4>
<p>Yes, agreed that it can often be nonfinite. I have already started on the refactor</p>



<a name="234251207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234251207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234251207">(Apr 13 2021 at 00:36)</a>:</h4>
<p><span class="user-mention" data-user-id="253861">@Thomas Browning</span>,  I have just one sorry at <a href="https://github.com/leanprover-community/mathlib/tree/disjoint_conj">branch#disjoint_conj</a> required to prove that the same cycle type implies conjugacy.</p>



<a name="234251267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234251267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234251267">(Apr 13 2021 at 00:37)</a>:</h4>
<p>We just need to show that if the cycle type of a permutation is <code>m1 + m2</code>, then it can be expressed as a product of disjoint permutations with cycle types <code>m1</code> and <code>m2</code>.</p>



<a name="234251282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234251282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234251282">(Apr 13 2021 at 00:37)</a>:</h4>
<p>Given as you wrote up <code>cycle_type</code>, do you have any insight into what kind of (possibly induction) we want to do?</p>



<a name="234252292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234252292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234252292">(Apr 13 2021 at 00:51)</a>:</h4>
<p>Can you induct on sigma, after reverting m1 and m2?</p>



<a name="234351068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234351068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234351068">(Apr 13 2021 at 15:45)</a>:</h4>
<p>I think I’m finding that <code>cycle_induction_on</code> should allow you to assume that one of your two disjoint permutations is a cycle. I keep trying to use <code>trunc_cycle_factors</code> to get that...</p>



<a name="234359803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234359803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234359803">(Apr 13 2021 at 16:36)</a>:</h4>
<p>Ah, so would changing the induction lemma to this be better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_eliminator]</span> <span class="kd">lemma</span> <span class="n">cycle_induction_on</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">base_one</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">base_cycles</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">β</span><span class="o">,</span> <span class="n">σ.is_cycle</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">σ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">induction_disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">σ</span> <span class="n">τ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">β</span><span class="o">,</span> <span class="n">σ.is_cycle</span> <span class="bp">→</span> <span class="n">disjoint</span> <span class="n">σ</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">*</span> <span class="n">τ</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">P</span> <span class="n">σ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">perm</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">τ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">β</span><span class="o">,</span> <span class="n">τ</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">τ.is_cycle</span><span class="o">)</span> <span class="bp">→</span> <span class="n">l.pairwise</span> <span class="n">disjoint</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">l.prod</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">classical</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">σ.trunc_cycle_factors.out</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">P</span> <span class="n">x.2.1</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">this</span> <span class="n">x.1</span> <span class="n">x.2.2.1</span> <span class="n">x.2.2.2</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">σ</span> <span class="n">l</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">base_one</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">list.prod_cons</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">induction_disjoint</span> <span class="n">σ</span> <span class="n">l.prod</span> <span class="o">(</span><span class="n">h1</span> <span class="n">σ</span> <span class="o">(</span><span class="n">l.mem_cons_self</span> <span class="n">σ</span><span class="o">))</span>
      <span class="o">(</span><span class="n">disjoint_prod_list_of_disjoint</span> <span class="o">(</span><span class="n">list.pairwise_cons.mp</span> <span class="n">h2</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
      <span class="o">(</span><span class="n">base_cycles</span> <span class="n">σ</span> <span class="o">(</span><span class="n">h1</span> <span class="n">σ</span> <span class="o">(</span><span class="n">l.mem_cons_self</span> <span class="n">σ</span><span class="o">)))</span>
      <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">τ</span> <span class="n">hτ</span><span class="o">,</span> <span class="n">h1</span> <span class="n">τ</span> <span class="o">(</span><span class="n">list.mem_cons_of_mem</span> <span class="n">σ</span> <span class="n">hτ</span><span class="o">))</span> <span class="o">(</span><span class="n">list.pairwise_of_pairwise_cons</span> <span class="n">h2</span><span class="o">))</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234377470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234377470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234377470">(Apr 13 2021 at 18:28)</a>:</h4>
<p>Yeah, I think so.</p>



<a name="234412450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234412450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234412450">(Apr 13 2021 at 22:35)</a>:</h4>
<p>I've made a lot of headway on constructable cycles via lists, like proving</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_cycle_form_perm</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">xs</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">is_cycle</span> <span class="o">(</span><span class="n">form_perm</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">xs</span><span class="o">))</span> <span class="o">:=</span>
</code></pre></div>
<p><a href="https://github.com/leanprover-community/mathlib/commit/e7ffca5fffc981a097e0fdf1285977aae78216d9#diff-9c65c703978eccccaa9dcbcc614d775ffe4a39aac3347edb1f88c5c12b403cd4R784">https://github.com/leanprover-community/mathlib/commit/e7ffca5fffc981a097e0fdf1285977aae78216d9#diff-9c65c703978eccccaa9dcbcc614d775ffe4a39aac3347edb1f88c5c12b403cd4R784</a></p>



<a name="234412578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Cycle%20Types/near/234412578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Cycle.20Types.html#234412578">(Apr 13 2021 at 22:36)</a>:</h4>
<p>As well as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">form_perm_reverse</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">form_perm</span> <span class="n">l.reverse</span> <span class="bp">=</span> <span class="o">(</span><span class="n">form_perm</span> <span class="n">l</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">form_perm_rotate</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">form_perm</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">form_perm</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">support_form_perm_of_nodup</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">l</span> <span class="bp">≠</span> <span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="o">:</span>
  <span class="n">support</span> <span class="o">(</span><span class="n">form_perm</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l.to_finset</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
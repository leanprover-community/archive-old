---
layout: archive
title: Zulip Chat Archive
permalink: /stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/index.html">Berkeley Lean Seminar</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html">Two silly questions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200283634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200283634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rahul Dalal <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200283634">(Jun 09 2020 at 20:12)</a>:</h4>
<p>What is the difference between passing in something like  "function \&lt; a b \&gt; " and just doing "function a b"</p>
<p>Related to this, what exactly is rintro \&lt;a b\&gt;  doing? What does it mean when one of those is replaced with rfl?</p>



<a name="200283748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200283748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200283748">(Jun 09 2020 at 20:13)</a>:</h4>
<p><code>\&lt;a, b\&gt;</code> is one term, and <code>a b</code> is two.</p>



<a name="200283938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200283938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200283938">(Jun 09 2020 at 20:14)</a>:</h4>
<p>Sometimes you want to deal with the type of natural numbers less than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>. In Lean this is the "canonical set of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>" and it's denoted <code>fin n</code>.</p>



<a name="200284143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200284143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200284143">(Jun 09 2020 at 20:16)</a>:</h4>
<p>A term of type <code>fin n</code> is two things: a natural number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>, and a proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m&lt;n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>. The way I thought about such a concept for decades was that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> was a number and the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m&lt;n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> was a proof, and that numbers and proofs were entirely different things. An interesting consequence of doing maths in Type theory rather than set theory is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> is a term, and a proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m&lt;n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is also a term.</p>



<a name="200284449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200284449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200284449">(Jun 09 2020 at 20:18)</a>:</h4>
<p>So a term of type <code>fin n</code> is a package of data, consisting both of <code>m</code> and the proof that <code>m&lt;n</code>. In particular if <code>a : fin n</code> then <code>a</code> is <em>not</em> a natural number.</p>



<a name="200284575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200284575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200284575">(Jun 09 2020 at 20:19)</a>:</h4>
<p>So given that <code>a</code> is some kind of package of data, one has to know how to get to <code>m</code> and the proof.</p>



<a name="200284724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200284724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200284724">(Jun 09 2020 at 20:21)</a>:</h4>
<p>To figure out how to do this, we need to look at the definition of <code>fin n</code> by typing something like <code>#check fin</code> and then right clicking on <code>fin</code> and peeking at the definition. We find that <code>fin n</code> is defined to be a <code>structure</code>, which means an inductive type with one constructor.</p>



<a name="200284749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200284749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200284749">(Jun 09 2020 at 20:21)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_lt</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="200284797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200284797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200284797">(Jun 09 2020 at 20:21)</a>:</h4>
<p>So if <code>a : fin n</code> then <code>a.val</code> will be the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> above, and <code>a.is_lt</code> will be the proof that it's less than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>.</p>



<a name="200285000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285000">(Jun 09 2020 at 20:23)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>In this example, the claim is that for every x of type <code>fin 10</code> we can find an <code>m</code> such that <code>m&lt;10</code>. Note that <code>m=x</code> won't do, because <code>x</code> isn't a natural number, despite the fact that sometimes people will refer to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> as "a natural number less than 10". It's not that, it's a term of type <code>fin 10</code> so it's a pair.</p>



<a name="200285132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285132">(Jun 09 2020 at 20:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="c1">-- I always do this</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  x : fin 10</span>
<span class="cm">  ⊢ ∃ (m : ℕ), m &lt; 10</span>
<span class="cm">  -/</span>
  <span class="n">use</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  x : fin 10</span>
<span class="cm">  ⊢ x.val &lt; 10</span>
<span class="cm">  -/</span>
  <span class="n">exact</span> <span class="n">x</span><span class="bp">.</span><span class="n">is_lt</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200285169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285169">(Jun 09 2020 at 20:25)</a>:</h4>
<p>The natural number we use is <code>x.val</code>, and the proof it satisfies the right thing is <code>x.is_lt</code>.</p>



<a name="200285278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285278">(Jun 09 2020 at 20:26)</a>:</h4>
<p>Another way of getting the terms out of a structure is to use the <code>cases</code> command.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="c1">-- I always do this</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  m : ℕ,</span>
<span class="cm">  hm : m &lt; 10</span>
<span class="cm">  ⊢ ∃ (m : ℕ), m &lt; 10</span>
<span class="cm">  -/</span>
  <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hm</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200285551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285551">(Jun 09 2020 at 20:28)</a>:</h4>
<p><code>cases</code> is a core Lean tactic. Sometimes structures are fancier objects though, with 3 or more fields, or fields containing other structures, and so the <code>rcases</code> tactic was born, which can take more complex structures apart. For this the standard cases syntax of just listing variable names wasn't powerful enough, so they started with these pointy brackets.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="c1">-- I always do this</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">x</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hm</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200285623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285623">(Jun 09 2020 at 20:29)</a>:</h4>
<p><code>intro, rcases</code> was such a common idiom that <code>rintro</code> was born:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hm</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200285663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285663">(Jun 09 2020 at 20:29)</a>:</h4>
<p>This introduces x and then instantly takes it apart into its pieces.</p>



<a name="200285875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285875">(Jun 09 2020 at 20:31)</a>:</h4>
<p>Here's a silly structure:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="c1">-- I always do this</span>

<span class="kn">structure</span> <span class="n">silly</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">37</span><span class="o">)</span>
<span class="o">(</span><span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">silly</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200285949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200285949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200285949">(Jun 09 2020 at 20:31)</a>:</h4>
<p>To make a term of type <code>silly</code> you need to supply two naturals, a boolean, a proof that the two naturals are equal, and a proof that one of the naturals is less than 37.</p>



<a name="200286104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200286104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rahul Dalal <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200286104">(Jun 09 2020 at 20:32)</a>:</h4>
<p>Thank you!</p>



<a name="200286228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200286228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200286228">(Jun 09 2020 at 20:33)</a>:</h4>
<p>Using our <code>rintro</code> skills we can solve this example as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">silly</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">hnm</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="c1">-- goal is now a mess</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  n : ℕ,</span>
<span class="cm">  b : bool,</span>
<span class="cm">  m : ℕ,</span>
<span class="cm">  h : n &lt; 37,</span>
<span class="cm">  hnm : m = n</span>
<span class="cm">  ⊢ m &lt; 37</span>
<span class="cm">  -/</span>
  <span class="n">rw</span> <span class="n">hnm</span><span class="o">,</span>
  <span class="c1">-- ⊢ n &lt; 37</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200286359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200286359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200286359">(Jun 09 2020 at 20:34)</a>:</h4>
<p>(<code>dsimp</code> simplifies <code>{m := blah, ... }.m</code> to <code>blah</code>)</p>



<a name="200286493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200286493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200286493">(Jun 09 2020 at 20:35)</a>:</h4>
<p>But <code>rintro</code> has got one more trick up its sleeve -- instead of rintroing <code>hnm</code> we can put <code>rfl</code> instead, which just means "define one side to be the other side".</p>



<a name="200286623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200286623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200286623">(Jun 09 2020 at 20:36)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">silly</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="c1">-- h is now a proof of m&lt;37!</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200286647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200286647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200286647">(Jun 09 2020 at 20:36)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rintro">tactic#rintro</a></p>



<a name="200287519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200287519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rahul Dalal <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200287519">(Jun 09 2020 at 20:43)</a>:</h4>
<p>So practically, you can put rfl in any spot where the corresponding term is an equality or equivalence and it will apply this to everything other term you are creating in the rintro?</p>



<a name="200287569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200287569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200287569">(Jun 09 2020 at 20:43)</a>:</h4>
<p>I'm not sure about an equivalence but yes an equality</p>



<a name="200287678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200287678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200287678">(Jun 09 2020 at 20:44)</a>:</h4>
<p>It will look to see if one side or the other is a bare variable, and if one of them is then it will basically just sub in its value everywhere</p>



<a name="200287730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200287730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200287730">(Jun 09 2020 at 20:44)</a>:</h4>
<p>What it's actually doing is <code>cases h</code> if <code>h : a = b</code>!</p>



<a name="200287861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200287861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200287861">(Jun 09 2020 at 20:45)</a>:</h4>
<p>Because <code>=</code> is not a primitive notion in type theory, it's notation for <code>eq</code> which is an inductive type with one constructor, just like <code>silly</code></p>



<a name="200287999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200287999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200287999">(Jun 09 2020 at 20:46)</a>:</h4>
<p><code>eq a b</code> is an inductive type with one constructor, <code>refl a</code> which is a term of type <code>eq a a</code> (note I just corrected a bad typo here)</p>



<a name="200288089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200288089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200288089">(Jun 09 2020 at 20:47)</a>:</h4>
<p>If you work out the recursor for that type, it's the principle that if you know P(a) and you know that a=b, you can deduce P(b)</p>



<a name="200288159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200288159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200288159">(Jun 09 2020 at 20:48)</a>:</h4>
<p>Ie it's the fact that you can substitute in an equality</p>



<a name="200288190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200288190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200288190">(Jun 09 2020 at 20:48)</a>:</h4>
<p>This is the basic principle behind the rewrite tactic</p>



<a name="200289416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Two%20silly%20questions/near/200289416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rahul Dalal <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Two.20silly.20questions.html#200289416">(Jun 09 2020 at 20:58)</a>:</h4>
<p>ok, thanks again!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
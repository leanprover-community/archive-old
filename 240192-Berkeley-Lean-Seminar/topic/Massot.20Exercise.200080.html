---
layout: archive
title: Zulip Chat Archive
permalink: /stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/index.html">Berkeley Lean Seminar</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html">Massot Exercise 0080</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="203315132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203315132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jordan Brown <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203315132">(Jul 08 2020 at 19:59)</a>:</h4>
<p>I have been stuck trying to figure out how to prove that the range of a continuous function on a compact interval is bounded, as after I form the set that is the range and try to show the inclusion, taking say y to be an arbitrary element of the range, I cannot get some x in the interval such that y = f x, when it seems like this should be definitionally true. The solution uses rintros, but whenever I try to use it, I get an error saying that the range is not an inductive datatype. How can I get around this?</p>



<a name="203319667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203319667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203319667">(Jul 08 2020 at 20:37)</a>:</h4>
<p>Could you post your code?  (Make sure to put it between <code> ``` </code> marks.)  You might also consider posting it, with code, in the "new members" stream.</p>



<a name="203320130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203320130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203320130">(Jul 08 2020 at 20:40)</a>:</h4>
<p>In my own solution, I did <code>intros y yel</code> first, then I did <code>rcases</code> on <code>yel</code> to split it up.  I'd need to see how you defined the range to be sure, though.</p>



<a name="203325383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203325383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203325383">(Jul 08 2020 at 21:24)</a>:</h4>
<p>I did more or less the same thing as Kyle. I defined <code>A := { y | ∃ x ∈ Icc a b, f x = y }</code> and then to prove <code>A ⊆ Icc c d</code> I first used <code>intros y hy</code> and then <code>rcases hy with ⟨x, x_in, hx⟩</code> One thing to keep in mind is that in Lean, <code>A ⊆ Icc c d</code> is basically synonymous with something like <code>∀ (y : ℝ) (hy : y ∈ A), y ∈ Icc c d</code> That is, an element of a subset should really be thought of as a pair consisting of an element of the set (in this case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>) and a proof that the element is in the subset. So to prove <code>A ⊆ Icc c d</code> you need to give a proof which takes an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> and a proof that that element is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> and produce a proof that the element is also in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[c, d]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>.</p>



<a name="203325694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203325694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203325694">(Jul 08 2020 at 21:26)</a>:</h4>
<p>Also, I second Kyle in saying it could be useful to post your code</p>



<a name="203326040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203326040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203326040">(Jul 08 2020 at 21:29)</a>:</h4>
<p>It might be especially useful to post how you defined the range of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> on the interval</p>



<a name="203331288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203331288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jordan Brown <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203331288">(Jul 08 2020 at 22:25)</a>:</h4>
<p>Hm, this is basically what I was trying to do and it keeps giving me the error "rcases tactic failed: y_in : [anonymous] is not an inductive datatype". The code currently is: </p>
<div class="codehilite"><pre><span></span><code><span class="k">begin</span>
  <span class="k">have</span> <span class="n">alpha</span><span class="o">:={</span><span class="n">x</span><span class="bp">|∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">bdd_above_segment</span> <span class="n">hf</span> <span class="k">with</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">bdd_below_segment</span> <span class="n">hf</span> <span class="k">with</span> <span class="n">c</span> <span class="n">d</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">z</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="err">∈</span> <span class="n">Icc</span> <span class="n">c</span> <span class="n">u</span><span class="o">,</span><span class="n">is_sup</span> <span class="n">alpha</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">g</span><span class="o">:</span> <span class="n">a</span><span class="err">∈</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">⟨</span> <span class="n">le_refl</span> <span class="n">a</span><span class="o">,</span><span class="n">hab</span><span class="bp">⟩</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span><span class="o">:</span> <span class="n">alpha</span> <span class="err">⊆</span> <span class="n">Icc</span> <span class="n">u</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">y_in</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">y_in</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">x_in</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span><span class="o">,</span>


<span class="kn">end</span> <span class="err">&#39;&#39;&#39;</span>
</code></pre></div>



<a name="203332311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203332311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203332311">(Jul 08 2020 at 22:39)</a>:</h4>
<p>that first <code>have</code> should be a <code>let</code>.</p>



<a name="203332340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203332340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203332340">(Jul 08 2020 at 22:39)</a>:</h4>
<p>You used <code>have</code> so Lean instantly forgot the definition of alpha and only remembered its type, like with proofs you remember what it's a proof of, but don't remember what the proof is.</p>



<a name="203333442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203333442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jordan Brown <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203333442">(Jul 08 2020 at 22:51)</a>:</h4>
<p>Ah, that fixed it immediately! I did not realize there was a difference. Thanks!</p>



<a name="203333763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203333763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203333763">(Jul 08 2020 at 22:55)</a>:</h4>
<p>Let for Type, have for Prop</p>



<a name="203334266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Massot%20Exercise%200080/near/203334266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Massot.20Exercise.200080.html#203334266">(Jul 08 2020 at 23:01)</a>:</h4>
<p>Also worth mentioning that <code>set</code> is sometimes useful. It's like <code>let</code> but gives you direct access to a proof that the new variable is equal to the expression used to define it. E.g. <code>let x := f n</code> vs. <code>set x := f n with hx</code>. In the latter, <code>hx</code> is a proof of the proposition <code>x = f n</code> which is useful because otherwise some tactics (like <code>linarith</code>) can't see this fact</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
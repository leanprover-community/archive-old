---
layout: archive
title: Zulip Chat Archive
permalink: /stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/index.html">Berkeley Lean Seminar</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html">Restrict algebra equivalence</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222186358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222186358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222186358">(Jan 09 2021 at 19:51)</a>:</h4>
<p>I was thinking about <code>alg_equiv.restrict_is_splitting_field</code> and it seems to me like the theorem could actually be made more general without much more work (though maybe that's too naive). The current assumption is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">K/E/F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is a tower of field extensions such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the splitting field of some polynomial over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. But shouldn't it be enough to assume that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">E/F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is a normal extension (not necessarily finite dimensional)? The proof is just that if you have an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>-algebra homomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>K</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\varphi : K \to K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> then it restricts to a homomorphism of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> because everything in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the root of some polynomial and must therefore go to a root of the same polynomial which is also in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> by normality.</p>



<a name="222188202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222188202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222188202">(Jan 09 2021 at 20:33)</a>:</h4>
<p>Yeah, I was realizing this. Unfortunately, we don't know that splitting fields are normal (it's a TODO in normal.lean). I was working on this a bit last night and it seems hard</p>



<a name="222199577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222199577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222199577">(Jan 10 2021 at 01:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222188202">said</a>:</p>
<blockquote>
<p>Yeah, I was realizing this. Unfortunately, we don't know that splitting fields are normal (it's a TODO in normal.lean). I was working on this a bit last night and it seems hard</p>
</blockquote>
<p>We only know they're normal if the polynomial is separable right?</p>



<a name="222199595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222199595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222199595">(Jan 10 2021 at 01:39)</a>:</h4>
<p>splitting field -&gt; normal is one of the hardest theorems in a Galois theory course!</p>



<a name="222199781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222199781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222199781">(Jan 10 2021 at 01:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="298851">Patrick Lutz</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222199577">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222188202">said</a>:</p>
<blockquote>
<p>Yeah, I was realizing this. Unfortunately, we don't know that splitting fields are normal (it's a TODO in normal.lean). I was working on this a bit last night and it seems hard</p>
</blockquote>
<p>We only know they're normal if the polynomial is separable right?</p>
</blockquote>
<p>Lean only knows this right now, but I know it in general</p>



<a name="222199841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222199841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222199841">(Jan 10 2021 at 01:46)</a>:</h4>
<p>When I proved it in my course I used some awful proof. Someone told me afterwards that there was a proof by induction on degree in Dummitt and Foote  but I was skeptical that it could be made to work. I went to take a look and found that they were right though.</p>



<a name="222199909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222199909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222199909">(Jan 10 2021 at 01:48)</a>:</h4>
<p>I think I followed the proof in Garling's book (the book I'd learnt the theory from) which is much nastier. It introduces some auxiliary condition which it proves is equivalent to normality and also to splitting field. I seem to have a sketch of <del>the D&amp;F proof</del> my crappy proof:</p>



<a name="222200059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200059">(Jan 10 2021 at 01:53)</a>:</h4>
<p>Say F/E is the splitting field of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f\in E[X]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span>. Now say $$p\in E[X]$ is irreducible and has a root <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\alpha\in F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. We want to show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> splits completely in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. Consider <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>F</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p\in F[X]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span>; it factors into irreducibles. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> be one of them. It suffices to show the degree of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> is 1. It's irreducible, so we can throw in a root <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> and get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\beta)=F[X]/(q)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>. Within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\beta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span> we see that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is a splitting field for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(\alpha)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\beta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span> is a splitting field for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(\beta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span>. But <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(\alpha)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(\beta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span> via an isomorphism sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> (because they're both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E[X]/(p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> and so if you know uniqueness up to (non-unique) isomorphism of splitting fields then you win because this implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>F</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>:</mo><mi>E</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>F</mi><mo>:</mo><mi>E</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[F(\beta):E(\beta)]=[F:E(\alpha)]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">F(\beta)=F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> by a degree count.</p>



<a name="222200103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200103">(Jan 10 2021 at 01:54)</a>:</h4>
<p>Aah, but uniqueness of splitting fields is what takes me ages :-(</p>



<a name="222200167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200167">(Jan 10 2021 at 01:56)</a>:</h4>
<p>Perhaps this is what D&amp;F do better than me. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is a field and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p\in E[X]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> is a poly then TFAE: (1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi mathvariant="normal">/</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">F/E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is a splitting field for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>, (2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> has property (<code>*</code>) for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>E</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(E,p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>. Property (<code>*</code>) is "if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">E\to K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is an extension of fields then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> splits completely in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> iff there's an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>-algebra map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F\to K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>".</p>



<a name="222200177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200177">(Jan 10 2021 at 01:57)</a>:</h4>
<p>I would not recommend this route. I don't remember the D&amp;F proof.</p>



<a name="222200294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200294">(Jan 10 2021 at 02:00)</a>:</h4>
<p>The point is that one finite extension of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, up to isomorphism, has property (<code>*</code>) because of the usual universal property proof; given two, (<code>*</code>) gives you a map between them which must be an iso for degree reasons.</p>



<a name="222200822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200822">(Jan 10 2021 at 02:17)</a>:</h4>
<p><a href="/user_uploads/3121/w1je2uAAkX3Y5m0SBkEYMf_z/df.png">df.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/w1je2uAAkX3Y5m0SBkEYMf_z/df.png" title="df.png"><img src="/user_uploads/3121/w1je2uAAkX3Y5m0SBkEYMf_z/df.png"></a></div>



<a name="222200834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222200834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222200834">(Jan 10 2021 at 02:17)</a>:</h4>
<p>there's the D+F proof and it's less horrible than mine. It gives uniqueness of splitting fields. Do we have that?</p>



<a name="222201215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222201215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222201215">(Jan 10 2021 at 02:29)</a>:</h4>
<p>I think so (we can construct maps in both directions, and look at dimensions)</p>



<a name="222266195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222266195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222266195">(Jan 11 2021 at 07:28)</a>:</h4>
<p>I've been working on splitting field implies normal. I was looking at this pdf: <a href="http://www.pitt.edu/~gmc/algebra/galoistheory.pdf">http://www.pitt.edu/~gmc/algebra/galoistheory.pdf</a></p>
<p>That pdf supposedly deduces Corollary 7.7 from Theorem 7.6. I formalized Theorem 7.6 (statement below, proof is done), but am struggling to see how to deduce "splitting field implies normal"</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">main_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">K</span><span class="o">]</span>
<span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">E</span><span class="o">}</span>
<span class="o">(</span><span class="n">hK</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">splits</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">K</span><span class="o">))</span> <span class="o">:</span>
<span class="n">nonempty</span> <span class="o">((</span><span class="n">adjoin</span> <span class="n">F</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">))</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>



<a name="222266259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222266259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222266259">(Jan 11 2021 at 07:28)</a>:</h4>
<p>I guess, is this lifting result powerful enough to deduce "splitting field implies normal"?</p>



<a name="222267542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222267542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222267542">(Jan 11 2021 at 07:52)</a>:</h4>
<p>Actually, I see a way forward. Assume that E/F is the splitting field of p. Let x be an element of E. Let m be the minimal polynomial of x over F. Let K be the splitting field of m over E (so now we have K/E/F). Let y be a root of m. We can use <code>main_theorem</code> to construct an F(y)-algebra homomorphism E(y) -&gt; E. By dimensions, y is in E.</p>



<a name="222267556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222267556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222267556">(Jan 11 2021 at 07:52)</a>:</h4>
<p>I won't finish this tonight, but it seems very doable.</p>



<a name="222681261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681261">(Jan 14 2021 at 05:23)</a>:</h4>
<p>I was starting to think about <code>alg_equiv.restrict_is_splitting_field_hom_surjective</code> tonight and I think it's missing a hypothesis. Currently it says that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">K/E/F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is a tower of field extensions and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the splitting field of some polynomial and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is finite degree over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> then the restriction map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Aut(K/F) \to Aut(E/F)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span> is surjective. But I think this is only true if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">K/F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is Galois, right? Otherwise you could have a situation where, for example, there is some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> which has a square root in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> but one of its conjugates does not.</p>



<a name="222681329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681329">(Jan 14 2021 at 05:25)</a>:</h4>
<p>I think that you're right</p>



<a name="222681454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681454">(Jan 14 2021 at 05:28)</a>:</h4>
<p>Also, the proof should be pretty similar to the proof that the splitting field of a separable polynomial is Galois. I wonder if we can factor out some common lemmas</p>



<a name="222681477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681477">(Jan 14 2021 at 05:30)</a>:</h4>
<p>Actually, can we just do it by counting?</p>



<a name="222681523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681523">(Jan 14 2021 at 05:30)</a>:</h4>
<p>it would be enough to know that the kernel has size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|Aut(K/F)|/|Aut(E/F)|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">/</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span> right?</p>



<a name="222681530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681530">(Jan 14 2021 at 05:31)</a>:</h4>
<p>which is equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>K</mi><mo>:</mo><mi>F</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">[</mo><mi>E</mi><mo>:</mo><mi>F</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[K : F]/[E : F]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">]</span></span></span></span> if they're both Galois</p>



<a name="222681534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681534">(Jan 14 2021 at 05:31)</a>:</h4>
<p>which is also equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>K</mi><mo>:</mo><mi>E</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[K : E]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">]</span></span></span></span></p>



<a name="222681582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681582">(Jan 14 2021 at 05:32)</a>:</h4>
<p>so we would really just need to know that there are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>K</mi><mo>:</mo><mi>E</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[K : E]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">]</span></span></span></span> automorphisms of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> which fix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>. But we know that already</p>



<a name="222681589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681589">(Jan 14 2021 at 05:32)</a>:</h4>
<p>although this argument would require the extra assumption that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is Galois, not just the splitting field of some polynomial</p>



<a name="222681750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681750">(Jan 14 2021 at 05:37)</a>:</h4>
<p>I feel like surjectivity should follow from some general lemma about lifting automorphisms</p>



<a name="222681874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681874">(Jan 14 2021 at 05:40)</a>:</h4>
<p>I recently proved this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">main_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">K</span><span class="o">]</span>
<span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">E</span><span class="o">}</span>
<span class="o">(</span><span class="n">hK</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">splits</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">K</span><span class="o">))</span> <span class="o">:</span>
<span class="n">nonempty</span> <span class="o">((</span><span class="n">adjoin</span> <span class="n">F</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">))</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>which tells you that an inclusion F -&gt; K lifts to an inclusion F(S) -&gt; K, provided that the minimal polynomial of each element of S splits in K.</p>
<p>Does this imply surjectivity? You want to lift an inclusion E -&gt; K to an inclusion K-&gt;K, so you just need to know that K/E is generated by elements whose minimal polynomial (over E) splits in K</p>



<a name="222681935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222681935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222681935">(Jan 14 2021 at 05:42)</a>:</h4>
<p>so does surjectivity hold as long as K is a splitting field over E? (this would be weaker than saying that K/F is Galois)</p>



<a name="222682120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222682120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222682120">(Jan 14 2021 at 05:47)</a>:</h4>
<p>I'm not sure I follow what you're saying. We need to lift a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi><mo>→</mo><mi>E</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">E/F \to E/F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> to a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi><mo>→</mo><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">K/F \to K/F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. But I don't exactly see how to do that from the theorem you just stated</p>



<a name="222682386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222682386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222682386">(Jan 14 2021 at 05:54)</a>:</h4>
<p>Let me think. So start with an F-algebra homomorphism f : E -&gt; E. This induces an F-algebra homomorphism g : E -&gt; K. Let K' denote K with E-algebra structure given by g. Assume that K=E(S) where each element of S has minimal polynomial over E that splits in K. I think the theorem gives an E-algebra homomorphism E(S) -&gt; K'. This is the same as an F-algebra homomorphism K -&gt; K that extends g.</p>



<a name="222682527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222682527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222682527">(Jan 14 2021 at 05:58)</a>:</h4>
<p>yeah, I guess you're right</p>



<a name="222682547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222682547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222682547">(Jan 14 2021 at 05:59)</a>:</h4>
<p>It feels like having the two different instances of <code>algebra E K</code> floating around might confuse Lean but I guess it should be okay</p>



<a name="222682603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222682603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222682603">(Jan 14 2021 at 06:00)</a>:</h4>
<p>You might need to have some @'s and <code>ring_hom.to_algebra</code>'s floating around</p>



<a name="222682613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222682613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222682613">(Jan 14 2021 at 06:00)</a>:</h4>
<p>like with <code>alg_hom_equiv_sigma</code></p>



<a name="222777612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222777612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222777612">(Jan 14 2021 at 20:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222681874">said</a>:</p>
<blockquote>
<p>I recently proved this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">main_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">K</span><span class="o">]</span>
<span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">E</span><span class="o">}</span>
<span class="o">(</span><span class="n">hK</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">splits</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">K</span><span class="o">))</span> <span class="o">:</span>
<span class="n">nonempty</span> <span class="o">((</span><span class="n">adjoin</span> <span class="n">F</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">))</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>which tells you that an inclusion F -&gt; K lifts to an inclusion F(S) -&gt; K, provided that the minimal polynomial of each element of S splits in K.</p>
<p>Does this imply surjectivity? You want to lift an inclusion E -&gt; K to an inclusion K-&gt;K, so you just need to know that K/E is generated by elements whose minimal polynomial (over E) splits in K</p>
</blockquote>
<p>This theorem could also be used to construct the embedding <code>F(a, b) -&gt; (p * q).splitting_field</code> that we need for the compositum case. But maybe you already realized that.</p>



<a name="222778940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222778940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222778940">(Jan 14 2021 at 20:26)</a>:</h4>
<p>Oh, I didn't realize that</p>



<a name="222805834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222805834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222805834">(Jan 15 2021 at 00:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222681874">said</a>:</p>
<blockquote>
<p>I recently proved this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">main_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">K</span><span class="o">]</span>
<span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">E</span><span class="o">}</span>
<span class="o">(</span><span class="n">hK</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">splits</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">K</span><span class="o">))</span> <span class="o">:</span>
<span class="n">nonempty</span> <span class="o">((</span><span class="n">adjoin</span> <span class="n">F</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">))</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>which tells you that an inclusion F -&gt; K lifts to an inclusion F(S) -&gt; K, provided that the minimal polynomial of each element of S splits in K.</p>
<p>Does this imply surjectivity? You want to lift an inclusion E -&gt; K to an inclusion K-&gt;K, so you just need to know that K/E is generated by elements whose minimal polynomial (over E) splits in K</p>
</blockquote>
<p>Is this anywhere in the abel-ruffini branch right now?</p>



<a name="222805892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222805892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222805892">(Jan 15 2021 at 00:45)</a>:</h4>
<p>Yes, it should be at the bottom of adjoin.lean</p>



<a name="222805902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222805902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222805902">(Jan 15 2021 at 00:45)</a>:</h4>
<p>Right after the induction lemmas</p>



<a name="222806131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222806131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222806131">(Jan 15 2021 at 00:48)</a>:</h4>
<p>It's possible that we'll also want a corollary stating <code>nonempty (E →ₐ[F] K)</code>, assuming that <code>(adjoin F (S : set E)) = top</code></p>



<a name="222806180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222806180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222806180">(Jan 15 2021 at 00:49)</a>:</h4>
<p>I agree. Although the use I mentioned earlier today doesn't require that form</p>



<a name="222809383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222809383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222809383">(Jan 15 2021 at 01:39)</a>:</h4>
<p><span class="user-mention" data-user-id="253861">@Thomas Browning</span> I think the fact that you made <code>field_theory/adjoin.lean</code> import <code>field_theory/normal.lean</code> has created a circular series of dependencies and so I can't get several files to compile</p>



<a name="222809399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222809399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222809399">(Jan 15 2021 at 01:39)</a>:</h4>
<p>I fixed it in a recent commit</p>



<a name="222809410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222809410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222809410">(Jan 15 2021 at 01:39)</a>:</h4>
<p>it should go the other way now</p>



<a name="222809470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222809470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222809470">(Jan 15 2021 at 01:40)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/commit/aed1157e4212fd6a23ede26bce59fd47f184c22a">https://github.com/leanprover-community/mathlib/commit/aed1157e4212fd6a23ede26bce59fd47f184c22a</a></p>



<a name="222809527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222809527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222809527">(Jan 15 2021 at 01:41)</a>:</h4>
<p>Oh, I didn't see that you made more commits. The weird thing is that everything was still compiling fine in <code>abel_ruffini.lean</code> until I closed VS Code and opened it again. And then nothing would compile</p>



<a name="222809611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222809611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222809611">(Jan 15 2021 at 01:42)</a>:</h4>
<p>Yeah, things were weird for me too</p>



<a name="222812637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222812637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222812637">(Jan 15 2021 at 02:27)</a>:</h4>
<p><span class="user-mention" data-user-id="253861">@Thomas Browning</span> I renamed the lemma <code>is_integral</code> to <code>SBR_is_integral</code> for now because it was conflicting with the usual meaning of <code>is_integral</code></p>



<a name="222812718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222812718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222812718">(Jan 15 2021 at 02:29)</a>:</h4>
<p>sure. I guess <code>SBR.is_integral</code> is fine outside the SBR namespace, but this is a problem inside the SBR namespace.</p>



<a name="222813216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222813216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222813216">(Jan 15 2021 at 02:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222812718">said</a>:</p>
<blockquote>
<p>sure. I guess <code>SBR.is_integral</code> is fine outside the SBR namespace, but this is a problem inside the SBR namespace.</p>
</blockquote>
<p>yeah, that's the problem I was running into</p>



<a name="222813237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222813237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222813237">(Jan 15 2021 at 02:37)</a>:</h4>
<p>I'm fine renaming it anything I just want to make sure we can also use the normal <code>is_integral</code> inside the <code>SBR</code> namespace</p>



<a name="222957969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley%20Lean%20Seminar/topic/Restrict%20algebra%20equivalence/near/222957969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/240192-Berkeley-Lean-Seminar/topic/Restrict.20algebra.20equivalence.html#222957969">(Jan 16 2021 at 04:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Restrict.20algebra.20equivalence/near/222199595">said</a>:</p>
<blockquote>
<p>splitting field -&gt; normal is one of the hardest theorems in a Galois theory course!</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/issues/5768">#5768</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
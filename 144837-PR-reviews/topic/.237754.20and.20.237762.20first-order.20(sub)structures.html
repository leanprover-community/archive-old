---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html">#7754 and #7762 first-order (sub)structures</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240784069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/240784069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#240784069">(May 31 2021 at 01:56)</a>:</h4>
<p>I've started defining some model theory concepts. These are interesting enough from the perspective of, say, Flypitch-type logic results, but I hope that these can be used to fix some big API repetition problems.</p>



<a name="240784089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/240784089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#240784089">(May 31 2021 at 01:57)</a>:</h4>
<p>In particular, <a href="https://github.com/leanprover-community/mathlib/issues/7762">#7762</a> defines a notion of substructure that could potentially be used to unify <code>submonoid</code>, <code>subgroup</code>, <code>submodule</code>, <code>subring</code>, <code>sublattice</code>, and nearly <code>sub</code>-anything.</p>



<a name="240784165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/240784165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#240784165">(May 31 2021 at 01:59)</a>:</h4>
<p>Now, I know that we won't JUST be able to use that API to define all these other notions, because for instance, the basic closure properties (things like <code>one_mem</code> and <code>mul_mem</code>) will be in an impenetrable form until they're translated from general model theory.</p>



<a name="240784171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/240784171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#240784171">(May 31 2021 at 01:59)</a>:</h4>
<p>I'm starting this thread because I'd like to hear any thoughts on the feasibility of (eventually) defining these other notions of substructure using this general concept.</p>



<a name="241425619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241425619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241425619">(Jun 03 2021 at 17:36)</a>:</h4>
<p>I have a more concrete issue:<br>
What should the notation be for first-order homs, embeddings, and equivs?</p>



<a name="241425884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241425884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241425884">(Jun 03 2021 at 17:38)</a>:</h4>
<p>Right now I just have <code>M →[L] N</code>, but as <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> has pointed out, this is taken by <code>mul_action_hom</code>. How should I adorn this to make it different?</p>



<a name="241426062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241426062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241426062">(Jun 03 2021 at 17:40)</a>:</h4>
<p>Later, I'll want to talk about elementary embeddings and such, and that could be <code>M ↪e[L] N</code> if that's not taken, but for now, should I just go with <code>M →fo[L] N</code> or something?</p>



<a name="241427310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241427310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241427310">(Jun 03 2021 at 17:46)</a>:</h4>
<p>Is subscript <code>s</code> taken? (<code>s</code> for structure)</p>



<a name="241429088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241429088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241429088">(Jun 03 2021 at 17:59)</a>:</h4>
<p>Or maybe a locale?</p>



<a name="241431275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241431275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241431275">(Jun 03 2021 at 18:17)</a>:</h4>
<p>I think a locale would be committing to never wanting to use this notation when importing files on <code>mul_action</code>s, which is probably not going to work</p>



<a name="241431770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241431770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241431770">(Jun 03 2021 at 18:20)</a>:</h4>
<p>(Once we have different notation, it might still be wise to put it in a locale to avoid future conflicts)</p>



<a name="241443699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241443699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241443699">(Jun 03 2021 at 19:53)</a>:</h4>
<p>I think mul_action_hom is used very rarely</p>



<a name="241450042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241450042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241450042">(Jun 03 2021 at 20:45)</a>:</h4>
<p>So would you put <code>mul_action_hom</code> in a locale as well? I think it will be used more if representation theory gets going, but at that point it will probably be under different notation anyway.</p>



<a name="241450435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241450435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241450435">(Jun 03 2021 at 20:47)</a>:</h4>
<p>I guess that would be one option, yes</p>



<a name="241450560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241450560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241450560">(Jun 03 2021 at 20:48)</a>:</h4>
<p>Another option would be a <code>has_indexed_arrow</code> typeclass to let the notation be shared.</p>



<a name="241451763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241451763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241451763">(Jun 03 2021 at 20:55)</a>:</h4>
<p>With <code>has_indexed_arrow A B (Type u)</code> providing <code>mul_action_hom</code> and <code>has_indexed_arrow A B language</code> providing your hom</p>



<a name="241471648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241471648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241471648">(Jun 04 2021 at 00:00)</a>:</h4>
<p>If this could be made to work it would be pretty nice. Notice that I also use this (although with the "category theory arrow") for enriched categories as well.</p>



<a name="241489587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/241489587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#241489587">(Jun 04 2021 at 04:17)</a>:</h4>
<p>For now I've localized it but not yet changed the notation itself - I'm not sure that fixes the issue yet, but localization is good.</p>



<a name="242007727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242007727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242007727">(Jun 09 2021 at 01:20)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7752">#7752</a> is on the merge queue, but while looking at one of <span class="user-mention" data-user-id="310045">@Eric Wieser</span> 's PRs, I got an idea for another approach, involving a general definition of <code>n</code>-ary functions, which I have started working on at <a href="https://github.com/leanprover-community/mathlib/tree/fo_arity">branch#fo_arity</a></p>



<a name="242008000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008000">(Jun 09 2021 at 01:24)</a>:</h4>
<p>Basically, when I talk about an <code>n</code>-ary function or relation, I can talk about it in a curried or uncurried way. In <a href="https://github.com/leanprover-community/mathlib/issues/7752">#7752</a>, everything is fully uncurried, a function on tuples, interpreted as <code>fin n -&gt; M</code>. However, most of mathlib uses fully curried functions, so I've created a type <code>ary_fun A B n</code> of <code>n + 1</code>-ary functions from <code>A</code> to <code>B</code>.</p>



<a name="242008153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008153">(Jun 09 2021 at 01:27)</a>:</h4>
<p>The <code>n + 1</code> is kind of unfortunate and requires me to work with constants separately, but it's inevitable if one wants to generalize the <code>arity</code> type in <code>set_theory/zfc.lean</code> to have a codomain that could live in a different universe than the domain, which is particularly useful if we want it to be <code>Prop</code>.</p>



<a name="242008326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008326">(Jun 09 2021 at 01:29)</a>:</h4>
<p>The other complication is that highly general <code>simp</code> lemmas seem to work less well for these curried versions, as for the uncurried version, there is just one input, so we can just say <code>ext</code> once and then use regular <code>simp</code> lemmas for functions. In particular, for the curried versions, I have to actually give a proof that the composition of two embeddings is an embedding, instead of relying heavily on <code>. obviously</code>.</p>



<a name="242008332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008332">(Jun 09 2021 at 01:29)</a>:</h4>
<p>There is one issue with this approach using your <code>ary_fun</code> in that you can't define inductive types built using this.</p>



<a name="242008382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008382">(Jun 09 2021 at 01:30)</a>:</h4>
<p>What do you mean?</p>



<a name="242008401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008401">(Jun 09 2021 at 01:30)</a>:</h4>
<p>1 sec i'll sketch an example</p>



<a name="242008581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008581">(Jun 09 2021 at 01:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ary_fun</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ary_fun</span> <span class="n">n</span>

<span class="c1">-- This works</span>
<span class="kd">inductive</span> <span class="n">foo0</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">foo0</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">foo0</span><span class="o">)</span> <span class="bp">→</span> <span class="n">foo0</span>

<span class="c1">-- This doesn't work</span>
<span class="kd">inductive</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">foo1</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="n">ary_fun</span> <span class="n">foo1</span> <span class="mi">2</span>
</code></pre></div>



<a name="242008604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008604">(Jun 09 2021 at 01:33)</a>:</h4>
<p>If you want to define the free monoid, say, inductively, this approach would pose an issue</p>



<a name="242008667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008667">(Jun 09 2021 at 01:34)</a>:</h4>
<p>err wait sorry let me fix this example</p>



<a name="242008717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008717">(Jun 09 2021 at 01:35)</a>:</h4>
<p>If there's a really foundational problem with using <code>ary_fun</code> to define first-order structures, it's probably still useful as a way to translate to the various curried functions in the library.</p>



<a name="242008840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008840">(Jun 09 2021 at 01:37)</a>:</h4>
<p>Ok, now the example is what I had in mind.</p>



<a name="242008893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008893">(Jun 09 2021 at 01:38)</a>:</h4>
<p>There is no way to freely (i.e.. inductively) create an n-ary function using this approach</p>



<a name="242008912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008912">(Jun 09 2021 at 01:38)</a>:</h4>
<p>But looking at your example, I doubt this will be a foundational problem,as I think I can still use <code>foo0</code> to define a free monoid and then put the correct <code>L.Structure</code> on it.</p>



<a name="242008926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008926">(Jun 09 2021 at 01:39)</a>:</h4>
<p>Oh sure, but you will need to go back-and-forth using the equivalence between the curried and uncurried approaches</p>



<a name="242008933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008933">(Jun 09 2021 at 01:39)</a>:</h4>
<p>(Also, your <code>ary_fun</code> matches <code>arity</code> from <code>set_theory/zfc.lean</code>, and doesn't have my annoying off-by-one</p>



<a name="242008955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242008955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242008955">(Jun 09 2021 at 01:39)</a>:</h4>
<p>So all this is background material, my real question is: do people have strong opinions on when I use the curried vs. uncurried approach?</p>



<a name="242009027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242009027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242009027">(Jun 09 2021 at 01:40)</a>:</h4>
<p>I'm thinking that a structure should be defined as a widget with constants, curried <code>ary_fun</code>s and curried <code>ary_rel</code>s, so that when I say how, say, the symbol <code>add</code> should be interpreted, I can just say <code>(+)</code></p>



<a name="242009038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242009038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242009038">(Jun 09 2021 at 01:41)</a>:</h4>
<p>But perhaps I should uncurry for the definition of <code>embedding</code>s</p>



<a name="242009059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242009059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242009059">(Jun 09 2021 at 01:41)</a>:</h4>
<p>And for abstract free objects down the line</p>



<a name="242009120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242009120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242009120">(Jun 09 2021 at 01:42)</a>:</h4>
<p>I guess the question is what is the intended applications of this work? If it's for model theory, then I'm inclined to stick with <code>fin n \to X</code> since it seems to me this would make it easier to work with (and even define) definable sets.</p>



<a name="242010143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242010143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242010143">(Jun 09 2021 at 02:01)</a>:</h4>
<p>For definable sets, I’ve got ideas that could work either way.</p>



<a name="242010214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242010214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242010214">(Jun 09 2021 at 02:02)</a>:</h4>
<p>I have ambitions that this could work outside model theory per se, and for instance unify the <code>substructure</code> libraries.</p>



<a name="242392885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237754%20and%20%237762%20first-order%20%28sub%29structures/near/242392885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237754.20and.20.237762.20first-order.20(sub)structures.html#242392885">(Jun 11 2021 at 19:33)</a>:</h4>
<p>I would be inclined not to steer too far away from the direction of infinitary logic. <code>ary_fun</code> seems problematic from that perspective.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
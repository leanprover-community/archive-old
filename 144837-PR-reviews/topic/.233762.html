---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.233762.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html">#3762</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206889657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206889657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206889657">(Aug 14 2020 at 01:18)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span>, does my question about proving</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Monad</span> <span class="n">C</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">((</span><span class="n">Monad_Mon_equiv</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">unit_iso</span><span class="bp">.</span><span class="n">app</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span><span class="bp">.</span><span class="n">app</span> <span class="n">X</span> <span class="bp">=</span> <span class="mi">ùüô</span> <span class="o">(</span><span class="n">A</span><span class="bp">.</span><span class="n">func</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>


<p>make sense? (I'm hoping I'm not being dumb, and that is the correct right hand side.)</p>



<a name="206889674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206889674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206889674">(Aug 14 2020 at 01:19)</a>:</h4>
<p>My suspicion is that you have been "evil" enough in your proofs that not only does this not work by <code>rfl</code>, but that it's going to be painful to prove at all.</p>



<a name="206889684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206889684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206889684">(Aug 14 2020 at 01:19)</a>:</h4>
<p>And the solution is to not use <code>functor.ext</code> and related machinery.</p>



<a name="206890479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206890479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206890479">(Aug 14 2020 at 01:35)</a>:</h4>
<p>Yes it makes sense. I'll try to see if your suggestion of using nat_iso.of_components works.</p>



<a name="206890563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206890563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206890563">(Aug 14 2020 at 01:37)</a>:</h4>
<p>Yeah, the stupid eq_to_hom lemmas I added we're because of the use of functor.ext.</p>



<a name="206890820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206890820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206890820">(Aug 14 2020 at 01:42)</a>:</h4>
<p>Is there any other reasonable way to prove equality of functors?</p>



<a name="206890836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206890836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206890836">(Aug 14 2020 at 01:43)</a>:</h4>
<p>I suspect the answer is "never prove equality of functors"</p>



<a name="206890990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206890990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206890990">(Aug 14 2020 at 01:46)</a>:</h4>
<p>I went through several rounds of trying to make use of equalities of functors, but in every case <code>eq.rec</code> eventually came back to bite me.</p>



<a name="206891103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206891103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206891103">(Aug 14 2020 at 01:48)</a>:</h4>
<p>I see. To be honest, I also found these proofs surprisingly painful. Probably for similar reasons.</p>



<a name="206892787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206892787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206892787">(Aug 14 2020 at 02:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I tried this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">Monad_Mon_equiv</span> <span class="o">:</span> <span class="o">(</span><span class="n">Monad</span> <span class="n">C</span><span class="o">)</span> <span class="err">‚âå</span> <span class="o">(</span><span class="n">Mon_</span> <span class="o">(</span><span class="n">C</span> <span class="err">‚•§</span> <span class="n">C</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">functor</span> <span class="o">:=</span> <span class="n">Monad_to_Mon</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">inverse</span> <span class="o">:=</span> <span class="n">Mon_to_Monad</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">unit_iso</span> <span class="o">:=</span> <span class="n">nat_iso</span><span class="bp">.</span><span class="n">of_components</span>
    <span class="o">(</span><span class="bp">Œª</span> <span class="n">X</span><span class="o">,</span> <span class="n">eq_to_iso</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply</span> <span class="n">to_of_mon_end_obj</span><span class="o">)))</span>
    <span class="k">begin</span>
      <span class="n">intros</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">ext</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">functor</span><span class="bp">.</span><span class="n">id_map</span><span class="o">,</span> <span class="n">functor</span><span class="bp">.</span><span class="n">comp_map</span><span class="o">,</span> <span class="n">comp_to_nat_trans</span><span class="o">,</span> <span class="n">eq_to_iso</span><span class="bp">.</span><span class="n">hom</span><span class="o">,</span>
        <span class="n">nat_trans</span><span class="bp">.</span><span class="n">vcomp_eq_comp</span><span class="o">,</span> <span class="n">nat_trans</span><span class="bp">.</span><span class="n">comp_app</span><span class="o">,</span> <span class="n">Monad</span><span class="bp">.</span><span class="n">to_nat_trans_eq_to_hom</span><span class="o">,</span>
        <span class="n">nat_trans</span><span class="bp">.</span><span class="n">id_app</span><span class="o">,</span> <span class="n">id_comp</span><span class="o">,</span> <span class="n">eq_to_hom_refl</span><span class="o">,</span> <span class="n">comp_id</span><span class="o">],</span>
      <span class="n">refl</span><span class="o">,</span>
    <span class="kn">end</span><span class="o">,</span>
  <span class="n">counit_iso</span> <span class="o">:=</span> <span class="n">nat_iso</span><span class="bp">.</span><span class="n">of_components</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">X</span><span class="o">,</span> <span class="n">eq_to_iso</span> <span class="err">$</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">of_to_mon_end_obj</span><span class="o">)</span>
    <span class="k">begin</span>
      <span class="n">intros</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">ext</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Mon_</span><span class="bp">.</span><span class="n">hom_eq_to_hom</span><span class="o">,</span> <span class="n">functor</span><span class="bp">.</span><span class="n">id_map</span><span class="o">,</span> <span class="n">functor</span><span class="bp">.</span><span class="n">comp_map</span><span class="o">,</span> <span class="n">Mon_</span><span class="bp">.</span><span class="n">comp_hom&#39;</span><span class="o">,</span> <span class="n">id_comp</span><span class="o">,</span>
        <span class="n">eq_to_hom_refl</span><span class="o">,</span> <span class="n">eq_to_iso</span><span class="bp">.</span><span class="n">hom</span><span class="o">,</span> <span class="n">comp_id</span><span class="o">],</span>
      <span class="n">refl</span><span class="o">,</span>
    <span class="kn">end</span> <span class="o">}</span>
</code></pre></div>


<p>But it seems essentially equivalent to what's already there, and the example you mentioned still doesn't work.</p>



<a name="206892796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206892796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206892796">(Aug 14 2020 at 02:25)</a>:</h4>
<p>Any suggestions?</p>



<a name="206894999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206894999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206894999">(Aug 14 2020 at 03:23)</a>:</h4>
<p>(deleted)</p>



<a name="206895449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206895449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206895449">(Aug 14 2020 at 03:34)</a>:</h4>
<p>I'm now thinking the way around this is to define the unit/counit_iso without every touching eq_to_hom/eq_to_iso</p>



<a name="206896712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206896712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206896712">(Aug 14 2020 at 04:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  I got it to work! (I just constructed the isomorphisms between the functors directly.)</p>
<p>See: <a href="https://github.com/leanprover-community/mathlib/blob/b9111c09ced26e65e8ccca4214e34f689d86a708/src/category_theory/monad/equiv_mon.lean#L230">https://github.com/leanprover-community/mathlib/blob/b9111c09ced26e65e8ccca4214e34f689d86a708/src/category_theory/monad/equiv_mon.lean#L230</a></p>



<a name="206896850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206896850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206896850">(Aug 14 2020 at 04:17)</a>:</h4>
<p>Now the question is: Should I keep the isomorphism between the categories <code>Monad_Mon_iso</code>?<br>
This uses <code>to_nat_trans_eq_to_hom</code> and <code>Mon_.hom_eq_to_hom</code>. I don't see how to avoid this (or some variant, e.g. I can just introduce these claims in the middle of a tactic block using <code>have : ...</code>).</p>



<a name="206897280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206897280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206897280">(Aug 14 2020 at 04:28)</a>:</h4>
<p>For much the same reason as we had trouble with the equiv, I'm not sure that the isomorphism is actually useful.</p>



<a name="206897353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206897353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206897353">(Aug 14 2020 at 04:31)</a>:</h4>
<p>I agree. I added a note in the docstring at the top of the file. do you think I should just delete the iso?</p>



<a name="206897433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233762/near/206897433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233762.html#206897433">(Aug 14 2020 at 04:33)</a>:</h4>
<p>Ok. I'll do that tomorrow (it's late)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
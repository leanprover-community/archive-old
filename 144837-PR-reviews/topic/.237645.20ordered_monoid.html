---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html">#7645 ordered_monoid</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240326841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240326841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240326841">(May 26 2021 at 13:46)</a>:</h4>
<p>Dear All,</p>
<p>the second <code>ordered</code> refactor PR just finished building successfully.  I would like to add a couple of extra lemmas about monotonicity.  However, before pushing them and getting CI to work on the PR for a <em>long</em> time, I would like to get an opinion.</p>
<p>Several existing lemmas are now simple applications of new lemmas.  As such, I would prefer to eliminate them, rather than keeping them floating around.  Is there some reason to maintain the old names?  Note that in all(?) cases, I have changed their statements to the more general setting.  Notable exceptions are the <code>norm_num</code> and <code>linarith</code> lemmas: these have scrupulously been preserved.</p>
<p>If you simply want to have a clickable link, the "redundant lemmas"  start <a href="https://github.com/leanprover-community/mathlib/blob/395f4e2b240143f5c8896f2e8c8ffbaf6ab371fe/src/algebra/ordered_group.lean#L360">here</a>.</p>
<p>Thanks!</p>



<a name="240327505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240327505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240327505">(May 26 2021 at 13:51)</a>:</h4>
<p>You're asking about whether we should have <code>P -&gt; Q</code> if we already have <code>P &lt;-&gt; Q</code>? I would say that in many cases it is useful to also have the one way functions.</p>



<a name="240327668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240327668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240327668">(May 26 2021 at 13:52)</a>:</h4>
<p>Ok, this does answer almost, if not all, the redundancies.  I may go for <code>alias</code>ing the ones that are of this form.  Thanks, Kevin!</p>



<a name="240327800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240327800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240327800">(May 26 2021 at 13:53)</a>:</h4>
<p>I will also try to make sure that the one-way functions cannot be proven with weaker assumptions, but I may miss out on some of them.</p>



<a name="240327813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240327813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240327813">(May 26 2021 at 13:53)</a>:</h4>
<p>If you're trying to write slick term-mode proofs then the one-way functions are handy, and this is pretty low-level stuff so one could imagine the Marios of this world wanting to be golfy and not having to write <code>(foo_equiv _ _).1</code>everywhere</p>



<a name="240328975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240328975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240328975">(May 26 2021 at 14:01)</a>:</h4>
<p>I also agree that it's good to keep them, but only stated in aliased form right after the iff statement. Like in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">sub_nonneg</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">sub_self</span> <span class="n">a</span><span class="o">,</span> <span class="n">sub_le_sub_iff_left</span><span class="o">]</span>

<span class="n">alias</span> <span class="n">sub_nonneg</span> <span class="bp">↔</span> <span class="n">le_of_sub_nonneg</span> <span class="n">sub_nonneg_of_le</span>
</code></pre></div>
<p>Note that if you only want to alias one of the two directions you can use an underscore, as in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">alias</span> <span class="n">sub_le_self_iff</span> <span class="bp">↔</span> <span class="n">_</span> <span class="n">sub_le_self</span>
</code></pre></div>
<p>(I'm sure you've already seen these tricks since you're working on these files, but they may be useful to other people too)</p>



<a name="240329181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240329181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240329181">(May 26 2021 at 14:03)</a>:</h4>
<p>Aah yes, I learnt this trick earlier this week when someone was asking about what <code>alias</code> did!</p>



<a name="240329192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240329192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240329192">(May 26 2021 at 14:03)</a>:</h4>
<p>Ok, thank you both for your comments!  Sébastien, I had seen the <code>alias</code> stuff <em>in situ</em>, but it is nice to see that what I had deduced is actually correct!</p>



<a name="240423176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240423176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240423176">(May 27 2021 at 05:54)</a>:</h4>
<p>Dear All,</p>
<p>I think that PR <a href="https://github.com/leanprover-community/mathlib/issues/7645">#7645</a> is now ready for review!  Here is a summary of the major changes.</p>
<ul>
<li>I split the <code>co(ntra)variant</code> stuff in a separate file called <code>algebra/covariant_and_contravariant.lean</code>: these are general facts, mostly not specific to orders or multiplication.</li>
<li>The file called <code>algebra/ordered_monoid_lemmas.lean</code> contains no <code>monoid</code>!  Most of the multiplication assumptions are <code>has_mul</code> or <code>mul_one_class</code>.</li>
<li>The file called <code>algebra/ordered_group.lean</code> now uses <code>co(ntra)variants</code> up until roughly half its length.</li>
</ul>
<p>I may continue to convert <code>ordered_group</code>, but the PR is already quite long as is and was planning to leave this for a new PR.</p>
<p>Any comments?</p>
<p>Thank you very much!</p>



<a name="240570679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240570679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240570679">(May 28 2021 at 07:37)</a>:</h4>
<p>Dear All (especially Sébastien!),</p>
<p>I am thinking of adding the code below to <code>algebra/group/defs.lean</code>, but I am wary of stepping into quicksand.</p>
<p>Does it seems reasonable?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">algebra.ordered_monoid_lemmas</span>  <span class="c1">--this import is for the second snippet: it will be in a separate file.</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">section</span> <span class="n">npow</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_rec_zero</span> <span class="o">:</span> <span class="o">(</span><span class="n">npow_rec</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_rec_zero_apply</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">npow_rec</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_rec_succ_apply</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">npow_rec</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">end</span> <span class="n">npow</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_rec_one</span> <span class="o">[</span><span class="n">mul_one_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">npow_rec</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">mul_one</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_eq_npow_rec</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">npow</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">x</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="o">(</span><span class="n">monoid.npow_zero'</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">npow_rec_zero_apply</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">calc</span>
      <span class="n">npow</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">npow</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:</span> <span class="n">monoid.npow_succ'</span> <span class="n">_</span> <span class="n">_</span>
                <span class="bp">...</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">has_mul.mul</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">npow_eq_npow_rec</span> <span class="n">_</span><span class="o">)</span>
                <span class="bp">...</span> <span class="bp">=</span> <span class="n">npow_rec</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">npow_rec_succ_apply</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_eq_nrec</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">npow</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="n">npow_rec</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">npow_eq_npow_rec</span> <span class="n">x</span> <span class="n">n</span><span class="o">))</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_eq_nrec_apply</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">npow</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">npow_eq_nrec</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">npow_rec_mono</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">monotone</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="o">:=</span> <span class="bp">@</span><span class="n">monotone_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="k">calc</span>
      <span class="n">a</span> <span class="bp">*</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">b</span> <span class="o">:</span> <span class="n">mul_le_mul_left'</span> <span class="o">(</span><span class="n">npow_rec_mono</span> <span class="n">n</span> <span class="n">ab</span><span class="o">)</span> <span class="n">a</span>
                   <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">b</span> <span class="o">:</span> <span class="n">mul_le_mul_right'</span> <span class="n">ab</span> <span class="o">(</span><span class="n">npow_rec</span> <span class="n">n</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>The reason for adding this is so that I can prove monotonicity of powers with very few assumptions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">npow_mono</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span>
  <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">monotone</span> <span class="o">(</span><span class="n">npow</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="k">calc</span>
  <span class="n">npow</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">a</span> <span class="o">:</span> <span class="n">npow_eq_nrec_apply</span>
       <span class="bp">...</span> <span class="bp">≤</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">b</span> <span class="o">:</span> <span class="n">npow_rec_mono</span> <span class="n">n</span> <span class="n">ab</span>
       <span class="bp">...</span> <span class="bp">=</span> <span class="n">npow</span> <span class="n">n</span> <span class="n">b</span>     <span class="o">:</span> <span class="n">npow_eq_nrec_apply.symm</span>
</code></pre></div>



<a name="240578241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240578241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240578241">(May 28 2021 at 09:03)</a>:</h4>
<p>I'm not really convinced that you need to do this in terms of <code>npow_rec</code>: as <code>npow</code> and <code>npow_rec</code> satisfy the same equations, all your proofs on <code>npow_rec</code> can be given directly on <code>npow</code>, right? I mean, you can give a direct proof of <code>npow_mono</code> without mentioning <code>npow_rec</code> at all.</p>



<a name="240578397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240578397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240578397">(May 28 2021 at 09:04)</a>:</h4>
<p>You are probably right: I was simply scared of using <code>npow</code> directly, since I understood that there were issues related to it, but was not really sure to what extent!  I will try!</p>



<a name="240769355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240769355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240769355">(May 30 2021 at 19:05)</a>:</h4>
<p>Dear All,</p>
<p>I noticed that <code>monotone</code> assumes <code>preorder</code>, while <code>strict_mono</code> only assumes <code>has_lt</code>.  Thus, I thought of changing <code>monotone</code> to use <code>has_le</code> and almost everything works.  Except:</p>
<ul>
<li>there were 2 cases where I had to replace a term with <code>(by exact [same term])</code>;</li>
<li>one of the tests for <code>apply_fun</code> no longer works.</li>
</ul>
<p>The test does not work, I believe, since now the <code>monotone</code> assumption does not get picked up by... something.  The proof of the test gets fixed by adding an extra <code>apply order_embedding.monotone</code> after the exact.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- broken test in test/apply_fun.lean</span>
<span class="c1">-- Verify that `apply_fun` works with `fin.cast_succ`, even though it has an implicit argument.</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a.cast_succ</span> <span class="bp">≤</span> <span class="n">b.cast_succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply_fun</span> <span class="n">fin.cast_succ</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- up to here was enough before the change preorder --&gt; has_le</span>
  <span class="n">apply</span> <span class="n">order_embedding.monotone</span><span class="o">,</span> <span class="c1">-- this is now needed.</span>
<span class="kd">end</span>
</code></pre></div>
<p>I am happy to roll back to having <code>monotone</code> and <code>strict_mono</code> to have asymmetric assumptions, but I wonder why this is needed.</p>
<p>Thanks!</p>



<a name="240782082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240782082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240782082">(May 31 2021 at 00:54)</a>:</h4>
<p>I don't see any failing tests in <code>test/apply_fun.lean</code> on that branch. Can you ping me when there are compiled oleans showing the failure?</p>



<a name="240788791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240788791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240788791">(May 31 2021 at 03:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> , the error was on commit</p>
<p>222c99df8fc74411782feb9a47465437578b6e2c</p>
<p>but I reverted it afterwards, to make sure that new stuff worked.</p>
<p>Is this enough information?  That commit fails the test.</p>



<a name="240788846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240788846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240788846">(May 31 2021 at 03:58)</a>:</h4>
<p>The later commits introduce a few more generalisations, but undo the <code>preorder --&gt; has_le</code> change and the tests (as well as everything else) work again.</p>



<a name="240794677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240794677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240794677">(May 31 2021 at 05:54)</a>:</h4>
<p>Btw, regardless of the preorder/has_le issue, I think that this has been a further positive test for <code>apply_fun</code>, since it produced an extra goal.  That is, if I understood the purpose of the test!</p>



<a name="240971710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/240971710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#240971710">(Jun 01 2021 at 16:56)</a>:</h4>
<p>Dear All,</p>
<p>I realize that this PR is <em>huge</em> and that reviewing it is not pleasant!  What can I do to make the process easier for whoever would like to spend some time with it?</p>
<p>Really, the basic strategy is very simple: extract a couple of properties that were already present, make them stand-alone and only assume then when needed, instead of always "by default".</p>
<p>If someone is willing to review it, let me know if you want more details!</p>
<p>Thanks a lot!</p>



<a name="241139789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241139789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241139789">(Jun 02 2021 at 12:15)</a>:</h4>
<p>Dear All,</p>
<p>this is the PR that always gives something back.  I decided to merge master into this PR, since it has been sitting there for some time and now I have some merge conflicts.  So far, so good.</p>
<p>Except that the merge conflicts appear to be approximately 200 lines of <code>data/nat/basic</code> having to do with <code>pow</code> that are no longer in <code>master</code> but are on my branch.</p>
<p>Have these lemmas moved somewhere else?  I cannot find them, although there is some comment to the extent that these lemmas could be duplicated by similar lemmas for <code>canonically_ordered_something</code>.</p>
<p>What should I do, simply remove them?</p>
<p>Thanks!</p>



<a name="241139933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241139933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241139933">(Jun 02 2021 at 12:17)</a>:</h4>
<p>This is how the merge conflict starts:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm">! ### `pow` -/</span>

<span class="c1">-- This is redundant with `canonically_ordered_semiring.pow_le_pow_of_le_left`,</span>
<span class="c1">-- but `canonically_ordered_semiring` is not such an obvious abstraction, and also quite long.</span>
<span class="c1">-- So, we leave a version in the `nat` namespace as well.</span>
<span class="c1">-- (The global `pow_le_pow_of_le_left` needs an extra hypothesis `0 ≤ x`.)</span>
<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">pow_le_pow_of_le_left</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="n">i</span> <span class="bp">≤</span> <span class="n">y</span><span class="bp">^</span><span class="n">i</span> <span class="o">:=</span>
<span class="n">canonically_ordered_semiring.pow_le_pow_of_le_left</span> <span class="n">H</span>

<span class="kd">theorem</span> <span class="n">pow_le_pow_of_le_right</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">j</span><span class="o">},</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">^</span><span class="n">i</span> <span class="bp">≤</span> <span class="n">x</span><span class="bp">^</span><span class="n">j</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="n">h</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">eq_zero_of_le_zero</span> <span class="n">h</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">le_refl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">j</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h.lt_or_eq_dec.elim</span>
  <span class="o">(</span><span class="bp">λ</span><span class="n">hl</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ'</span><span class="o">,</span> <span class="bp">←</span> <span class="n">nat.mul_one</span> <span class="o">(</span><span class="n">x</span><span class="bp">^</span><span class="n">i</span><span class="o">)]</span><span class="bp">;</span> <span class="n">exact</span>
    <span class="n">nat.mul_le_mul</span> <span class="o">(</span><span class="n">pow_le_pow_of_le_right</span> <span class="bp">$</span> <span class="n">le_of_lt_succ</span> <span class="n">hl</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span><span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">e</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span>
<span class="c1">-- and so on for ~200 lines</span>
</code></pre></div>



<a name="241140619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241140619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241140619">(Jun 02 2021 at 12:24)</a>:</h4>
<p>They were moved: <a href="https://github.com/leanprover-community/mathlib/issues/7758">#7758</a></p>



<a name="241140743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241140743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241140743">(Jun 02 2021 at 12:25)</a>:</h4>
<p>Great, thank you very much, Gabriel!  I will therefore remove them from the version of <code>data/nat/basic</code> in this PR!</p>



<a name="241142626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241142626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241142626">(Jun 02 2021 at 12:43)</a>:</h4>
<p>Just merge master into your branch?</p>



<a name="241143210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241143210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241143210">(Jun 02 2021 at 12:48)</a>:</h4>
<p>That's what I thought I did, but on my local version the new file (<code>data/nat/pow</code>) was not there and the lines were in <code>data/nat/basic</code>.  Anyway, I think that even though my local copy was messed up, the one on GitHub was correct and seems to be happily building mathlib!</p>



<a name="241147998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241147998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241147998">(Jun 02 2021 at 13:26)</a>:</h4>
<p>Sorry about this; I've been trying to straighten out some of the spiderweb of dependencies from <code>data</code> into other places, so I have quite a few "moving things around" PRs in the works at the moment. It's going to cause some conflicts. :-(</p>



<a name="241148121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241148121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241148121">(Jun 02 2021 at 13:27)</a>:</h4>
<p>Scott, no worries!  I have had to re-touch so many files for this PR that this was not a big deal at all!  I simply wanted to make sure that, by erasing these lemmas from that file, they would not be lost elsewhere!</p>



<a name="241150174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241150174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241150174">(Jun 02 2021 at 13:42)</a>:</h4>
<p>Damiano you shouldn't be erasing things manually, just update master and merge it into your branch.</p>



<a name="241150339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241150339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241150339">(Jun 02 2021 at 13:43)</a>:</h4>
<p>If you erase things manually then you'll create another commit which might conflict with the already-in-master commit.</p>



<a name="241151253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241151253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241151253">(Jun 02 2021 at 13:49)</a>:</h4>
<p>Git still confuses me, so I am probably wrong, but the commit that caused the merge conflict was the merging of master.  (It has the automatic message <code>Merge branch 'master' into adomani_ordered_stuff</code>.)</p>
<p>I certainly had <em>intended</em> to merge master into my branch and I thought that I had done it successfully, not receiving any merge conflict on my machine, but then, on mathlib,  there were some extra lemmas in one file.</p>
<p>I admit that I do not know what was going on, but it seems that the current version has achieved what I was hoping that it would!</p>



<a name="241151543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241151543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241151543">(Jun 02 2021 at 13:51)</a>:</h4>
<p>Is it possible you had not pulled the latest master from origin before you merged master locally?</p>



<a name="241152213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241152213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241152213">(Jun 02 2021 at 13:56)</a>:</h4>
<p>It is certainly possible, although my memory is that I switched to master, typed leanproject up, then switched back to my branch and merged master.  Whether my memory actually agrees with the reality is something that I am not sure I can verify!  <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="241152249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241152249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241152249">(Jun 02 2021 at 13:56)</a>:</h4>
<p>you can just do it again</p>



<a name="241152285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241152285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241152285">(Jun 02 2021 at 13:57)</a>:</h4>
<p>If there are problems then those problems are coming your way in the future anyway</p>



<a name="241152421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241152421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241152421">(Jun 02 2021 at 13:58)</a>:</h4>
<p>If two different PRs move lemmas around, git usually gives up on you and produces a merged version with the lemmas in both places (possibly alongside confusing merge conflicts)</p>



<a name="241152510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241152510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241152510">(Jun 02 2021 at 13:58)</a>:</h4>
<p>I think that's what happened here</p>



<a name="241153804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241153804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241153804">(Jun 02 2021 at 14:07)</a>:</h4>
<p>This might be what happened here.  I will try to redo the merge, but once my computer is finished with the <code>lean --make src</code> command that is now running.</p>



<a name="241164037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241164037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241164037">(Jun 02 2021 at 15:16)</a>:</h4>
<p>Ok, the PR built on my computer <em>after</em> I removed the extra lines in <code>data/nat/basic</code>.  I then </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">git</span> <span class="n">switch</span> <span class="n">master</span>
<span class="n">leanproject</span> <span class="n">up</span>
<span class="n">git</span> <span class="n">pull</span>  <span class="c1">-- to make sure, "Already up to date."</span>
<span class="n">git</span> <span class="n">switch</span> <span class="n">adomani_ordered_stuff</span>
<span class="n">git</span> <span class="n">merge</span> <span class="n">master</span>  <span class="c1">-- had merge conflict with the manually removed lines: I accepted the incoming *without* the extra lines</span>
</code></pre></div>
<p>and now I think that everything is ok!</p>



<a name="241164268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241164268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241164268">(Jun 02 2021 at 15:18)</a>:</h4>
<p>yeah that looks fine except that now of course you don't know that it builds any more. Why not just push and let CI tell you?</p>



<a name="241164383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241164383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241164383">(Jun 02 2021 at 15:19)</a>:</h4>
<p>CI is already doing that: I am waiting for it to finish, though it might take a few hours still</p>



<a name="241164464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241164464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241164464">(Jun 02 2021 at 15:19)</a>:</h4>
<p>It has been building mathlib for 2h40m, at the moment.</p>



<a name="241164626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241164626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241164626">(Jun 02 2021 at 15:20)</a>:</h4>
<p>(which is a good sign: if there are errors, it often picks them up early, since I am modifying the "initial" ordered files, which get used in <code>nat</code>, for instance.)</p>



<a name="241313610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237645%20ordered_monoid/near/241313610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237645.20ordered_monoid.html#241313610">(Jun 02 2021 at 20:15)</a>:</h4>
<p>Also CI produced oleans successfully!  I assume that no lemmas have been lost (nor duplicated) in the process!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.238082.20succ_order.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html">#8082 succ_order</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247520284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247520284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247520284">(Jul 28 2021 at 21:32)</a>:</h4>
<p>Oh, I ended up (understand, 6 hours ago) taking an entirely different turn to what you suggest. I've just pushed but here's the gist of it.</p>



<a name="247520376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247520376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247520376">(Jul 28 2021 at 21:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">class</span> <span class="n">succ_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">succ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">succ</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">maximal_of_succ_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">a</span><span class="o">⦄,</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">b</span><span class="o">⦄,</span> <span class="bp">¬</span><span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">succ_le_of_lt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="247520461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247520461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247520461">(Jul 28 2021 at 21:34)</a>:</h4>
<p>It seems to work quite well! The amount of lemmas I proved will testify.</p>



<a name="247520696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247520696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247520696">(Jul 28 2021 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247501228">said</a>:</p>
<blockquote>
<p>I believe it's worth the effort to ensure that <code>succ_order</code> is a subsingleton, so we should pick the value of <code>succ \top</code>. <code>\top</code> itself would work if you define <code>succ a</code> as the infimum of all <code>b &gt; a</code>, but <code>\bot</code> would be better if you want to fit addition on <code>fin</code>, so I'm not quite sure what the best option is here.</p>
</blockquote>
<p>This is hopeless so long as we only have <code>preorder α</code>. Consider <code>(≤) := λ a b, true</code>. Then any function <code>α → α</code> will be a valid <code>succ</code>.<br>
For <code>partial_order α</code>, I'll try proving it tomorrow.</p>



<a name="247551072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247551072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247551072">(Jul 29 2021 at 07:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247520696">said</a>:</p>
<blockquote>
<p>For <code>partial_order α</code>, I'll try proving it tomorrow.</p>
</blockquote>
<p>And it's done!</p>



<a name="247560560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247560560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247560560">(Jul 29 2021 at 09:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247551072">said</a>:</p>
<blockquote>
<p>And it's done!</p>
</blockquote>
<p>Please push your results, I'm very curious :)</p>



<a name="247561263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247561263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247561263">(Jul 29 2021 at 09:26)</a>:</h4>
<p>Oh yeah of course! Forgot to hit that little button <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="247561485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247561485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247561485">(Jul 29 2021 at 09:29)</a>:</h4>
<p>I moved the stuff in a new file because it was getting big. I think I'll also create the instance <code>pred_order</code> as the current pattern seems to suggest that I should <code>is_atomic</code>/<code>is_coatomic</code>, <code>is_atomistic/is_coatomistic</code>, <code>order_bot/order_top</code>...</p>



<a name="247599750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247599750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247599750">(Jul 29 2021 at 15:29)</a>:</h4>
<p>I defined <code>pred_order</code> just to see whether everything would be trivial enough to justify not introducing it, but I got stuck on the very first lemma!<br>
Any idea for how to prove this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">gc_pred_succ</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">succ_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">pred_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">galois_connection</span> <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">succ</span> <span class="o">:=</span>
</code></pre></div>
<p>I suspect we need to upgrade the instance to <code>partial_order α</code>, but I'm not quite sure yet.</p>



<a name="247601586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247601586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247601586">(Jul 29 2021 at 15:44)</a>:</h4>
<p>Is there a succ-inct way to describe mathematically what <code>succ a</code> has to be? (I see it is already proven that it is uniquely determined)</p>



<a name="247609503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247609503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247609503">(Jul 29 2021 at 16:48)</a>:</h4>
<p>I claim <code>succ a</code> should be the infimum of all <code>b &gt; a</code>, if <code>a</code> is not <code>\top</code>, and <code>\top</code> otherwise.</p>



<a name="247609555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247609555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247609555">(Jul 29 2021 at 16:48)</a>:</h4>
<p>(The latter case follows from the definition of <code>Inf ∅</code>, of course.)</p>



<a name="247609869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247609869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247609869">(Jul 29 2021 at 16:51)</a>:</h4>
<p>Oooh, nice idea. Let me prove it!</p>



<a name="247609956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247609956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247609956">(Jul 29 2021 at 16:52)</a>:</h4>
<p>I renamed <code>succ_eq_add_one_order</code> to <code>add_succ_order</code>. What do you think?</p>



<a name="247614217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247614217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247614217">(Jul 29 2021 at 17:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247609869">said</a>:</p>
<blockquote>
<p>Oooh, nice idea. Let me prove it!</p>
</blockquote>
<p>Done!</p>



<a name="247614535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247614535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247614535">(Jul 29 2021 at 17:25)</a>:</h4>
<p>It's of course not usable  to prove <code>subsingleton (succ_order α)</code> because we need <code>complete_lattice α</code> instead of just <code>preorder α</code>.</p>



<a name="247628211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247628211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247628211">(Jul 29 2021 at 19:15)</a>:</h4>
<p>Is it always true if you change it to "<code>a</code> otherwise"?</p>



<a name="247628292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247628292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247628292">(Jul 29 2021 at 19:16)</a>:</h4>
<p>In a preorder you surely can't expect to have a uniquely defined successor. So maybe it makes more sense to assume <code>partial_order</code> from the start</p>



<a name="247639476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247639476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247639476">(Jul 29 2021 at 20:51)</a>:</h4>
<p>Yeah, you don't have a unique successor in general, but I actually managed to prove many lemmas for preorders.</p>



<a name="247639699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247639699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247639699">(Jul 29 2021 at 20:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247628211">said</a>:</p>
<blockquote>
<p>Is it always true if you change it to "<code>a</code> otherwise"?</p>
</blockquote>
<p>What do you mean? Here's what I proved following Anne's statement:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">succ_eq_infi</span> <span class="o">[</span><span class="n">complete_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">succ_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">⨅</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">),</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_infi</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">le_infi</span> <span class="n">succ_le_of_lt</span><span class="o">))</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">ha</span> <span class="o">:=</span> <span class="n">eq_or_ne</span> <span class="n">a</span> <span class="bp">⊤</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">succ_top</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_top</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">binfi_le</span> <span class="n">_</span> <span class="o">(</span><span class="n">lt_succ_iff_ne_top.2</span> <span class="n">ha</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247645398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247645398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247645398">(Jul 29 2021 at 21:43)</a>:</h4>
<p>I mean if you don't necessarily have a complete lattice, but rather something with multiple maximal elements</p>



<a name="247645461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247645461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247645461">(Jul 29 2021 at 21:44)</a>:</h4>
<p>e.g. I think the empty relation is a <code>succ_order</code> by the current definition</p>



<a name="247645478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247645478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247645478">(Jul 29 2021 at 21:44)</a>:</h4>
<p>er not empty, the equality relation</p>



<a name="247647882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247647882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247647882">(Jul 29 2021 at 22:09)</a>:</h4>
<p>Yeah sure, isn't that the point of having more general instance requirements?</p>



<a name="247647979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247647979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247647979">(Jul 29 2021 at 22:10)</a>:</h4>
<p>Wilder stuff happens, but the key properties are still preserved. And if you really care about the stronger results, just assume some more instances on the lemmas.</p>



<a name="247648119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247648119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247648119">(Jul 29 2021 at 22:12)</a>:</h4>
<p>For example, originally, <code>succ_order</code> wasn't allowing maximal elements, but this wasn't actually needed for many of the results. So I've relaxed it and results that actually require it get a <code>no_top_order α</code> hypothesis.</p>



<a name="247648589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247648589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247648589">(Jul 29 2021 at 22:18)</a>:</h4>
<p>Yes, so the question is how do you mathematically explain what <code>succ</code> does in general</p>



<a name="247648707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247648707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247648707">(Jul 29 2021 at 22:20)</a>:</h4>
<p>Does <code>succ_eq_infi</code> still hold without the complete lattice assumption if you only assert it is an infimum of that set?</p>



<a name="247676836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247676836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247676836">(Jul 30 2021 at 07:12)</a>:</h4>
<p>You mean "Can you characterize it as the infimum of that set, without talking about infimums?"?</p>



<a name="247691496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247691496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247691496">(Jul 30 2021 at 10:36)</a>:</h4>
<p>No, I mean what I said <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="247691902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247691902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247691902">(Jul 30 2021 at 10:41)</a>:</h4>
<p>Well... <code>succ a</code> is an element that covers <code>a</code>.</p>



<a name="247692406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247692406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247692406">(Jul 30 2021 at 10:48)</a>:</h4>
<p>If <code>a</code> is maximal then we are talking about the inf of the empty set. If the poset doesn't have a largest element then this infimum doesn't make sense and, in any case, could not depend on the choice of <code>a</code>.</p>



<a name="247692532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247692532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247692532">(Jul 30 2021 at 10:50)</a>:</h4>
<p>Ah yeah but I'm not talking about infimums here. I just require <code>a ≤ succ a</code> and <code>succ a</code> covers <code>a</code>.</p>



<a name="247692703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247692703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247692703">(Jul 30 2021 at 10:53)</a>:</h4>
<p>In that case, I would return to my original question</p>



<a name="247692808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247692808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247692808">(Jul 30 2021 at 10:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247601586">said</a>:</p>
<blockquote>
<p>Is there a succ-inct way to describe mathematically what <code>succ a</code> has to be? (I see it is already proven that it is uniquely determined)</p>
</blockquote>
<p>That one, you mean?</p>



<a name="247692899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247692899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247692899">(Jul 30 2021 at 10:55)</a>:</h4>
<p>If <code>a</code> is maximal, <code>succ a</code> just has to be (not strictly) greater than <code>a</code>. If <code>a</code> isn't maximal, then <code>succ a</code> must cover <code>a</code>.</p>



<a name="247856092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247856092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247856092">(Aug 01 2021 at 12:02)</a>:</h4>
<p>I have a problem with my generalized lemmas. They have trouble matching <code>nat.succ</code>, although I've provided <code>succ_order ℕ</code>. Any suggestion?</p>



<a name="247900665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247900665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247900665">(Aug 02 2021 at 08:38)</a>:</h4>
<p>For example, are you asking why you had to turn <code>max_succ_succ</code> into <code>nat.max_succ_succ</code> <a href="https://github.com/leanprover-community/mathlib/pull/8082/commits/14205c3fdedcb8395ad6fc49267ed9c895718261">here</a>?</p>



<a name="247900935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247900935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247900935">(Aug 02 2021 at 08:43)</a>:</h4>
<p>Yes, exactly!</p>



<a name="247901102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247901102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247901102">(Aug 02 2021 at 08:46)</a>:</h4>
<p>That's <code>simp</code>le, you just need to hint to Lean that it needs to do more unfolding:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- In term mode, unfolding is done up to semireducible, which is the default reducibility level:</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">max</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">max_succ_succ</span> <span class="c1">-- works</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">max</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">nat.max_succ_succ</span> <span class="c1">-- works</span>

<span class="c1">-- `simp` only goes up to `reducible`, which `+` satisfies on `nat`:</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">max</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat.max_succ_succ</span><span class="o">]</span> <span class="c1">-- works</span>

<span class="c1">-- but `nat.add_succ_order` isn't reducible enough:</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">max</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">max_succ_succ</span><span class="o">]</span> <span class="c1">-- failed to simplify</span>

<span class="c1">-- so let's ask Lean to unfold it more:</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span> <span class="n">nat.add_succ_order</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">max</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">max</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">max_succ_succ</span><span class="o">]</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="247901158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247901158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247901158">(Aug 02 2021 at 08:47)</a>:</h4>
<p>Ah, so you're saying <code>succ_order</code> should be <code>reducible</code>?</p>



<a name="247901195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247901195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247901195">(Aug 02 2021 at 08:48)</a>:</h4>
<p>The <code>succ_order</code> instance on <code>nat</code>, which is <code>nat.add_succ_order</code>, should be reducible</p>



<a name="247901214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247901214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247901214">(Aug 02 2021 at 08:48)</a>:</h4>
<p>Ah okay!</p>



<a name="247901239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247901239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247901239">(Aug 02 2021 at 08:48)</a>:</h4>
<p>Does it even make sense to have reducible structures?</p>



<a name="247901250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/247901250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#247901250">(Aug 02 2021 at 08:48)</a>:</h4>
<p>That was exactly my question :)</p>



<a name="248389004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/248389004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#248389004">(Aug 04 2021 at 18:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20succ_order/near/247901195">said</a>:</p>
<blockquote>
<p>The <code>succ_order</code> instance on <code>nat</code>, which is <code>nat.add_succ_order</code>, should be reducible</p>
</blockquote>
<p>I don't think marking instances as reducible means anything, does it?</p>



<a name="248416478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/248416478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#248416478">(Aug 04 2021 at 22:20)</a>:</h4>
<p>I am pretty sure that it does something, since just above I posted a code block proving the opposite :)</p>



<a name="248417238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/248417238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#248417238">(Aug 04 2021 at 22:28)</a>:</h4>
<p>If that's the case, this behavior feels like it might interfere with the library note on reducible non-instance, but I might be mistaken.</p>



<a name="248487514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/248487514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#248487514">(Aug 05 2021 at 14:47)</a>:</h4>
<p>Making instances reducible doesn't do anything for type-class inference, but it can definitely affect simp and rw (and other things).</p>
<p>By default, instances have a reducibility setting that is between reducible and semireducible (default for defs). Type-class inference unfolds everything that is reducible or an instance, simp and rw only unfold reducible definitions.</p>



<a name="248491635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/248491635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#248491635">(Aug 05 2021 at 15:14)</a>:</h4>
<p>Uh, does that make them semisemireducible?</p>



<a name="248494719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/248494719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#248494719">(Aug 05 2021 at 15:36)</a>:</h4>
<p>A musician might suggest demisemireducible</p>



<a name="252756941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/252756941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#252756941">(Sep 10 2021 at 09:25)</a>:</h4>
<p>I'm getting back to this. Should we keep the syntax-agreement typeclasses? Eg</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Class stating that `∀ a b, a &lt; b ↔ a + 1 ≤ b` and `∀ a b, a &lt; b + 1 ↔ a ≤ b`. `succ_order` with</span>
<span class="sd">additive notation. -/</span>
<span class="kd">class</span> <span class="n">add_succ_order</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="kd">extends</span>
  <span class="n">succ_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">succ_eq_add_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="254954397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/254954397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#254954397">(Sep 26 2021 at 19:13)</a>:</h4>
<p>I have now opened <a href="https://github.com/leanprover-community/mathlib/issues/9397">#9397</a>. This is the same PR, except for the fact that no other file has been touched. I came to understand that adapting the existing API is by far the most annoying part of <a href="https://github.com/leanprover-community/mathlib/issues/8082">#8082</a> and that's why it has never been ready. If we could already agree on the definitions, then we will be able to decide how the API should change.</p>



<a name="255884985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255884985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255884985">(Oct 02 2021 at 17:20)</a>:</h4>
<p>What should happen with this new API? <a href="https://github.com/leanprover-community/mathlib/issues/8082">#8082</a> tries replacing all the ℕ- and ℤ-specific API around <code>succ</code> and <code>pred</code>.</p>



<a name="255885124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255885124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255885124">(Oct 02 2021 at 17:22)</a>:</h4>
<p>This seems to be a bit hard. In particular, elaboration sometimes has a hard time unifying <code>succ_order.succ</code> with <code>nat.succ</code>.</p>



<a name="255885231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255885231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255885231">(Oct 02 2021 at 17:24)</a>:</h4>
<p>Do you think it's doable to replace <code>succ_order α</code> by <code>is_succ f</code> where <code>f : α → α</code>? <span class="user-mention" data-user-id="238446">@Anne Baanen</span>, that very much sounds like your idea of unbundling morphisms and instead giving them instances.</p>



<a name="255902218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255902218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255902218">(Oct 02 2021 at 22:12)</a>:</h4>
<p>I'm going to say it's not a good idea unless nobody ever will try to replace any given <code>f</code> in <code>succ_order f</code> with any other <code>f'</code>, even if you consider what they're doing is making a mistake.</p>



<a name="255902250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255902250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255902250">(Oct 02 2021 at 22:13)</a>:</h4>
<p>(I am very much not in favour of unbundling morphisms and instead giving them instances! Instead, I want to declare a typeclass instance on <em>types</em> of bundled morphisms.)</p>



<a name="255902548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255902548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255902548">(Oct 02 2021 at 22:18)</a>:</h4>
<p>There's a reason we* dropped unbundled morphisms/subobjects in favour of bundled ones.</p>
<p>*I joined the mathlib community a couple months after the initial push, and only tangentially took part in that refactor.</p>



<a name="255909420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20succ_order/near/255909420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20succ_order.html#255909420">(Oct 03 2021 at 00:27)</a>:</h4>
<p>I'm pretty dubious about trying to retrofit anything onto <code>nat.succ</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
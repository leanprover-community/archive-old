---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html">#13250 Modular form defiinition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303530338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303530338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303530338">(Oct 11 2022 at 22:24)</a>:</h4>
<p>(deleted)</p>



<a name="303533157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533157">(Oct 11 2022 at 22:51)</a>:</h4>
<p>Per one of Moritz' comment on this PR, I think there is a different approach that might be considered for this PR. In particular, I don't think it is quite necessary to realize <code>weakly_modular_form</code> as a submodule of <code>ℍ → ℂ</code>, and similarly for the others. Personally, I think it would make more sense to define the following structures:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">))</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">weakly_modular_form</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
<span class="o">(</span><span class="n">slash_action_eq'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">,</span> <span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">modular_form</span> <span class="kd">extends</span> <span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">structure</span> <span class="n">cusp_form</span> <span class="kd">extends</span> <span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_zero_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">class</span> <span class="n">weakly_modular_form_class</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">ℍ</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">slash_action_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">),</span> <span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">modular_form_class</span> <span class="kd">extends</span> <span class="n">weakly_modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">class</span> <span class="n">cusp_form_class</span> <span class="kd">extends</span> <span class="n">weakly_modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_at_infty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_zero_at_im_infty</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="bp">Γ</span> <span class="bp">𝕜</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">cusp_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="n">modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">weakly_modular_form_class</span> <span class="o">(</span><span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">modular_form_class</span> <span class="o">(</span><span class="n">modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">cusp_form_class</span> <span class="o">(</span><span class="n">cusp_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>After this (and some other boilerplate you should add that comes with the hom class setup) you can provide module instances for <code>weakly_modular_form</code>, <code>modular_form</code> and <code>cusp_form</code>, which is straightforward. You can also provide a graded multiplication operation on relevant types too. And finally, you can take the direct sum of <code>modular_form Γ</code> and put a graded ring structure on it. </p>
<p>All this being said, I'm not a number theorist, and I don't know much about modular forms. I'm posting this on Zulip so there can be discussion around it.</p>



<a name="303533295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533295">(Oct 11 2022 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> has marked this topic as unresolved.</p>



<a name="303533308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533308">(Oct 11 2022 at 22:53)</a>:</h4>
<p>The approach described above should definitely be multiple PRs (although I think this PR should be split into multiple pieces as is anyway).</p>



<a name="303533408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533408">(Oct 11 2022 at 22:53)</a>:</h4>
<p>Note that <span class="user-mention" data-user-id="389019">@Chris Birkbeck</span> already has the graded ring structure done (deferred to a different PR), so your proposal (which sounds reasonable to me) is just a different route to that.</p>



<a name="303533552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533552">(Oct 11 2022 at 22:54)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13250#issuecomment-1272409520">https://github.com/leanprover-community/mathlib/pull/13250#issuecomment-1272409520</a></p>



<a name="303533564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533564">(Oct 11 2022 at 22:54)</a>:</h4>
<p>Yes, I realized that. Thanks.</p>



<a name="303533662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533662">(Oct 11 2022 at 22:56)</a>:</h4>
<p>The above is mainly about uniformity of design with respect to other parts of mathlib, but also what I think will be easiest to work with.</p>



<a name="303533837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303533837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303533837">(Oct 11 2022 at 22:58)</a>:</h4>
<p>Question: Does <code>modular_form_class</code>, the top of that tree, only need to exist if it is anticipated that there will be further extensions to it?  Or should it exist anyway?</p>



<a name="303534376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303534376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303534376">(Oct 11 2022 at 23:03)</a>:</h4>
<p>You mean <code>cusp_form_class</code>?</p>



<a name="303534518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303534518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303534518">(Oct 11 2022 at 23:05)</a>:</h4>
<p>Either way, yes, it should still exist.</p>



<a name="303534528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303534528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303534528">(Oct 11 2022 at 23:05)</a>:</h4>
<p>Sorry, yes.</p>



<a name="303534564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303534564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303534564">(Oct 11 2022 at 23:05)</a>:</h4>
<p>What is the purpose of having the "top of the tree" class?  (This is my crash course in <code>fun_like</code>.)</p>



<a name="303535624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303535624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303535624">(Oct 11 2022 at 23:19)</a>:</h4>
<p>The purpose is that what you think is the top of the tree is usually not <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> But yes indeed we add those mostly to have a uniform design and avoid confusing the end user even more.</p>



<a name="303535771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303535771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303535771">(Oct 11 2022 at 23:20)</a>:</h4>
<p>That's how you know that hom's of the leaf node of the tree also have all the properties of all lower nodes.</p>
<p>For example, let's say you have two homs, <code>hom1</code> and <code>hom2</code> extends <code>hom1</code> (as an example, think of <code>add_monoid_hom</code> and <code>ring_hom</code>). These have associated classes <code>hom1_class</code> and <code>hom2_class</code>, where the latter extends the former, and <code>hom1</code> is an instance of <code>hom1_class</code> and similarly for <code>hom2</code> and <code>hom2_class</code>.</p>
<p>Now, let's say you prove a lemma that holds for <code>f : hom1</code>. Likely it generalizes to anything where <code>f : F</code> and <code>F</code> has an instance of <code>hom1_class</code>. Then you take some <code>g : hom2</code>. You would like to say that this lemma automatically holds for <code>g</code>, and if you phrased it in terms of <code>hom1_class</code>, then it does! The reason is that <code>hom2</code> has a <code>hom2_class</code> instance which means it has a <code>hom1_class</code> instance, so the lemma applies.</p>
<p>You could technically avoid this by providing directly a <code>hom1_class</code> instance for <code>hom2</code>, but that would be bad (just in case what you thought was the top of the tree <del>really</del> <em>eventually</em> isn't).</p>



<a name="303546059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303546059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303546059">(Oct 12 2022 at 01:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303535624">said</a>:</p>
<blockquote>
<p>The purpose is that what you think is the top of the tree is usually not <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> </p>
</blockquote>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303535771">said</a>:</p>
<blockquote>
<p>just in case what you thought was the top of the tree <del>really</del> <em>eventually</em> isn't</p>
</blockquote>
<p>I think this is the answer I was after: there's a belief that everything will get specialized further some day.  I guess I don't see now what that's going to be for <code>cusp_form</code>, but undoubtedly that's just an invitation to eat my words in 10 months.</p>



<a name="303547858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303547858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303547858">(Oct 12 2022 at 01:49)</a>:</h4>
<p>Yeah, I see what you mean. The other reason is uniformity of API. And probably to piggy back on that, even if <code>cusp_form</code> really is a leaf forever, you don't want people to look at that and say, "oh, it's a leaf so they don't provide the associated hom class, I'll do that with my hom class which is also a leaf," but that one doesn't end up being a leaf.</p>



<a name="303575664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303575664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303575664">(Oct 12 2022 at 07:48)</a>:</h4>
<p>Whilst I definitely agree that the space of modular forms should be a type not a term, I'll say again here that in the literature "weakly modular" usually implies meromorphic (and in particular differentiable, and not C-valued).</p>
<p>Another issue with the whole approach of the PR is that really this is not the correct generality, but I have not mentioned this until now for fear of derailing this PR even more. I think that if Sebastian Gouezel were writing this definition he'd define the notion of a modular form for any discrete subgroup of SL(2, real) and if you do it this way then the theory of cusps and boundedness is far more delicate -- the cusps correspond to parabolic elements of the subgroup. I'd refrained from mentioning this until now because ultimately the most used kinds of modular forms are the ones coming from subgroups of SL2(Z) where the cusps are just the rationals and this is what we have right now, so this is very much a "perfect is the enemy of good" comment, but using general discrete Fuchsian groups of the first kind is what one should really be doing here rather than subgroups of SL(2,int).</p>



<a name="303575885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303575885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303575885">(Oct 12 2022 at 07:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303533157">said</a>:</p>
<blockquote>
<p>Per one of Moritz' comment on this PR, I think there is a different approach that might be considered for this PR. In particular, I don't think it is quite necessary to realize <code>weakly_modular_form</code> as a submodule of <code>ℍ → ℂ</code>, and similarly for the others. Personally, I think it would make more sense to define the following structures:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">))</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">weakly_modular_form</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
<span class="o">(</span><span class="n">slash_action_eq'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">,</span> <span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">modular_form</span> <span class="kd">extends</span> <span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">structure</span> <span class="n">cusp_form</span> <span class="kd">extends</span> <span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_zero_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">class</span> <span class="n">weakly_modular_form_class</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">ℍ</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">slash_action_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">),</span> <span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">modular_form_class</span> <span class="kd">extends</span> <span class="n">weakly_modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">class</span> <span class="n">cusp_form_class</span> <span class="kd">extends</span> <span class="n">weakly_modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_at_infty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_zero_at_im_infty</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="bp">Γ</span> <span class="bp">𝕜</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">cusp_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="n">modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">weakly_modular_form_class</span> <span class="o">(</span><span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">modular_form_class</span> <span class="o">(</span><span class="n">modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">cusp_form_class</span> <span class="o">(</span><span class="n">cusp_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>After this (and some other boilerplate you should add that comes with the hom class setup) you can provide module instances for <code>weakly_modular_form</code>, <code>modular_form</code> and <code>cusp_form</code>, which is straightforward. You can also provide a graded multiplication operation on relevant types too. And finally, you can take the direct sum of <code>modular_form Γ</code> and put a graded ring structure on it. </p>
<p>All this being said, I'm not a number theorist, and I don't know much about modular forms. I'm posting this on Zulip so there can be discussion around it.</p>
</blockquote>
<p>Ok so let me see how this would go. Every time I make something higher up I make it as a structure and a class and then it should be easy to make the new definitions inherit old properties?</p>



<a name="303576060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303576060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303576060">(Oct 12 2022 at 07:50)</a>:</h4>
<p>I agree about the weakly modular usually implying meromorphic, but I didnt know if we had meromorphic yet? I could just call it something else?</p>



<a name="303576414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303576414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303576414">(Oct 12 2022 at 07:53)</a>:</h4>
<p>but going back to the proposed approach, <code>cusp_forms</code> aren't the top as eventually we'll want things like <code>eigenform</code>, <code>newform</code>, <code>primitive</code> and so on. Similarly there will be more branching lower down, such as using <code>weakly modular</code> to define <code>maass forms</code> and so on. This is a probably a silly question,  but will this branching cause any issues?</p>



<a name="303577730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303577730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303577730">(Oct 12 2022 at 08:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303575664">said</a>:</p>
<blockquote>
<p>Whilst I definitely agree that the space of modular forms should be a type not a term, I'll say again here that in the literature "weakly modular" usually implies meromorphic (and in particular differentiable, and not C-valued).</p>
<p>Another issue with the whole approach of the PR is that really this is not the correct generality, but I have not mentioned this until now for fear of derailing this PR even more. I think that if Sebastian Gouezel were writing this definition he'd define the notion of a modular form for any discrete subgroup of SL(2, real) and if you do it this way then the theory of cusps and boundedness is far more delicate -- the cusps correspond to parabolic elements of the subgroup. I'd refrained from mentioning this until now because ultimately the most used kinds of modular forms are the ones coming from subgroups of SL2(Z) where the cusps are just the rationals and this is what we have right now, so this is very much a "perfect is the enemy of good" comment, but using general discrete Fuchsian groups of the first kind is what one should really be doing here rather than subgroups of SL(2,int).</p>
</blockquote>
<p>How about I promise to do the refactor when someone wants to think about these other subgroups? :P</p>



<a name="303578986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303578986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303578986">(Oct 12 2022 at 08:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303575664">said</a>:</p>
<blockquote>
<p>Another issue with the whole approach of the PR is that really this is not the correct generality, [..]</p>
</blockquote>
<p>I agree, but I also want to see the definition of modular forms in mathlib sooner than later. On the other hand, it would be really good to have all the hyperbolic geometry in mathlib and refactoring it later sounds very painful.</p>



<a name="303580422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303580422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303580422">(Oct 12 2022 at 08:23)</a>:</h4>
<p>The solution which occurred to me when I was thinking about this issue privately was to stick with SL2Z for now and use <code>automorphic_form</code> to do the general Fuchsian group case. Let's perhaps not derail the discussion any further, I think Chris' response is the pragmatic one :-)</p>



<a name="303611399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303611399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303611399">(Oct 12 2022 at 11:58)</a>:</h4>
<p>In fact one response to Moritz' observation is that instead of doing SL_2 we should be working with an arbitrary connected reductive group over a global field, and just sticking to SL_2 will make refactoring it later very painful as well. This of course would also be a way to put back the development of modular forms by 5 years. I guess my vision right now is modular forms via SL_2(Z), then later automorphic forms for Fuchian subgroups of SL_2(R), and then a theorem saying that they're isomorphic when the Fuchsian subgroup is a congruence subgroup of SL_2(Z), and then of course later on automorphic forms for G and a theorem saying that when G is an inner form of GL_2 which is split at infinity we recover automorphic forms for Fuchsian subgroups of SL_2(R).  This is a great example of when the "correct generality" is in some sense far too general and we need to make some decisions about where to draw lines.</p>



<a name="303623547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303623547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303623547">(Oct 12 2022 at 13:09)</a>:</h4>
<p>One other direction is wrt the weights. At the moment its an integer, but eventually we might want more general weights. But this is maybe something I can build in now by making the definitions depend on a choice of <code>slash_action</code> ?</p>



<a name="303625212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303625212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303625212">(Oct 12 2022 at 13:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303611399">said</a>:</p>
<blockquote>
<p>In fact one response to Moritz' observation is that instead of doing SL_2 we should be working [..]</p>
</blockquote>
<p>I'll just rename these to <code>birkbeck_modular_forms</code> and when we do it in complete generally we can just coerce them into <code>actual_modular_forms</code> <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>



<a name="303629398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303629398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303629398">(Oct 12 2022 at 13:37)</a>:</h4>
<p><code>old_fashioned_modular_forms</code>. More general weights is a very different kettle of fish. There are vector-valued forms and there are also half-integral weight forms but vector valued forms are a bit niche and half integral weight forms are an analytic theory (there is no algebraic analogue as far as I know) so I'm very happy to wait until later for those things.</p>



<a name="303629935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303629935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303629935">(Oct 12 2022 at 13:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303576060">said</a>:</p>
<blockquote>
<p>I agree about the weakly modular usually implying meromorphic, but I didnt know if we had meromorphic yet? I could just call it something else?</p>
</blockquote>
<p>Why don't you use <code>mdifferentiable</code> for this condition? I.e. move it from the <code>modular_form</code>/<code>cusp_form</code> to the <code>weakly_modular_form</code>.</p>



<a name="303630757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303630757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303630757">(Oct 12 2022 at 13:45)</a>:</h4>
<p>I guess I could do that, but maybe we want to save the name <code>weakly_modular_form</code> for the meromorphic ones? I think maybe I shouldn't call this property <code>weakly_modular</code> and instead call it something else.</p>



<a name="303631319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303631319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303631319">(Oct 12 2022 at 13:49)</a>:</h4>
<p>Oh sorry, I misread -- meromorphic not holomorphic.  Disregard!</p>



<a name="303631710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/303631710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#303631710">(Oct 12 2022 at 13:51)</a>:</h4>
<p>By the way, there is <a href="#narrow/stream/116395-maths/topic/Meromorphic.20functions">kind of a roadmap</a> for meromorphic functions, which will be accessible after <a href="https://github.com/leanprover-community/mathlib/pull/15331">#15331</a>.  I had been thinking of doing this anyway.</p>



<a name="306086071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/306086071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#306086071">(Oct 25 2022 at 17:38)</a>:</h4>
<p>Ok so I'm a bit confused about how to use these new structures/classes. I defined <code>slash_invariant_form</code> and <code>slash_invariant_form_class</code> and I proved some instances on these spaces (in particular on the structure not the class) and then I want to prove similar instances for <code>modular_forms</code> say. How can I use the fact that this extends <code>slash_invariant_form</code> to help do this? Here is an example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">))</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">slash_invariant_form</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
<span class="o">(</span><span class="n">slash_action_eq'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">,</span> <span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">slash_invariant_form_class</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="n">F</span> <span class="n">ℍ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">slash_action_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">),</span> <span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">slash_invariant_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">--Say I have a proof of this</span>

<span class="c1">--Can I use this to make the following easier (i.e. only prove that `mdifferentible` and `bdd_` behaves well?</span>

<span class="kd">structure</span> <span class="n">modular_form</span> <span class="kd">extends</span> <span class="n">slash_invariant_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">instance</span> <span class="n">modular_form.has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Do I just need to do the proof again? Or should I be proving these instances for the classes?</p>



<a name="308640728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/308640728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#308640728">(Nov 08 2022 at 17:56)</a>:</h4>
<p>Ok so I've made the changes to the definitions to make them <code>fun_like</code>. One thing that has come up which I don't know how to fix (mainly because I dont understand the error) is that the linter is giving the following error :<code>slash_invariant_form_class.to_fun_like - The following arguments become metavariables. argument 2: (Γ : subgroup (matrix.special_linear_group (fin 2) ℤ)), argument 3: (k : ℤ)</code>. Any ideas how to fix this/what it means? (I dont really know what a metavariable is)</p>



<a name="308644019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/308644019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#308644019">(Nov 08 2022 at 18:14)</a>:</h4>
<p>I guess the issue is that when typeclass search goes looking for <code>fun_like</code> it doesn't know which <code>k</code> to look for when deriving <code>fun_like</code> from <code>slash_invariant_form_class</code>, the usual solution to this sort of thing is to make <code>k</code> an <code>out_param int</code> rather than an int, at least for the instance, I have no idea if that really makes sense in context though!</p>



<a name="308744647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/308744647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#308744647">(Nov 09 2022 at 09:13)</a>:</h4>
<p>OK I see, let me try that then. Thanks!</p>



<a name="310101186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/310101186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#310101186">(Nov 14 2022 at 23:17)</a>:</h4>
<p><code>out_param</code> is meaningless on instances, it only means things on typeclass indices (IIRC)</p>



<a name="310175605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20defiinition/near/310175605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition.html#310175605">(Nov 15 2022 at 11:00)</a>:</h4>
<p>Indeed: the <code>out_param</code> mechanism is used to determine which parts of a typeclass search goal become variables. So it only applies when a new search goal is started.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
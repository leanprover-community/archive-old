---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html">#8337 Weak convergence</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246778846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246778846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246778846">(Jul 21 2021 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="373986">@Kalle Kytölä</span>, I wondered how you would feel about changing most occurrences of <code>ennreal</code> in this PR to <code>nnreal</code>.  I made a quick pass-through and it didn't seem to break anything in this PR, because integrals of bounded functions wrt finite measures can naturally be considered as part of <code>nnreal</code> rather than <code>ennreal</code>.  The question is more, would it break the subsequent work of yours (not yet PR'd)?  And does it feel natural to you as a probabilist?</p>
<p>The reason I suggest it is that it would let you avoid your definition <code>bounded_continuous_to_ennreal</code>, and instead just use <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function">docs#bounded_continuous_function</a>, which lets the PR hook into the rest of mathlib nicely.</p>
<p>(In a later PR we could take the opportunity to make bounded continuous functions <code>α →ᵇ nnreal</code> into a (topological) semimodule, so that the dual <code>(α →ᵇ nnreal) →L[nnreal] nnreal</code> is well-defined and inherits various structure ... )</p>



<a name="246789675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246789675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246789675">(Jul 21 2021 at 22:41)</a>:</h4>
<p>Potentially the most relevant thing to start with: in the literature, one uses bounded continuous real valued functions as "test functions" in the definition of weak convergence. The boundedness of the function and the finiteness of the measure guarantee integrability (continuity of course guarantees Borel measurability). I departed from this standard choice, and I now realize that I should have justified the departure much better. In fact, when trying to articulate my justifications in response to your suggestion, I started having a lot of doubts about my choice.</p>



<a name="246789718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246789718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246789718">(Jul 21 2021 at 22:41)</a>:</h4>
<p>I'll try to articulate my original reasoning below --- if for nothing else, then to expose its weakness.</p>
<p>If it is not convincing (I'm leaning towards not being convinced myself anymore), my first instinct now would be to go back to the standard definition with bounded continuous <code>real</code>-valued functions and real numbers being spit out by the integrals rather than the <code>nnreal</code>-valued ones. (But I'm open to other arguments, of course!)</p>



<a name="246790001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246790001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246790001">(Jul 21 2021 at 22:44)</a>:</h4>
<p>The only solid piece in favor of what I choice to do is that my non-standard definition is equivalent with the standard definition (and I proved this), so the choice is not absolutely wrong. Moreover, its implementation was not too lengthy. Of course to depart from a standard choice, one should have a more compelling reason --- perhaps that the standard definition makes a not too lengthy implementation somehow harder (which is what I used to believe, probably incorrectly).</p>
<p>(The good news from this otherwise boring remark is that we know that changing to the standard definition we can of course still prove the equivalences --- we'd just end up permuting the equivalent conditions.)</p>



<a name="246790181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246790181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246790181">(Jul 21 2021 at 22:46)</a>:</h4>
<p>Originally, my choice of <code>ennreal</code> was mostly because of the following. I felt that (Lebesgue) <code>lintegral</code> is simpler than (Bochner) <code>integral</code>: the former does not require integrability assumptions to be meaningful, and the construction of (Bochner) <code>integral</code> builds on the simpler (Lebesgue) <code>lintegral</code>. Then <code>ennreal</code>s are what <code>lintegral</code>s spit out (and <code>ennreal</code> is also the codomain of the functions that are fed to <code>lintegral</code>). I thought that using the simpler <code>lintegral</code> as the chosen formal definition was somehow desirable (one avoids passing arguments about integrability), and one would then prove API lemmas showing the equivalence with the usual definition.</p>
<p>Right now I am unsure of whether that argument has any merit. It might in the end boil down to the banal fact that as a newbie with Lean, I just chose to work with the simpler looking piece of the library: <code>lintegral</code> instead of <code>integral</code>.</p>



<a name="246790291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246790291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246790291">(Jul 21 2021 at 22:47)</a>:</h4>
<p>I thought there was also another mild reason to put something  nonnegative (<code>nnreal</code> or <code>ennreal</code>) at center stage: one formulation (and probably a necessary step in the proof of any formulation) of the Riesz-Markov-Kakutani characterization of finite Borel measures as the <em>positive</em> linear functionals on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∥</mi><mo>⋅</mo><msub><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∞</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C(X),\|\cdot\|_\infty)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> (for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> compact metric space, say). The positivity is phrased by assuming nonnegativity of functions throughout, and the nontrivial direction of constructing the measure out of a given positive functional very soon lands in <code>ennreal</code> (after some supremums of the non-negative values), as is natural for measures. I thought the choice of eating <code>ennreal</code>-valued functions and especially spitting out <code>ennreal</code> values was natural in this regard. Though I don't think this was a strong argument at any point even in my own mind.</p>



<a name="246790477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246790477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246790477">(Jul 21 2021 at 22:49)</a>:</h4>
<p>I agree with basically all this -- I think the nonnegative-first strategy is quite elegant!  But what do you think specifically about using <code>nnreal</code> rather than <code>ennreal</code>?</p>



<a name="246790706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246790706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246790706">(Jul 21 2021 at 22:52)</a>:</h4>
<p>Alternatively, we could generalize <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function">docs#bounded_continuous_function</a> to allow the codomain to be a <a href="https://leanprover-community.github.io/mathlib_docs/find/emetric_space">docs#emetric_space</a> rather than a metric space; then <code>ennreal</code> would be a permissible codomain.</p>



<a name="246791007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246791007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246791007">(Jul 21 2021 at 22:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/246790291">said</a>:</p>
<blockquote>
<p>the nontrivial direction of constructing the measure out of a given positive functional very soon lands in <code>ennreal</code> (after some supremums of the non-negative values), as is natural for measures.</p>
</blockquote>
<p>I guess this is the point where, you are saying, we might regret the choice of nnreal over ennreal?</p>



<a name="246791409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246791409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246791409">(Jul 21 2021 at 23:00)</a>:</h4>
<p>I must say I didn't yet really fully grasp the advantage of <code>nnreal</code> over <code>ennreal</code>. It lets us use <code>bounded_continuous_function</code>, true. But I think I don't yet have the experience to appreciate what this enables (although I believe there are good results proven about that). I obviously trust your experience much more here.</p>
<p>One downside (I am not good at judging how serious) of <code>nnreal</code> values is that what comes out of a <code>lintegral</code> has to be passed through a <code>ennreal.to_nnreal</code>. Occasionally things like this created hurdles to me, but I think you'd again know much better how much of those were beginner's stumbling and how much they actually make a difference in the implementation.</p>
<p>If changing to <code>real</code>s would <strong>both</strong> allow to hook into <code>bounded_continuous_function</code> API and make the chosen definition standard (and avoid ennreals, which don't even have a continuous subtraction), then is there still an advantage to <code>nnreal</code>?</p>



<a name="246791812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246791812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246791812">(Jul 21 2021 at 23:05)</a>:</h4>
<p>I mean, this is literally the only project I've done so far, so if you say something works better, I will definitely take your word for that!</p>
<p>It's just that I think my original arguments were weak, and your argument of hooking into <code>bounded_continuous_function</code> API works equally well for the standard definition with <code>real</code>s and (Bochner) <code>integral</code>...</p>



<a name="246791926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246791926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246791926">(Jul 21 2021 at 23:07)</a>:</h4>
<p>I think that in the end, we need both a "signed" piece of the theory and a "positive" piece, with the former done using reals and the latter using either <code>nnreal</code> or <code>ennreal</code>.  So there are two separate questions:</p>
<ul>
<li>which is the "true" definition (with the other one just being an equivalent characterization), the "signed" or the "positive" definition?</li>
<li>in the "positive" definition, do we use <code>nnreal</code> or <code>ennreal</code>?</li>
</ul>



<a name="246792060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246792060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246792060">(Jul 21 2021 at 23:09)</a>:</h4>
<p>Although... I guess with Bochner integral there is the question of whether the values should be reals at all or <code>complex</code>  (importantly the characteristic functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>↦</mo><mi mathvariant="sans-serif">E</mi><mo stretchy="false">[</mo><msup><mi>e</mi><mrow><mi>i</mi><mi>θ</mi><mi>X</mi></mrow></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta \mapsto \mathsf{E}[e^{i \theta X}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.70544em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathsf">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">θX</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>) or something crazily general...</p>
<p>(I guess this is partly what your positive vs. signed distinction gets at, too?)</p>



<a name="246792073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246792073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246792073">(Jul 21 2021 at 23:09)</a>:</h4>
<p>For sure, you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function">docs#bounded_continuous_function</a> in the signed portion of the theory, and if we choose <code>nnreal</code> over <code>ennreal</code> in the positive portion of the theory, we can use <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function">docs#bounded_continuous_function</a> there too.</p>



<a name="246792242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246792242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246792242">(Jul 21 2021 at 23:11)</a>:</h4>
<p>So let me try to sell you on <code>nnreal</code>, or outline the advantages as they occured to me.  (I am speaking for myself, not any kind of "mathlib establishment", and there are several people who know the measure theory/probability library better than I do.  So feel free to disagree or wait for other opinions!)</p>



<a name="246792313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246792313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246792313">(Jul 21 2021 at 23:12)</a>:</h4>
<p>Ok, I now again lean towards the Bochner integral being a too complicated for the purpose of the basic definition...</p>
<p>So then that indeed leaves <code>nnreal</code> and <code>ennreal</code>.</p>



<a name="246793185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246793185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246793185">(Jul 21 2021 at 23:25)</a>:</h4>
<p>Basically, I think it would make heading in the Riesz-Markov-Kakutani direction more elegant.  At the moment, bounded continuous functions into a normed space are given the structure of a normed space: <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.normed_space">docs#bounded_continuous_function.normed_space</a></p>
<p>It shouldn't be too difficult to give a slightly weaker version of this construction, making bounded continuous functions over a metric space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> with a "compatible" module structure into a topological module.  In mathlib, a module need not have subtraction, and the scalars <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> need only form a semiring, not necessarily a ring.  So this all applies to make <code>α →ᵇ nnreal</code> a topological <code>nnreal</code>-module.</p>
<p>Then you can just define the standard weak topology on the dual of a topological module, and this same construction applies to <em>both</em> dual spaces:</p>
<ul>
<li><code>(α →ᵇ nnreal) →L[nnreal] nnreal</code></li>
<li><code>(α →ᵇ ℝ) →L[ℝ] ℝ</code></li>
</ul>
<p>So the parallels between the arguments are made clearer:  you're giving <code>nnreal</code>-linear embeddings of the space of measures into each of these two dual spaces, and proving that the induced topology is the same each time.</p>
<p>I guess what I'm saying is, you get a lot of algebraic structure by using <code>nnreal</code>, if you would like it.</p>



<a name="246793353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246793353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246793353">(Jul 21 2021 at 23:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/246791409">said</a>:</p>
<blockquote>
<p>One downside (I am not good at judging how serious) of <code>nnreal</code> values is that what comes out of a <code>lintegral</code> has to be passed through a <code>ennreal.to_nnreal</code>. Occasionally things like this created hurdles to me, but I think you'd again know much better how much of those were beginner's stumbling and how much they actually make a difference in the implementation.</p>
</blockquote>
<p>So much for the pros.  I don't want to discount, as a con, this point you raise.  But it could be probably helped a bit by proving early on the one lemma that lintegral of a bounded continuous function with respect to a finite measure is finite, and applying it repeatedly.</p>



<a name="246793717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246793717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246793717">(Jul 21 2021 at 23:33)</a>:</h4>
<p>Ok, I definitely have to think about the implementation of <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/246793185">that</a> in more detail. But it certainly sounds good, and much more serious than the single argument I can think of in favor of <code>ennreal</code>s.</p>
<p>(Yeah, much of my portmanteau exercise was fighting coercions, and I haven't yet proven the equivalence with the <code>nnreal</code> definition, so I don't know how hard the <code>ennreal.to_nnreal ∘ lintegral</code> rather than just <code>lintegral</code>would bite back.)</p>
<p>But I am convinced that's worth trying. (More than that, I'm convinced it's a significant improvement. By trying I mean whether I can make it work.) Thank you very much for the idea!</p>
<p>I guess some check should be done to make sure the rest goes through with the modification. I could try to change the definition and prove the equivalence with the standard definition, for example. (I don't know how long it will take me; it depends how much time I find and how badly I get stuck.)</p>



<a name="246794052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246794052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246794052">(Jul 21 2021 at 23:39)</a>:</h4>
<p>OK, great!  I'd love to see how this works out in practice.  If it becomes painful, you can stop fighting it, I won't be offended :)</p>
<p>I sketched out some code for this part earlier today when I was thinking this through -- I'll PR it tonight I hope, so that you can get started on the fun part (the weak topology) immediately:</p>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/246793185">said</a>:</p>
<blockquote>
<p>It shouldn't be too difficult to give a slightly weaker version of this construction, making bounded continuous functions over a metric space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> with a "compatible" module structure into a topological module.  In mathlib, a module need not have subtraction, and the scalars <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> need only form a semiring, not necessarily a ring.  So this all applies to make <code>α →ᵇ nnreal</code> a topological <code>nnreal</code>-module.</p>
</blockquote>



<a name="246798884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246798884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246798884">(Jul 22 2021 at 00:57)</a>:</h4>
<p>Ok, so I'm slowly internalizing this slightly better. (And I'm more convinced that your suggestion is the right approach! I actually remember that you made this good point already much earlier, but back then I thought it is something to add later rather than to take as the starting point.)</p>
<p>Let me still just make sure I follow without too serious misunderstandings...</p>
<p>Do I understand correctly that your proposal is to define the weak-* topology at once for all sorts of (dual) spaces (including duals of Banach spaces, but also duals of more exotic spaces such as topological <code>nnreal</code> modules, for which mathlib already has duals implemented)? I agree that the definition will be basically the same. Maybe the only difference is that so far I didn't explicitly incorporate any linearity in my definition (but it comes built in because the pairing of measures with test functions is by integration).</p>
<p>If that was the idea, then is the planned next step to embed the finite measures to the dual of the appropriate <code>bounded_continuous_function</code>s (whether real valued or nonnegative) and inherit the topology from there? The embedding is the trivial half of Riesz-Markov-Kakutani, and it suffices for the definition of the topology (the fact that the embedding is surjective is the nontrivial half). But at least if we don't right away prove the Riesz-Markov-Kakutani, then the "inheriting" of a topology on the measures is again a <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_space.induced">docs#topological_space.induced</a>, or what is essentially the same, <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.topological_space">docs#subtype.topological_space</a>.</p>
<p>Is this close enough to what you had in mind, <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>?</p>



<a name="246799307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246799307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246799307">(Jul 22 2021 at 01:04)</a>:</h4>
<p>A stupid syntax question I have is how to tell Lean I want two topologies on the same space. I spent probably 5 minutes at one point on trying to put either the weak topology on a Banach space or the weak-* topology on the dual, but I either got the norm-topology via the typeclass inference / <code>instance</code>, or no topology at all. Can you recommend e.g. some part of mathlib that would be a good model of how to use another instance of a structure on a <code>Type</code> in addition to the default <code>instance</code>?</p>



<a name="246799852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246799852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246799852">(Jul 22 2021 at 01:17)</a>:</h4>
<p>Yes, this is all exactly what I mean :)</p>



<a name="246799921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246799921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246799921">(Jul 22 2021 at 01:19)</a>:</h4>
<p>The usual solution to wanting a different instance is to use a type synonym.</p>



<a name="246799983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246799983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246799983">(Jul 22 2021 at 01:20)</a>:</h4>
<p>So we could have <code>topological_module.dual</code> and <code>normed_space.dual</code>, one equipped with the weak topology and one equipped with the norm topology, and it just so happens that for normed spaces they are definitionally equal.  Is that what you mean, Scott?</p>



<a name="246799991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246799991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246799991">(Jul 22 2021 at 01:20)</a>:</h4>
<p>There are lots of examples of this in the category theory library, many of which even have comments: search for <code>type synonym</code>.</p>



<a name="246800164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800164">(Jul 22 2021 at 01:24)</a>:</h4>
<p>I meant something more like if <code>V</code> is a Banach space, we might have <code>weak V</code> be definitionally equal to <code>V</code>, but come equipped with the weak topology instead of the norm topology.</p>



<a name="246800191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800191">(Jul 22 2021 at 01:25)</a>:</h4>
<p>Similarly we might have <code>weak_star_dual V</code>, which is definitionally equal to the linear dual of <code>V</code>, but again comes equipped with a different <code>topology</code> instance.</p>



<a name="246800197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800197">(Jul 22 2021 at 01:26)</a>:</h4>
<p>Ok, all that looks great! I will have to go to sleep now, but this looks like a great idea and I will try it in the hopefully near future.</p>



<a name="246800253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800253">(Jul 22 2021 at 01:27)</a>:</h4>
<p>Sometimes it's even a good idea to make the type synonym <code>irreducible</code> after setting up a certain amount of API, to prevent "accidents" (which sometimes result in the wrong typeclass leaking through: it usually takes some abuse, however).</p>
<p>But other times this is too inconvenient (e.g. it requires use of an explicit function to think of an element of <code>V</code> as an element of <code>V</code> with the weak topology).</p>



<a name="246800305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800305">(Jul 22 2021 at 01:28)</a>:</h4>
<p>Just one more question... In a type synonym, do we get to keep all the other structure that is already there? We want to throuw away only the wrong topology, not other <code>instance</code>s, right?</p>



<a name="246800306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800306">(Jul 22 2021 at 01:28)</a>:</h4>
<p>I always get weak and weak-* mixed up.  Weak-* is on the dual, is that right?  (If so, edit everything I previously said in this conversation.). But I think the point I was making remains, that <code>weak_star_dual V</code> can be defined more generally (for <code>V</code> a topological module rather than a normed space) than the current <a href="https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual">docs#normed_space.dual</a> (with the operator norm).</p>



<a name="246800521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246800521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246800521">(Jul 22 2021 at 01:34)</a>:</h4>
<p>We probabilists have the weak and weak-star mixed up by convention rather than by accident <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span>. (And even with this great excuse I probably get them backwards. But I think weak-* is supposed to be on the dual indeed. For ordinary mathematicians, not probabilists.)</p>



<a name="246801066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246801066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246801066">(Jul 22 2021 at 01:47)</a>:</h4>
<p>When you make a type synonym by default _none_ of the instances are available.</p>
<p>However using <code>@[derive [foo, bar, baz]]</code> on the definition of the synonym lets you fairly painlessly copy over the ones you want to keep.</p>



<a name="246801126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246801126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246801126">(Jul 22 2021 at 01:48)</a>:</h4>
<p>Does it copy the ones "underneath" the ones you explicitly copy?  So if you copy the monoid instance does it bring the inhabited instance with it?</p>



<a name="246801223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246801223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246801223">(Jul 22 2021 at 01:51)</a>:</h4>
<p>Yes, because there wasn't actually an inhabited instance in the first place: it was being found by typeclass inference.</p>



<a name="246802614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/246802614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#246802614">(Jul 22 2021 at 02:23)</a>:</h4>
<p>That said, there are plenty of places in mathlib where you see <code>@[derive [inhabited, *_monoid]]</code>. Perhaps I'm wrong, or perhaps these are redundant.</p>



<a name="247092494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/247092494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#247092494">(Jul 24 2021 at 20:51)</a>:</h4>
<p>Thanks Scott! I had no time to return to this before right now. I'm looking into type sysonyms, but still have questions (I got past the "can't tell Lean that I want to consider two topologies"). I will pose a <a href="#narrow/stream/113489-new-members/topic/type.20synonym/near/247092154">specific question</a> (in fact two) in the <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> stream, since my struggles are more general than just the PR in question, and on the other hand hardly get to the start of Heather's improvement. </p>
<p>(I phrase my example there with the weak rather than the more appropriate weak-* topology, but regarding the syntax there is probably no difference.)</p>
<p>(Also I may have missed if Heather had made PRs already. I also wasn't sure what exactly they would include. But this is stuff I want to learn in any case.)</p>



<a name="247465579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/247465579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#247465579">(Jul 28 2021 at 14:22)</a>:</h4>
<p>I made some experiments, mostly with defining the weak-* topology on a type synonym of the dual of a normed space, and sufficient API so that it can be used for the purpose of the "standard" definition of the weak convergence of measures. What I did so far is not yet in the generality of the weak-* topology that Heather proposed above --- this is the "standard" rather than the "non-negative" route, whose main drawback in my opinion is being based on Bochner integration (of <code>ℝ</code>-valued functions, a bit arbitrarily) rather than the more fundamental Lebesgue integration.</p>
<p>My own feeling is that the experiment looks reasonable, and with cleaning up and Heather's actual proposed modification, it could be a good definition of the weak convergence of finite measures and probability measures. I'm fairly confident I could make portmanteau work starting from this... <span aria-label="fingers crossed" class="emoji emoji-1f91e" role="img" title="fingers crossed">:fingers_crossed:</span></p>
<p>The reason I didn't implement Heather's generality yet is because I think the modifications will be very straightforward once I familiarize myself with the right typeclasses of topological modules over topological semirings and what not. Before embarking on that, I thought I'd ask if the structure and the API look reasonable (once modified to the correct, more general typeclasses).</p>



<a name="247465677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/247465677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#247465677">(Jul 28 2021 at 14:23)</a>:</h4>
<p>So here's my outline of the weak-* topology on the dual of a normed space (nothing yet to do with measures):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.dual</span>
<span class="kn">import</span> <span class="n">measure_theory.bochner_integration</span>
<span class="kn">import</span> <span class="n">measure_theory.borel_space</span>
<span class="kn">import</span> <span class="n">topology.continuous_function.bounded</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="kn">open</span> <span class="n">real.abs</span>
<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>
<span class="n">open_locale</span> <span class="n">bounded_continuous_function</span>

<span class="kn">section</span> <span class="n">weak_star_topology</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">### Weak star topology on the dual of a normed space</span>

<span class="cm">(...to be defined in a greater generality, as suggested by Heather.)</span>

<span class="cm">In this section, we define the weak-star topology on the dual of a normed</span>
<span class="cm">space. We use the type synomym `weak_dual 𝕜 E` for the `dual 𝕜 E` of</span>
<span class="cm">a normed space `E` when the topology instance is `weak_dual.topology`</span>
<span class="cm">instead of the norm topology coming from the operator norm.</span>
<span class="cm">-/</span>

<span class="kn">open</span> <span class="n">normed_space</span>
<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>

<span class="kd">@[derive [add_comm_group, module 𝕜]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">weak_dual</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span>

<span class="sd">/-- The canonical map `dual 𝕜 E → weak_dual 𝕜 E` at the type level. -/</span>
<span class="kd">def</span> <span class="n">to_weak_dual'</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>

<span class="sd">/-- The canonical map `weak_dual 𝕜 E → dual 𝕜 E` at the type level. -/</span>
<span class="kd">def</span> <span class="n">to_ordinary_dual'</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">instance</span> <span class="n">weak_dual.has_coe_to_fun</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span>  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="n">to_ordinary_dual'</span> <span class="bp">𝕜</span> <span class="n">x'</span><span class="o">)</span> <span class="n">x</span><span class="o">))</span> <span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">weak_dual.coe_to_fun_def</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">to_weak_dual_injective</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="o">,</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">to_ordinary_dual_injective</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_weak_dual_to_ordinary_dual'</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="o">(</span><span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="n">x'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_ordinary_dual_to_weak_dual'</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="o">(</span><span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="n">x'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_weak_dual_inj_iff'</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x'</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="n">y'</span> <span class="bp">↔</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">y'</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_ordinary_dual_inj_iff'</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="n">y'</span> <span class="bp">↔</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">y'</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="sd">/-- The canonical linear map `dual 𝕜 E → weak_dual 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">to_weak_dual</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">linear_map</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">to_weak_dual'</span> <span class="bp">𝕜</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x'</span> <span class="n">y'</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">c</span> <span class="n">x'</span> <span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span> <span class="o">}</span>

<span class="sd">/-- The canonical linear map `weak_dual 𝕜 E → dual 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">to_ordinary_dual</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">linear_map</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">to_ordinary_dual'</span> <span class="bp">𝕜</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x'</span> <span class="n">y'</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">c</span> <span class="n">x'</span> <span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span> <span class="o">}</span>

<span class="sd">/-- The linear equivalence between `dual 𝕜 E` and `weak_dual 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">equiv_to_weak_dual</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">linear_equiv</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">to_weak_dual'</span> <span class="bp">𝕜</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x'</span> <span class="n">y'</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">c</span> <span class="n">x'</span> <span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">to_ordinary_dual'</span> <span class="bp">𝕜</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">to_weak_dual_to_ordinary_dual'</span> <span class="bp">𝕜</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">to_ordinary_dual_to_weak_dual'</span> <span class="bp">𝕜</span><span class="o">,</span> <span class="o">}</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">weak_dual</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">weak_dual.equiv_to_fun_def</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">equiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">--@[simp]</span>
<span class="kd">lemma</span> <span class="n">equiv_to_weak_dual_apply</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">to_weak_dual'</span> <span class="bp">𝕜</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">to_weak_dual_eq_iff_eq_to_ordinary_dual</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">y'</span> <span class="bp">↔</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="n">y'</span> <span class="o">:=</span>
<span class="n">equiv.apply_eq_iff_eq_symm_apply</span> <span class="o">(</span><span class="n">equiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">to_ordinary_dual_eq_iff_eq_to_weak_dual</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_ordinary_dual'</span> <span class="n">_</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">y'</span> <span class="bp">↔</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="n">y'</span> <span class="o">:=</span>
<span class="n">equiv.apply_eq_iff_eq_symm_apply</span> <span class="o">(</span><span class="n">equiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv.symm</span>

<span class="c1">--@[simp]</span>
<span class="kd">lemma</span> <span class="n">equiv_to_weak_dual_symm_apply</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">equiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">to_ordinary_dual'</span> <span class="bp">𝕜</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">inhabited</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)]</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">to_weak_dual'</span> <span class="n">_</span> <span class="o">(</span><span class="n">default</span> <span class="n">_</span><span class="o">)⟩</span>

<span class="sd">/-- The weak-star topology. -/</span>
<span class="kd">instance</span> <span class="n">weak_dual.topology</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">topological_space</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">topological_space.induced</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">))</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">weak_dual.test_continuous'</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">continuous_induced_dom</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="bp">𝕜</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">x</span><span class="o">))</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">weak_dual.test_continuous</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_pi_iff.mp</span> <span class="o">(</span><span class="n">weak_dual.test_continuous'</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span> <span class="n">z</span>

<span class="kd">theorem</span> <span class="n">weak_dual.tendsto_iff_forall_test_tendsto</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">ψs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">ψ</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">ψs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">ψ</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">ψs</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="n">z</span><span class="o">)</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">weak_star_conv</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">tendsto_pi.mp</span>
      <span class="o">(</span><span class="n">tendsto.comp</span> <span class="o">(</span><span class="n">continuous.tendsto</span> <span class="o">(</span><span class="n">weak_dual.test_continuous'</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span> <span class="n">weak_star_conv</span><span class="o">),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h_lim_forall</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_lim</span> <span class="o">:=</span> <span class="n">tendsto_pi.mpr</span> <span class="n">h_lim_forall</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">nhds_induced</span><span class="o">,</span> <span class="n">tendsto_comap_iff</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">theorem to_weak_dual_continuous (E : Type*) [normed_group E] [normed_space 𝕜 E] :</span>
<span class="cm">  continuous (@to_weak_dual 𝕜 _ E _ _) :=</span>
<span class="cm">begin</span>
<span class="cm">  apply continuous_induced_rng,</span>
<span class="cm">  apply continuous_pi_iff.mpr,</span>
<span class="cm">  intros z,</span>
<span class="cm">  dsimp,</span>
<span class="cm">  -- TODO: Surely this map is `∥z∥`-Lipschitz and therefore continuous :/.</span>
<span class="cm">  -- But this is not the generality Heather is proposing anyway, and in the right</span>
<span class="cm">  -- generality we could not use the norms. so I'll `sorry` it for now.</span>
<span class="cm">  sorry,</span>
<span class="cm">end</span>

<span class="cm">/-- Here is a relatively explicit statement about the weak-star topology begin coarser</span>
<span class="cm">    than the dual-norm topology. But based on the sorried lemma above, and not elegant yet... -/</span>
<span class="cm">theorem open_set_of_weak_dual_open_set (E : Type*) [normed_group E] [normed_space 𝕜 E]</span>
<span class="cm">  (s : set (dual 𝕜 E)) (s_weak_dual_open : is_open (to_weak_dual 𝕜 '' s)) : is_open s :=</span>
<span class="cm">begin</span>
<span class="cm">  have key := continuous_def.mp (to_weak_dual_continuous 𝕜 E) _ s_weak_dual_open,</span>
<span class="cm">  have eq : (to_weak_dual' 𝕜)⁻¹' ((to_weak_dual' 𝕜) '' s) = s,</span>
<span class="cm">  { ext x',</span>
<span class="cm">    simp only [set.mem_preimage, set.mem_image, iff_self, exists_eq_right], },</span>
<span class="cm">  rwa eq at key,</span>
<span class="cm">end</span>
<span class="cm">-/</span>

<span class="kd">end</span> <span class="n">weak_star_topology</span>
</code></pre></div>



<a name="247465765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/247465765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#247465765">(Jul 28 2021 at 14:23)</a>:</h4>
<p>...continuing from above (Zulip's 10k character limit hit), here is the part with the "standard" definition of weak convergence of measures (as inherited from the weak-* topology on the dual of the normed space <code>α →ᵇ ℝ</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">weak_convergence_of_measures</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">### Topology of weak convergence of measures</span>
<span class="cm">In this section, we define the topology of weak convergence on the set of Borel probability</span>
<span class="cm">measures and on the set of finite Borel measures on a topological space.</span>
<span class="cm">-/</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span>

<span class="sd">/-- Probability measures are defined as the subtype of measures that have the property of being</span>
<span class="sd">probability measures (i.e., their total mass is one). -/</span>
<span class="kd">def</span> <span class="n">probability_measures</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">probability_measure</span> <span class="n">μ</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">probability_measures_inhabited</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">measure_theory.measure.dirac</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">),</span>
   <span class="n">property</span> <span class="o">:=</span> <span class="n">measure_theory.measure.dirac.probability_measure</span><span class="o">,</span> <span class="o">}⟩</span>

<span class="kd">instance</span> <span class="n">probability_measures.has_coe_to_measure</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">subtype.val</span><span class="o">⟩</span>

<span class="sd">/-- Coercion of a probability measure to a measure. -/</span>
<span class="kd">def</span> <span class="n">probability_measures.to_measure</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">μ</span>

<span class="kd">instance</span> <span class="n">probability_measures.has_coe_to_fun</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ennreal</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">μ</span><span class="o">,</span> <span class="n">μ.val.measure_of</span><span class="o">)⟩</span>

<span class="kd">lemma</span> <span class="n">probability_measures.coe_eq_val</span> <span class="o">(</span><span class="n">ν</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">ν</span> <span class="o">:</span> <span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ν.val</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="sd">/-- Finite measures are defined as the subtype of measures that have the property of being finite</span>
<span class="sd">measures (i.e., their total mass is finite). -/</span>
<span class="kd">def</span> <span class="n">finite_measures</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">finite_measure</span> <span class="n">μ</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finite_measures_inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨{</span> <span class="n">val</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
   <span class="n">property</span> <span class="o">:=</span> <span class="n">measure_theory.finite_measure_zero</span><span class="o">,</span> <span class="o">}⟩</span>

<span class="kd">instance</span> <span class="n">finite_measures.has_coe_to_measure</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">subtype.val</span><span class="o">⟩</span>

<span class="sd">/-- Coercion of a finite measure to a measure. -/</span>
<span class="kd">def</span> <span class="n">finite_measures.to_measure</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">μ</span>

<span class="kd">instance</span> <span class="n">finite_measures.has_coe_to_fun</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ennreal</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">μ</span><span class="o">,</span> <span class="n">μ.val.measure_of</span><span class="o">)⟩</span>

<span class="kd">lemma</span> <span class="n">finite_measures.coe_eq_val</span> <span class="o">(</span><span class="n">ν</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">ν</span> <span class="o">:</span> <span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ν.val</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="n">probability_measures.has_coe_to_finite_measures</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">μ</span> <span class="o">,</span> <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">μ.val</span><span class="o">,</span>
                 <span class="n">property</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="c1">-- TODO: This needs golf.</span>
                   <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="n">ennreal.one_lt_top</span><span class="o">,</span>
                   <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">μ.prop.measure_univ</span><span class="o">,</span> <span class="n">probability_measures.coe_eq_val</span><span class="o">]</span> <span class="n">at</span> <span class="n">key</span><span class="o">,</span>
                   <span class="n">exact</span> <span class="o">⟨</span><span class="n">key</span><span class="o">⟩,</span>
                 <span class="kd">end</span><span class="o">,</span> <span class="o">}}</span>

<span class="sd">/-- Coercion of a probability measure to a finite measure. -/</span>
<span class="kd">def</span> <span class="n">probability_measures.to_finite_measure</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">μ</span>

<span class="kd">lemma</span> <span class="n">probability_measures.coe_coe_eq_val</span> <span class="o">(</span><span class="n">ν</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">ν.to_finite_measure</span><span class="o">)</span><span class="bp">.</span><span class="n">to_measure</span> <span class="bp">=</span> <span class="n">ν.val</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span>

<span class="sd">/-- The pairing of a (Borel) probability measure `μ` with a nonnegative bounded continuous</span>
<span class="sd">function is obtained by (Bochner) integrating the (test) function against the measure. This is</span>
<span class="sd">`probability_measures.test_against`. -/</span>
<span class="kd">abbreviation</span> <span class="n">probability_measures.test_against</span>
  <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">integral</span> <span class="n">μ.to_measure</span> <span class="n">f</span>

<span class="sd">/-- The pairing of a finite (Borel) measure `μ` with a nonnegative bounded continuous</span>
<span class="sd">function is obtained by (Bochner) integrating the (test) function against the measure. This is</span>
<span class="sd">`finite_measures.test_against`. -/</span>
<span class="kd">abbreviation</span> <span class="n">finite_measures.test_against</span>
  <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">integral</span> <span class="n">μ.to_measure</span> <span class="n">f</span>

<span class="kd">lemma</span> <span class="n">probability_measures.test_against_comp_via_finite_measures</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">probability_measures.test_against</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">finite_measures.test_against</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">funext</span> <span class="n">μ</span> <span class="n">f</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">integrable_of_bdd_cont</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">opens_measurable_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">normed_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">integrable</span> <span class="n">f</span> <span class="n">μ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">ennreal.of_real</span> <span class="bp">∘</span> <span class="n">norm</span> <span class="bp">∘</span> <span class="n">f</span> <span class="k">with</span> <span class="n">hf'</span> <span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">lintegral</span> <span class="n">μ.to_measure</span> <span class="n">f'</span> <span class="bp">&lt;</span> <span class="bp">⊤</span> <span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">ae_mble</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ae_measurable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">‹</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">›</span> <span class="o">‹</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">›</span> <span class="n">f</span> <span class="n">μ.to_measure</span>
    <span class="o">:=</span> <span class="n">continuous.ae_measurable</span> <span class="n">f.continuous</span> <span class="o">(</span><span class="n">finite_measures.to_measure</span> <span class="n">μ</span><span class="o">),</span>
    <span class="n">exact</span> <span class="o">⟨</span> <span class="n">ae_mble</span> <span class="o">,</span> <span class="o">(</span><span class="n">has_finite_integral_iff_norm</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">this</span> <span class="o">⟩,</span> <span class="o">}</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">bdd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f'</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ennreal.of_real_le_of_real</span> <span class="o">(</span><span class="n">bounded_continuous_function.norm_coe_le_norm</span> <span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">integr_bdd</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">lintegral_mono</span> <span class="n">α</span> <span class="n">_</span> <span class="n">μ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">bdd</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">c'</span> <span class="o">:=</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="k">with</span> <span class="n">hc'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">const_integr</span> <span class="o">:</span> <span class="n">lintegral</span> <span class="n">μ.to_measure</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">,</span> <span class="n">c'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c'</span> <span class="bp">*</span> <span class="o">(</span><span class="n">μ</span><span class="o">(</span><span class="n">univ</span><span class="o">)),</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">lintegral_const</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">total</span> <span class="o">:</span> <span class="n">c'</span> <span class="bp">*</span> <span class="o">(</span><span class="n">μ</span><span class="o">(</span><span class="n">univ</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="bp">⊤</span><span class="o">,</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">ennreal.mul_lt_top</span> <span class="n">ennreal.of_real_lt_top</span> <span class="n">μ.prop.measure_univ_lt_top</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">const_integr</span> <span class="n">at</span> <span class="n">total</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">lt_of_le_of_lt</span> <span class="n">integr_bdd</span> <span class="n">total</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">α</span><span class="o">]</span>
<span class="c1">-- [opens_measurable_space α] suffices...</span>
<span class="c1">-- ...but would not have uniqueness of limits etc. even under the</span>
<span class="c1">-- assumption `has_bounded_continuous_approx_of_closed α`.</span>

<span class="kd">lemma</span> <span class="n">finite_measures.test_against_add</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">f₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">μ.test_against</span> <span class="o">(</span><span class="n">f₁</span> <span class="bp">+</span> <span class="n">f₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">μ.test_against</span> <span class="n">f₁</span> <span class="bp">+</span> <span class="n">μ.test_against</span> <span class="n">f₂</span> <span class="o">:=</span>
<span class="n">integral_add</span> <span class="o">(</span><span class="n">integrable_of_bdd_cont</span> <span class="n">μ</span> <span class="n">f₁</span><span class="o">)</span> <span class="o">(</span><span class="n">integrable_of_bdd_cont</span> <span class="n">μ</span> <span class="n">f₂</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">finite_measures.test_against_smul</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">μ.test_against</span> <span class="o">(</span><span class="n">c</span> <span class="bp">•</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">•</span> <span class="o">(</span><span class="n">μ.test_against</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply</span> <span class="n">integral_smul</span>

<span class="kd">def</span> <span class="n">finite_measures.test_against_linear_map</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linear_map</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">μ.test_against</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">finite_measures.test_against_add</span> <span class="n">μ</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">finite_measures.test_against_smul</span> <span class="n">μ</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">finite_measures.to_dual_of_bounded_continuous</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">normed_space.dual</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">μ.test_against</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">finite_measures.test_against_add</span> <span class="n">μ</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">finite_measures.test_against_smul</span> <span class="n">μ</span><span class="o">,</span>
  <span class="n">cont</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">set</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">μ</span> <span class="n">univ</span><span class="o">)</span><span class="bp">.</span><span class="n">to_real</span> <span class="k">with</span> <span class="n">hc</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">c_as_ennreal</span> <span class="o">:</span> <span class="n">μ</span> <span class="n">univ</span> <span class="bp">=</span> <span class="n">ennreal.of_real</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">hc</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">ennreal.of_real_to_real</span> <span class="o">(</span><span class="n">ne_top_of_lt</span> <span class="n">μ.prop.measure_univ_lt_top</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">set</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">μ.test_against_linear_map.to_add_monoid_hom</span> <span class="k">with</span> <span class="n">hL</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">add_monoid_hom.continuous_of_bound</span> <span class="n">L</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="bp">@</span><span class="n">norm_integral_le_lintegral_norm</span> <span class="n">α</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">μ.to_measure</span> <span class="n">f</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">norm_bound</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">,</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">apply</span> <span class="n">bounded_continuous_function.norm_coe_le_norm</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">norm_bound'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">,</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">norm_bound</span> <span class="n">x</span><span class="o">,</span> <span class="n">ennreal.of_real_le_of_real_iff</span><span class="o">,</span> <span class="n">norm_nonneg</span><span class="o">],</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ.to_measure</span> <span class="bp">≤</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ.to_measure</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">lintegral_mono</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">norm_bound'</span><span class="o">,</span> <span class="o">}</span> <span class="o">,</span>
    <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ.to_measure</span> <span class="bp">=</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">μ</span> <span class="n">univ</span><span class="o">)</span> <span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">lintegral_const</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">c_as_ennreal</span><span class="o">,</span> <span class="bp">←</span><span class="n">ennreal.of_real_mul</span> <span class="o">(</span><span class="n">norm_nonneg</span> <span class="n">f</span><span class="o">)]</span> <span class="n">at</span> <span class="n">eq</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">ub_finite</span> <span class="o">:</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ.to_measure</span> <span class="bp">&lt;</span> <span class="bp">⊤</span><span class="o">,</span>
    <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">eq</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ennreal.of_real_lt_top</span><span class="o">,</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">term_finite</span> <span class="o">:</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ.to_measure</span> <span class="bp">&lt;</span> <span class="bp">⊤</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">apply</span> <span class="n">lt_of_le_of_lt</span> <span class="n">key</span> <span class="n">ub_finite</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">eq'</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∫⁻</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ.to_measure</span><span class="o">)</span><span class="bp">.</span><span class="n">to_real</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">f</span> <span class="bp">∥</span><span class="o">)</span> <span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">eq</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">ennreal.to_real_of_real</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">mul_nonneg</span> <span class="o">(</span><span class="n">norm_nonneg</span> <span class="n">f</span><span class="o">)</span> <span class="n">ennreal.to_real_nonneg</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">eq'</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">ennreal.to_real_le_to_real</span> <span class="o">(</span><span class="n">ne_top_of_lt</span> <span class="n">term_finite</span><span class="o">)</span> <span class="o">(</span><span class="n">ne_top_of_lt</span> <span class="n">ub_finite</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">key</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">finite_measures.to_weak_dual_of_bounded_continuous</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">weak_dual</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">to_weak_dual'</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">μ.to_dual_of_bounded_continuous</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">probability_measures.to_dual_of_bounded_continuous</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">normed_space.dual</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">μ.to_finite_measure.to_dual_of_bounded_continuous</span>

<span class="kd">def</span> <span class="n">probability_measures.to_weak_dual_of_bounded_continuous</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">weak_dual</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">to_weak_dual'</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">μ.to_dual_of_bounded_continuous</span><span class="o">)</span>

<span class="c1">--@[simp]</span>
<span class="kd">lemma</span> <span class="n">finite_measures.test_against_eq_to_weak_dual_test</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">μ.to_weak_dual_of_bounded_continuous</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">μ.test_against</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="c1">--@[simp]</span>
<span class="kd">lemma</span> <span class="n">probability_measures.test_against_eq_to_weak_dual_test</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">μ.to_weak_dual_of_bounded_continuous</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">μ.test_against</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="sd">/-- When `α` is a topological space equipped with its Borel sigma algebra, we introduce the</span>
<span class="sd">topology of weak convergence on `probability_measures α`. This is inherited from the weak-*</span>
<span class="sd">topology on `weak_dual ℝ (α →ᵇ ℝ)` via the mapping of the measures to the functionals</span>
<span class="sd">on bounded continuous functions `α →ᵇ ℝ`. -/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">topological_space.induced</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">),</span> <span class="n">μ.to_weak_dual_of_bounded_continuous</span><span class="o">)</span> <span class="n">infer_instance</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">topological_space.induced</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">),</span> <span class="n">μ.to_weak_dual_of_bounded_continuous</span><span class="o">)</span> <span class="n">infer_instance</span>

<span class="kd">end</span> <span class="n">weak_convergence_of_measures</span>
</code></pre></div>



<a name="247465883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/247465883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#247465883">(Jul 28 2021 at 14:24)</a>:</h4>
<p>...and still continuing (the 10k character limit hit a second time), here are the sanity-checks I did with the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> Integration of test functions against borel probability measures depends continuously on the</span>
<span class="cm">measure. -/</span>

<span class="kd">lemma</span> <span class="n">finite_measures.to_weak_dual_continuous</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">@</span><span class="n">finite_measures.to_weak_dual_of_bounded_continuous</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">continuous_induced_dom</span>

<span class="kd">lemma</span> <span class="n">probability_measures.to_weak_dual_continuous</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_measures.to_weak_dual_of_bounded_continuous</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">continuous_induced_dom</span>

<span class="kd">lemma</span> <span class="n">probability_measures.coe_embedding</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">embedding</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">induced</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">induced_compose</span> <span class="o">(</span><span class="n">probability_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">coe</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">finite_measures.to_weak_dual_of_bounded_continuous</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">key.symm</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inj</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">μ</span> <span class="n">ν</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">subtype.eq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">μ.coe_coe_eq_val</span><span class="o">,</span> <span class="bp">←</span><span class="n">ν.coe_coe_eq_val</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">coe</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">proba_meas_tendsto_nhds_iff_fin_meas_tendsto_nhds</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">δ</span><span class="o">)</span>
  <span class="o">{</span><span class="n">μs</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">μ₀</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">μs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">μ₀</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">∘</span> <span class="n">μs</span><span class="o">)</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">μ₀.to_finite_measure</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">embedding.tendsto_nhds_iff</span> <span class="o">(</span><span class="n">probability_measures.coe_embedding</span> <span class="n">α</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">lemma finite_measures.to_weak_dual_embedding (α : Type*)</span>
<span class="cm">  [measurable_space α] [topological_space α] [borel_space α] :</span>
<span class="cm">  embedding (@finite_measures.to_weak_dual_of_bounded_continuous α _ _ _ ) :=</span>
<span class="cm">{ induced := by refl,</span>
<span class="cm">  inj := begin</span>
<span class="cm">    -- Doesn't hold generally, I guess.</span>
<span class="cm">    -- Needs assumptions like `has_bounded_continuous_approx_of_closed α`.</span>
<span class="cm">    sorry,</span>
<span class="cm">  end, }</span>
<span class="cm">-/</span>

<span class="kd">lemma</span> <span class="n">tendsto_induced_iff</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">xs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">xs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">nhds</span> <span class="n">α</span> <span class="o">(</span><span class="n">topological_space.induced</span> <span class="n">f</span> <span class="n">infer_instance</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">conv_induced</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">f_cont</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">continuous_induced_dom</span> <span class="n">α</span> <span class="n">β</span> <span class="n">f</span> <span class="n">infer_instance</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">continuous.tendsto</span> <span class="n">α</span> <span class="n">β</span>
      <span class="o">(</span><span class="n">topological_space.induced</span> <span class="n">f</span> <span class="n">infer_instance</span><span class="o">)</span> <span class="n">infer_instance</span> <span class="n">f</span> <span class="n">f_cont</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">tendsto.comp</span> <span class="o">(</span><span class="n">key</span> <span class="n">x</span><span class="o">)</span> <span class="n">conv_induced</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">conv_image</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nhds_induced</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">map_le_iff_le_comap.mp</span> <span class="n">conv_image</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">finite_measures.conv_iff_weak_star_conv</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">μs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">μs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">μ</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">μs</span><span class="o">(</span><span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">to_weak_dual_of_bounded_continuous</span><span class="o">)</span>
      <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">μ.to_weak_dual_of_bounded_continuous</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply</span> <span class="n">tendsto_induced_iff</span>

<span class="kd">theorem</span> <span class="n">finite_measures.conv_iff_test_against'</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">μs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">μs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">μ</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">),</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">μs</span><span class="o">(</span><span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">to_weak_dual_of_bounded_continuous</span> <span class="n">f</span><span class="o">)</span>
      <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">μ.to_weak_dual_of_bounded_continuous</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finite_measures.conv_iff_weak_star_conv</span><span class="o">,</span>
       <span class="n">weak_dual.tendsto_iff_forall_test_tendsto</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">finite_measures.weak_conv_iff_test_against</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">μs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">μs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">μ</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">),</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">integral</span> <span class="o">(</span><span class="n">μs</span><span class="o">(</span><span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">to_measure</span> <span class="n">f</span><span class="o">)</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">integral</span> <span class="n">μ.to_measure</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">finite_measures.conv_iff_test_against'</span>

<span class="sd">/-- The usual definition of weak convergence of probability measures is given in terms of sequences</span>
<span class="sd">of probability measures: it is the requirement that the integrals of all continuous bounded</span>
<span class="sd">functions against members of the sequence converge. -/</span>
<span class="kd">theorem</span> <span class="n">probability_measures.weak_conv_iff_test_against</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">μs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">probability_measures</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">μs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">μ</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="o">),</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">integral</span> <span class="o">(</span><span class="n">μs</span><span class="o">(</span><span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">to_measure</span> <span class="n">f</span><span class="o">)</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">integral</span> <span class="n">μ.to_measure</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">proba_meas_tendsto_nhds_iff_fin_meas_tendsto_nhds</span><span class="o">,</span>
      <span class="n">finite_measures.weak_conv_iff_test_against</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247466232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/247466232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#247466232">(Jul 28 2021 at 14:27)</a>:</h4>
<p>To be clear, what I'd like to hear now is whether this type of modification of the definition of weak convergence of measures is the correct direction to pursue. Fixing details and clean-up I can and will do later (...only if it looks like it makes sense).</p>



<a name="248784675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248784675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248784675">(Aug 08 2021 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/246793185">said</a>:</p>
<blockquote>
<p>It shouldn't be too difficult to give a slightly weaker version of this construction, making bounded continuous functions over a metric space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> with a "compatible" module structure into a topological module.  In mathlib, a module need not have subtraction, and the scalars <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> need only form a semiring, not necessarily a ring.  So this all applies to make <code>α →ᵇ nnreal</code> a topological <code>nnreal</code>-module.</p>
</blockquote>
<p>This is now PR'd, <a href="https://github.com/leanprover-community/mathlib/issues/8580">#8580</a>.  Sorry for the delay!</p>



<a name="248927402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248927402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248927402">(Aug 10 2021 at 00:42)</a>:</h4>
<p>Thank you! I modified the definition and first lemmas about <code>weak_dual</code> to hopefully the right generality. There is a minimal amount of API in the general case (what else to say?). There is a bit more for duals of normed spaces --- in particular the proof that the weak-* topology is coarser than the dual-norm topology.</p>
<p>Improvements welcome!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.dual</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.operator_norm</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kn">section</span> <span class="n">weak_star_topology</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">### Weak star topology on duals of topological modules</span>
<span class="cm">In this section, we define the weak-* topology on duals of suitable topological modules `E` over</span>
<span class="cm">suitable topological semirings `𝕜`. The (weak) dual consists of continuous linear functionals</span>
<span class="cm">`E →L[𝕜] 𝕜` from `E` to scalars `𝕜`. The weak-* topology is the coarsest topology on this dual</span>
<span class="cm">`weak_dual 𝕜 E := (E →L[𝕜] 𝕜)` w.r.t. which the evaluation maps at all `z : E` are continuous.</span>

<span class="cm">The weak dual is a module over `𝕜` if the semiring `𝕜` is commutative.</span>
<span class="cm">-/</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">has_continuous_add</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_mul</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_add</span> <span class="n">E</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>

<span class="sd">/-- The (weak) dual of a topological module `E` over a topological semiring `𝕜` consists of</span>
<span class="sd">continuous linear functionals from `E` to scalars `𝕜`. It is a type synonym with the original</span>
<span class="sd">dual, but will be equipped with a different topology. -/</span>
<span class="kd">def</span> <span class="n">weak_dual</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">inhabited</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">default</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
               <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">forall_const</span><span class="o">],</span>
               <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">forall_const</span><span class="o">,</span> <span class="n">smul_zero</span><span class="o">],</span>
               <span class="n">cont</span> <span class="o">:=</span> <span class="n">continuous_const</span><span class="o">,</span> <span class="o">},</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">weak_dual.has_coe_to_fun</span> <span class="o">:</span>
  <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_fun</span> <span class="n">x</span><span class="o">))</span> <span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">weak_dual.topology</span> <span class="o">:</span>
  <span class="n">topological_space</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">topological_space.induced</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">))</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">weak_dual.test_continuous'</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">continuous_induced_dom</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="bp">𝕜</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">x</span><span class="o">))</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">weak_dual.test_continuous</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_pi_iff.mp</span> <span class="o">(</span><span class="n">weak_dual.test_continuous'</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span> <span class="n">z</span>

<span class="kd">theorem</span> <span class="n">weak_dual.tendsto_iff_forall_test_tendsto</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">ψs</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">ψ</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">ψs</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="n">ψ</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">ψs</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="n">z</span><span class="o">)</span> <span class="n">F</span> <span class="o">(</span><span class="bp">𝓝</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">weak_star_conv</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">tendsto_pi.mp</span>
      <span class="o">(</span><span class="n">tendsto.comp</span> <span class="o">(</span><span class="n">continuous.tendsto</span> <span class="o">(</span><span class="n">weak_dual.test_continuous'</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="n">ψ</span><span class="o">)</span> <span class="n">weak_star_conv</span><span class="o">),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h_lim_forall</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_lim</span> <span class="o">:=</span> <span class="n">tendsto_pi.mpr</span> <span class="n">h_lim_forall</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">nhds_induced</span><span class="o">,</span> <span class="n">tendsto_comap_iff</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="sd">/-- If the scalars `𝕜` are a commutative semiring, then `weak_dual 𝕜 E` is an additive commutative</span>
<span class="sd">    monoid (and in fact moreover a module over `𝕜`). -/</span>
<span class="kd">instance</span> <span class="n">weak_dual.add_comm_monoid</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_continuous_add</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_mul</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_add</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">restrict_scalars.add_comm_monoid</span> <span class="bp">𝕜</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>

<span class="sd">/-- If the scalars `𝕜` are a commutative semiring, then `weak_dual 𝕜 E` is (an additive</span>
<span class="sd">    commutative monoid and moreover) a module over `𝕜`. -/</span>
<span class="kd">instance</span> <span class="n">weak_dual.module</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_continuous_add</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_mul</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_add</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">restrict_scalars.module</span> <span class="bp">𝕜</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">weak_star_topology</span>



<span class="kn">section</span> <span class="n">weak_star_topology_for_duals_of_normed_spaces</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">### Weak star topology on duals of normed spaces</span>
<span class="cm">In this section, we prove properties about the weak-* topology on duals of normed spaces.</span>
<span class="cm">We prove in particular that the canonical mapping `dual 𝕜 E → weak_dual 𝕜 E` is continuous,</span>
<span class="cm">i.e., that the weak-* topology is coarser (not necessarily strictly) than the topology given</span>
<span class="cm">by the dual-norm (i.e. the operator-norm).</span>
<span class="cm">-/</span>

<span class="kn">open</span> <span class="n">normed_space</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>

<span class="sd">/-- For normed spaces `E`, there is a canonical map `dual 𝕜 E → weak_dual 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">normed_space.dual.to_weak_dual</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>

<span class="sd">/-- For normed spaces `E`, there is a canonical map `weak_dual 𝕜 E → dual 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">weak_dual.to_original_dual</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">weak_dual.coe_to_fun_eq_original_coe_to_fun</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x'.to_weak_dual</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">to_weak_dual_injective</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_weak_dual</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="o">,</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">to_original_dual_injective</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_original_dual</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="o">,</span> <span class="n">id</span>

<span class="c1">-- Q: Are the following simp-lemmas useful?</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_weak_dual_to_original_dual</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x'.to_original_dual</span><span class="o">)</span><span class="bp">.</span><span class="n">to_weak_dual</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_original_dual_to_weak_dual</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x'.to_weak_dual</span><span class="o">)</span><span class="bp">.</span><span class="n">to_original_dual</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_weak_dual_inj_iff</span> <span class="o">(</span><span class="n">x'</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x'.to_weak_dual</span> <span class="bp">=</span> <span class="n">y'.to_weak_dual</span> <span class="bp">↔</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">y'</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_original_dual_inj_iff</span> <span class="o">(</span><span class="n">x'</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x'.to_original_dual</span> <span class="bp">=</span> <span class="n">y'.to_original_dual</span> <span class="bp">↔</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">y'</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="sd">/-- The linear equivalence between `dual 𝕜 E` and `weak_dual 𝕜 E` for a normed space `E`. -/</span>
<span class="kd">def</span> <span class="n">linequiv_to_weak_dual</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_weak_dual</span><span class="o">),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x'</span> <span class="n">y'</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">c</span> <span class="n">x'</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_original_dual</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">to_original_dual_to_weak_dual</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">to_weak_dual_to_original_dual</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">linequiv_to_weak_dual_apply</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linequiv_to_weak_dual</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">x'.to_weak_dual</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">equiv_to_weak_dual_symm_apply</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linequiv_to_weak_dual.symm</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">x'.to_original_dual</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- TODO: The only reason to separate this from `evaluate_dual_at` is to get access to the proofs</span>
<span class="c1">-- of `map_add'` and `map_smul'`. Surely there is a syntax to avoid this unnecessary intermediate</span>
<span class="c1">-- step... right?</span>
<span class="kd">def</span> <span class="n">normed_space.evaluate_dual_at'</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">forall_const</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">continuous_linear_map.add_apply</span><span class="o">],</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">forall_const</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">pi.smul_apply</span><span class="o">,</span>
                             <span class="n">continuous_linear_map.coe_smul'</span><span class="o">],</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">TODO: Is there a way to make the following dot notation work?</span>
<span class="cm">(And the same for `evaluate_dual_at`?)</span>

<span class="cm">variables (w : E)</span>
<span class="cm">#check w</span>
<span class="cm">#check normed_space.evaluate_dual_at' w</span>
<span class="cm">#check w.evaluate_dual_at' -- fails</span>
<span class="cm">-/</span>

<span class="kd">def</span> <span class="n">normed_space.evaluate_dual_at</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">normed_space.evaluate_dual_at'</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">normed_space.evaluate_dual_at'</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span>
  <span class="n">cont</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">apply</span> <span class="bp">@</span><span class="n">continuous_of_linear_of_bound</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">infer_instance</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">normed_space.evaluate_dual_at'</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span>
      <span class="o">(</span><span class="n">normed_space.evaluate_dual_at'</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">map_smul</span> <span class="o">(</span><span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">x'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">continuous_linear_map.le_op_norm</span> <span class="n">x'</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">mul_comm</span> <span class="n">at</span> <span class="n">key</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">to_weak_dual_continuous</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_weak_dual</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">continuous_induced_rng</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_pi_iff.mpr</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">normed_space.evaluate_dual_at</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">normed_space.dual.continuous_linear_map_to_weak_dual</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="n">weak_dual</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'.to_weak_dual</span><span class="o">),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">linequiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">E</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add'</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">linequiv_to_weak_dual</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">E</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">map_smul'</span><span class="o">,</span>
  <span class="n">cont</span> <span class="o">:=</span> <span class="n">to_weak_dual_continuous</span><span class="o">,</span> <span class="o">}</span>

<span class="c1">-- This is a relatively straightforward statement of the fact that the weak-star topology is</span>
<span class="c1">-- coarser than the dual-norm topology, without abusing definitional equality.</span>
<span class="sd">/-- The weak-star topology is coarser than the dual-norm topology: all weak-star open sets are</span>
<span class="sd">    norm-topology open. -/</span>
<span class="kd">lemma</span> <span class="n">open_set_of_weak_dual_open_set</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span>
  <span class="o">(</span><span class="n">s_weak_dual_open</span> <span class="o">:</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">linequiv_to_weak_dual</span> <span class="bp">''</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="o">(</span><span class="n">linequiv_to_weak_dual</span><span class="o">)</span><span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">linequiv_to_weak_dual</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">x'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_preimage</span><span class="o">,</span> <span class="n">linequiv_to_weak_dual_apply</span><span class="o">,</span> <span class="n">set.mem_image</span><span class="o">,</span> <span class="n">to_weak_dual_inj_iff</span><span class="o">,</span>
               <span class="n">exists_eq_right</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">eq</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_def.mp</span> <span class="n">to_weak_dual_continuous</span> <span class="n">_</span> <span class="n">s_weak_dual_open</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- TODO: The proof below may be abusing definitional equality... And it looks like it needs golf.</span>
<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">linequiv_to_weak_dual_image</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">linequiv_to_weak_dual</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x'</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">hx'</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hx'</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">y'</span><span class="o">,</span> <span class="n">hy'</span><span class="o">,</span> <span class="n">h_eq</span><span class="o">⟩,</span>
    <span class="n">rwa</span> <span class="bp">←</span><span class="n">h_eq</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">hx'</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span> <span class="n">hx'</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span> <span class="o">⟩,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- TODO: The proof and even the statement below may be abusing definitional equality...</span>
<span class="c1">-- But I don't think this can be stated using `≤` on topologies without such abuse.</span>
<span class="sd">/-- The weak-star topology is coarser than the dual-norm topology. -/</span>
<span class="kd">theorem</span> <span class="n">dual_norm_topology_le_weak_dual_topology</span> <span class="o">:</span>
  <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">weak_dual.topology</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">open_set_of_weak_dual_open_set</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">linequiv_to_weak_dual_image</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">weak_star_topology_for_duals_of_normed_spaces</span>
</code></pre></div>



<a name="248927624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248927624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248927624">(Aug 10 2021 at 00:46)</a>:</h4>
<p><span class="user-mention" data-user-id="373986">@Kalle Kytölä</span>  This looks PR-ready, can you go ahead and open one?  I have some comments but I'll make them in place.</p>



<a name="248927626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248927626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248927626">(Aug 10 2021 at 00:46)</a>:</h4>
<p>I believe the above should in principle work as a starting point for weak convergence of measures (once <a href="https://github.com/leanprover-community/mathlib/issues/8580">#8580</a> is merged), although so far I'm still struggling with coercions.</p>
<p>Does it make sense to PR the above <code>weak_dual</code> separately (with any improvements that anyone suggests)? In some sense it is completely independent of the weak convergence of finite Borel measures and of Borel probability measures. (Although I think that this approach via <code>weak_dual ℝ≥0 (α →ᵇ ℝ≥0)</code> suggested by Heather is a great way to define the weak convergence of such measures on a topological space <code>α</code>.)</p>



<a name="248927636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248927636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248927636">(Aug 10 2021 at 00:46)</a>:</h4>
<p>(Snap!)</p>



<a name="248927903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248927903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248927903">(Aug 10 2021 at 00:50)</a>:</h4>
<p>Actually, one point before you PR:  perhaps it would be a good idea to split this into two files, putting the first half in an earlier file (maybe in <code>topology/algebra/***</code>) which doesn't import the normed space theory, and the second half in <code>analysis/normed_space/dual</code>.  What do you think?</p>



<a name="248930275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/248930275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#248930275">(Aug 10 2021 at 01:24)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/8598">#8598</a></p>



<a name="250189395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250189395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250189395">(Aug 21 2021 at 01:34)</a>:</h4>
<p>Ok, let me try to resume this, although I think the simplest is to abandon the original PR <a href="https://github.com/leanprover-community/mathlib/issues/8337">#8337</a> and open new ones that take the better route suggested by Heather. I have basically rewritten (building on the recently merged <a href="https://github.com/leanprover-community/mathlib/issues/8580">#8580</a> and <a href="https://github.com/leanprover-community/mathlib/issues/8598">#8598</a>) the definition of weak convergence of finite measures so that the topology is inherited from the weak-* topology on the dual of bounded continuous <code>nnreal</code>-valued functions. The new version makes it quite natural to introduce more structure on the type <code>finite_measures</code> (and  <code>probability_measures</code>), which should be a good thing. But with more structure and coercion issues between <code>nnreal</code>s and <code>ennreal</code>s the file length is worse by a nontrivial factor...</p>



<a name="250189418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250189418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250189418">(Aug 21 2021 at 01:34)</a>:</h4>
<p>My current version is here, if someone has the energy to comment on it: &lt;<a href="https://github.com/kkytola/lean-questions/blob/main/weak_convergence_of_measures.lean">https://github.com/kkytola/lean-questions/blob/main/weak_convergence_of_measures.lean</a>&gt;.</p>
<p>Due to the length, I plan to make the PR more manageable by splitting to parts, roughly according to the sections in the file:</p>
<ul>
<li><strong>finite_measures</strong>: A section about the type of finite measures on a measurable space, with some basic API including coercions and <code>add_comm_monoid</code> structure (but not yet e.g. <code>module ℝ≥0</code>).</li>
<li><strong>probability_measures</strong>: A similar section about the type of probability measures on a measurable space, with some basic API</li>
<li><strong>various_lemmas</strong>: Lemmas that I (at least felt like I) needed, but which probably belong elsewhere, if they don't exist already and/or can't be simplified so much as to render them unnecessary. Anything worth keeping in this section is  probably in need of some golf... Since it is independent of the rest, I can probably PR the appropriate ones here in microscopic pieces while the more macroscopic ones are in review.</li>
<li><strong>weak_convergence_of_measures</strong>: The actual definition of the topology (finally!). This depends on all of the above, though. The last two <code>theorem</code>s are my current sanity check that this route is leading to the right direction (in particular for the portmanteau theorem).</li>
</ul>



<a name="250189484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250189484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250189484">(Aug 21 2021 at 01:36)</a>:</h4>
<p>So unless there is a more feasible approach or objections, I will discard the original PR <a href="https://github.com/leanprover-community/mathlib/issues/8337">#8337</a> and start PRing pieces of the above. The first steps would be the first two sections, but in parallel I could also PR any of the lemmas in the <strong>various_lemmas</strong> section that are deemed worthwhile.</p>
<p>I will appreciate any comments! (Both before I PR any of this, and during the PR processes, which have been really valuable tutoring for me so far --- huge thanks for that!)</p>



<a name="250232960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250232960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250232960">(Aug 21 2021 at 19:22)</a>:</h4>
<p><span class="user-mention" data-user-id="373986">@Kalle Kytölä</span> To start with a part of mathlib I know well, here are a few comments on the "various lemmas" about bounded continuous functions:</p>
<ul>
<li>I agree <code>bounded_continuous_function.radius_bounded</code> should exist.  Its proof might shorten a bit by combining <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.bounded_range">docs#bounded_continuous_function.bounded_range</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/metric.bounded_iff_subset_ball">docs#metric.bounded_iff_subset_ball</a>.</li>
<li>I don't think <code>bounded_continuous_function.norm_bounded</code> needs to exist, can you use <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.norm_coe_le_norm">docs#bounded_continuous_function.norm_coe_le_norm</a> in its place?</li>
<li>I agree <code>bounded_continuous_function.nnreal.upper_bound</code> should exist (but maybe in the alternative form <code>∀ x, f(x) ≤ dist f 0</code>; that's true, right?  And/or perhaps there should be a lemma saying that <code>dist f 0 = supr f</code>).</li>
<li><code>bounded_continuous_function.integrable</code> could I think be made a 1-liner from <code>bounded_continuous_function.mem_Lp</code>, since there's a lemma somewhere saying a function is in <code>L1</code> iff it's integrable.</li>
<li>I agree <code> bounded_continuous_function.coe_nnreal_comp_measurable</code> should exist, and/or the intermediate fact <code>bounded_continuous_function.measurable</code>.</li>
<li><del>I agree <code>lintegral_lt_top_of_bounded_continuous_to_nnreal</code> should exist.</del> Or maybe instead a lemma saying that a bounded measurable function to <code>nnreal</code> has finite lintegral wrt a finite measure.</li>
</ul>



<a name="250233204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250233204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250233204">(Aug 21 2021 at 19:29)</a>:</h4>
<p>As you said, this would be a good self-contained PR ... I would put the first ones in <code>topology.continuous_function.bounded</code>, and disperse the others appropriately through the measure theory library -- maybe  <code>bounded_continuous_function.integrable</code> in <code>measure_theory.function.l1_space</code>, <code>bounded_continuous_function.measurable</code> in <code>measure_theory.constructions.borel_space</code>, ...</p>



<a name="250233414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250233414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250233414">(Aug 21 2021 at 19:35)</a>:</h4>
<p>For your lemma <code>tendsto_induced_iff</code>, can you instead use <a href="https://leanprover-community.github.io/mathlib_docs/find/inducing.tendsto_nhds_iff">docs#inducing.tendsto_nhds_iff</a>?</p>



<a name="250233699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250233699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250233699">(Aug 21 2021 at 19:43)</a>:</h4>
<p>And one small readability thing for the measure theory part: instead of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A finite measure can be interpreted as a measure. -/</span>
<span class="kd">def</span> <span class="n">to_measure</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtype.val</span> <span class="n">μ</span>
</code></pre></div>
<p>you could set up a coercion (I didn't check the precise syntax)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A finite measure can be interpreted as a measure. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">coe_subtype</span>
</code></pre></div>
<p>and then everywhere you currently write <code>μ.to_measure</code> it should be possible to write just <code>μ</code>, or at worst <code>↑μ</code>.</p>



<a name="250235420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250235420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250235420">(Aug 21 2021 at 20:24)</a>:</h4>
<p>Thank you Heather! All of these make a lot of sense. Regarding the last one, I had actually recently moved away from using <code>coe</code>s here (compared to, e.g., <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/247465765">this earlier draft</a>), since I felt there were too many coercions to different things.</p>
<p>But what you propose makes perfect sense to me again: both <code>finite_measures</code> and <code>probability_measures</code> should have one main <code>coe</code> that takes them to <code>measure</code>s, and one <code>coe_to_fun</code>, which is essentially the same as the <code>measure.coe_to_fun</code> except postcomposed with <code>ennreal.to_nnreal</code> (so these measures can easily be made spit out finite values on measurable sets).</p>
<p>Only one of the things that used to be a <code>coe</code>, namely the embedding of <code>probability_measures</code> into <code>finite_measures</code>, probably should not be a coercion after all.</p>
<p>So good, I'll proceed and look forward to getting more comments in the PRs.</p>
<p>Thank you very much again for the valuable help, Heather!</p>



<a name="250237870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250237870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250237870">(Aug 21 2021 at 21:25)</a>:</h4>
<p>I wonder about naming also ... perhaps it would be more consistent with usual mathlib style to rename the mixin classes <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.finite_measure">docs#measure_theory.finite_measure</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure">docs#measure_theory.probability_measure</a> to respectively <code>is_finite_measure</code> (or <code>measure_theory.measure.is_finite</code>), <code>is_probability_measure</code>, so that Kalle's bundled versions <code>finite_measures</code>, <code>probability_measures</code> can be renamed respectively <code>finite_measure</code>, <code>probability_measure</code>.</p>
<p><span class="user-mention" data-user-id="350992">@Rémy Degenne</span>  <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> what do you think?</p>



<a name="250238057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238057">(Aug 21 2021 at 21:30)</a>:</h4>
<p>Thanks Heather!!! I have been wondering about that, but since the naming was proposed by Floris <a href="#narrow/stream/113489-new-members/topic/Portmanteau.20theorem/near/244535251">here</a>, I have used it so far. But it feels awkward at places, so a Type <code>finite_measure</code> and renaming the existing Prop-flavor structure to <code>is_finite_measure</code> would be fantastic! (+ same for probability measures)</p>



<a name="250238139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238139">(Aug 21 2021 at 21:33)</a>:</h4>
<p>Ah, I see Floris actually had the same thoughts!</p>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/113489-new-members/topic/Portmanteau.20theorem/near/244535251">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> I would define the subtype of probability measure in general. (maybe this def should</span>
<span class="cm">be called `probability_measure` and the class should be called `is_probability_measure`)</span>
<span class="cm">-/</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="250238144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238144">(Aug 21 2021 at 21:33)</a>:</h4>
<p>Maybe it stuck in my memory from him asking it.</p>



<a name="250238189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238189">(Aug 21 2021 at 21:34)</a>:</h4>
<p>I had forgotten. Only kept the name <span aria-label="laughter tears" class="emoji emoji-1f602" role="img" title="laughter tears">:laughter_tears:</span></p>



<a name="250238265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238265">(Aug 21 2021 at 21:36)</a>:</h4>
<p>One advantage would be that these types could then return <code>nnreal</code>-valued measures of sets, via the <code>coe_to_fun</code>. (The default <code>ennreal</code>-valuedness is sometimes a bit of an unnecessary hurdle for these.)</p>
<p>Although a disadvantage is that if these will thus be used more widely as <code>nnreal</code>-valued replacements of special kinds of measures (say probability measures), then using a topology <code>instance</code> may be too much. There are other natural topologies  on probability measures besides the topology of weak convergence, starting from total variation distance, Wasserstein-style distances, etc. (Even the Lévy-Prokhorov metric only gives the weak convergence topology for Polish spaces).</p>



<a name="250238393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238393">(Aug 21 2021 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250238265">said</a>:</p>
<blockquote>
<p>One advantage would be that these types could then return <code>nnreal</code>-valued measures of sets, via the <code>coe_to_fun</code>.</p>
</blockquote>
<p>Since you started this project, <span class="user-mention" data-user-id="243312">@Jason KY.</span> has been working on a simultaneous project, the result of which is <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.vector_measure">docs#measure_theory.vector_measure</a> and consequences such as Radon-Nikodym.  Is it true that finite measures are in bijection with nnreal <code>vector_measure</code>s?</p>



<a name="250238438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238438">(Aug 21 2021 at 21:40)</a>:</h4>
<p>I was going to say that I would like those changed names better :D But apparently I had already said that before :)</p>



<a name="250238440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238440">(Aug 21 2021 at 21:40)</a>:</h4>
<p>Because Jason has already implemented the add_comm_group and nnreal-module structures on nnreal <code>vector_measure</code>s:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.vector_measure.module">docs#measure_theory.vector_measure.module</a></p>



<a name="250238489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238489">(Aug 21 2021 at 21:42)</a>:</h4>
<p>Oh! I hadn't paid attention and seen the <code>vector_measure</code> was going on. Yes, looks like they would be in bijection (at least on a quick glance).</p>



<a name="250238630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238630">(Aug 21 2021 at 21:45)</a>:</h4>
<p>Regarding the <code>nnreal</code>-module structure on <code>finite_measure(s)</code>, what was missing from my draft was <code>smul</code>.  I thought first making <code>measure α</code> have a <code>smul</code> by <code>ennreal</code> would have been the natural route (didn't yet check if it works, though). But if Jason's <code>vector_measure</code> can be used more directly, that's good.</p>



<a name="250238687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238687">(Aug 21 2021 at 21:47)</a>:</h4>
<p>If the bijection is true, would make sense to use nnreal <code>vector_measure</code>s instead of creating a bundled <code>finite_measure</code> separately?  It sort of shifts the work around, right?  You have to do some work to prove the bijection (which provides the <code>coe</code> to <code>measure</code> and the proof that the <code>coe</code> satisfies <code>finite_measure</code>), but perhaps having an object which natively outputs <code>nnreal</code>s saves work in other places, and of course the algebraic structure comes for free from Jason's work.  I don't know which is better.</p>
<p>Hopefully the measure theory experts will weigh in.</p>



<a name="250238816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238816">(Aug 21 2021 at 21:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250238630">said</a>:</p>
<blockquote>
<p>I thought first making <code>measure α</code> have a <code>smul</code> by <code>ennreal</code> would have been the natural route (didn't yet check if it works, though).</p>
</blockquote>
<p>I think this already exists actually!<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.module">docs#measure_theory.measure.module</a></p>



<a name="250238835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250238835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250238835">(Aug 21 2021 at 21:51)</a>:</h4>
<p>I had somehow failed to find it. (Found the <code>has_add</code> by <code>#check</code>, but not this one...)</p>



<a name="250239038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250239038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250239038">(Aug 21 2021 at 21:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250238687">said</a>:</p>
<blockquote>
<p>If the bijection is true, would make sense to use nnreal <code>vector_measure</code>s instead of creating a bundled <code>finite_measure</code> separately?  It sort of shifts the work around, right?  You have to do some work to prove the bijection (which provides the <code>coe</code> to <code>measure</code> and the proof that the <code>coe</code> satisfies <code>finite_measure</code>), but perhaps having an object which natively outputs <code>nnreal</code>s saves work in other places, and of course the algebraic structure comes for free from Jason's work.  I don't know which is better.</p>
<p>Hopefully the measure theory experts will weigh in.</p>
</blockquote>
<p>It indeed shifts the work around. I was relieved to get to (essentially) the <code>lintegral</code>s via the current route, since that is what I had previously used as a working starting point for portmanteau. Going through <code>vector_measure</code> looks like it could have its advantages, though. I will at least think about it, and also wait to see if someone notices other compelling reasons one way or another...</p>



<a name="250239044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250239044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250239044">(Aug 21 2021 at 21:56)</a>:</h4>
<p>I think using <code>vector_measure</code> is a good idea :) Creating a bijection should be easier than proving the api from scratch again. Also it can stress test the apis for <code>vector_measure</code> and maybe find some holes</p>



<a name="250239104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250239104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250239104">(Aug 21 2021 at 21:58)</a>:</h4>
<p>Is an ennreal-vector measure the same as a measure?  There is a statement along these lines in <span class="user-mention" data-user-id="243312">@Jason KY.</span>'s API, but only one direction of the putative bijection is provided.<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.to_ennreal_vector_measure">docs#measure_theory.measure.to_ennreal_vector_measure</a></p>



<a name="250239242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250239242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250239242">(Aug 21 2021 at 22:01)</a>:</h4>
<p>They should be the same, I think I just forgot the other direction</p>



<a name="250239304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250239304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250239304">(Aug 21 2021 at 22:02)</a>:</h4>
<p>In fact the other direction should be easier since we don't need to worry about what happens when the set is not measurable</p>



<a name="250239810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250239810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250239810">(Aug 21 2021 at 22:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measure.vector_measure</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">ennreal</span>

<span class="kn">namespace</span> <span class="n">measure_theory</span>

<span class="kn">open</span> <span class="n">measure</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">foo'</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector_measure</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">measurable_set</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="o">:=</span> <span class="n">v</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector_measure</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">measure.of_measurable</span> <span class="o">(</span><span class="n">foo'</span> <span class="n">v</span><span class="o">)</span> <span class="n">v.empty</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="n">hf₁</span> <span class="n">hf₂</span><span class="o">,</span> <span class="n">v.of_disjoint_Union_nat</span> <span class="n">hf₁</span> <span class="n">hf₂</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">vector_measure</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="bp">≃</span> <span class="n">measure</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">foo</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">to_ennreal_vector_measure</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">intros</span> <span class="n">v</span><span class="o">,</span>
      <span class="n">ext1</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">to_ennreal_vector_measure_apply_measurable</span> <span class="n">hs</span><span class="o">,</span> <span class="n">foo</span><span class="o">,</span> <span class="n">of_measurable_apply</span> <span class="n">_</span> <span class="n">hs</span><span class="o">],</span>
      <span class="n">refl</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">intros</span> <span class="n">μ</span><span class="o">,</span>
      <span class="n">ext1</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">foo</span><span class="o">,</span> <span class="n">of_measurable_apply</span> <span class="n">_</span> <span class="n">hs</span><span class="o">,</span> <span class="n">foo'</span><span class="o">,</span> <span class="n">to_ennreal_vector_measure_apply_measurable</span> <span class="n">hs</span><span class="o">],</span>
    <span class="kd">end</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">measure_theory</span>
</code></pre></div>



<a name="250241126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250241126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250241126">(Aug 21 2021 at 22:45)</a>:</h4>
<p>For the topology of weak convergence, the main thing that is needed is integration (it is the pairing from which the topology is induced). I did not immediately find integration w.r.t. <code>vector_measure</code>. Could you, Jason, briefly describe the status of that, please? I suppose integration in this generality will have to be closely related to the Bochner integral, except for functions with values in modules where the scalars are the vectors of the vector measure? (At least that's my quick thought, please correct me if I'm wrong!)</p>
<p>A key step for the topology is to show that every <code>μ : finite_measure(s)</code> determines a dual element of bounded continuous functions <code>α →ᵇ nnreal</code>, i.e., a continuous linear functional <code>(α →ᵇ nnreal) →L[nnreal] nnreal</code>. Is this doable with the <code>vector_measure</code> API?</p>



<a name="250241171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250241171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250241171">(Aug 21 2021 at 22:46)</a>:</h4>
<p>Although I wouldn't in any case be totally sure if the pairing to define the topology of weak convergence should be anything other than something very directly related to <code>lintegral</code>...</p>
<p>That is probably because I am not yet familiar with how <code>vector_measure</code> avoids requiring finite total mass (if it indeed does so). A worry I have is that for instance Riesz-Markov-Kakutani type results in non-compact spaces characterizing regular Borel measures as the dual of something might not be able to use <code>vector_measure</code>. (This worry could be entirely imagined, because I have not thought about it.) Of course those won't work directly with my currently proposed definitions either (finiteness of the measures is an assumption), but the needed refactor (changing test functions and the types of measures) looks superficially easier to me (possibly just because that's what I am more familiar with).</p>
<p>It is of course possible to just establish a bijection from <code>finite_measure(s)</code> to <code>vector_measure nnreal</code> and use it for certain properties (e.g. module), but not for the definition of the topology directly.</p>
<p>Anyways, I'll have to think more about this!</p>



<a name="250241855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250241855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250241855">(Aug 21 2021 at 23:01)</a>:</h4>
<p>From my understanding, in your original definition, you had to create a function from <code>finite_measures</code> to <code>measure</code> and then integrate wrt to the measure. I would think an implementation with <code>vector_measure</code> is the same, where we define a bijection between <code>vector_measure \a nnreal</code> and <code>measure</code> (with an instance that says the resulting measure is finite) and integrate wrt to that measure.</p>



<a name="250241986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250241986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250241986">(Aug 21 2021 at 23:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250241171">said</a>:</p>
<blockquote>
<p>That is probably because I am not yet familiar with how <code>vector_measure</code> avoids requiring finite total mass (if it indeed does so).</p>
</blockquote>
<p><code>vector_measure \a nnreal</code> will avoid requiring finiteness since  the vector measure will map sets to nnreals and so, will map <code>set.univ</code> to a finite value</p>



<a name="250242554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250242554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250242554">(Aug 21 2021 at 23:17)</a>:</h4>
<p>That finiteness would be automatic with <code>nnreal</code>-valued <code>vector_measures</code> I understand. My vague worry was about generalizations where the finiteness is not required, such as <a href="https://en.wikipedia.org/wiki/Riesz%E2%80%93Markov%E2%80%93Kakutani_representation_theorem">Riesz-Markov-Kakutani</a> characterizing positive linear functionals on compactly supported continuous functions on locally compact Hausdorff spaces as Radon measures. In these types of cases (similar in spirit to what is going on in the definition of the topology of weak convergence) using <code>lintegral</code> seems the most natural to me (but that might still be because I have no feeling for the internals of integration w.r.t. <code>vector_measure</code>).</p>



<a name="250242558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250242558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250242558">(Aug 21 2021 at 23:17)</a>:</h4>
<p>In any case, the main doubt I have for the present purpose is about integration w.r.t. <code>vector_measure</code>.</p>
<p>In the special cases of <code>nnreal</code>-vectors or <code>ennreal</code>-vectors one could indeed prove equivalence with <code>measure</code>s, finite or not, and then integrate. But if this is needed, it is an extra step. If one defines special kinds of measures (probability measures, finite measures, Radon measures, ...) as subtypes of measures, then passing to a <code>measure</code> appears strictly more innocent.</p>



<a name="250244369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244369">(Aug 22 2021 at 00:07)</a>:</h4>
<p>Slightly beside the main point, which I still feel is integration... (Althought admittedly other main points that I'm not very experienced with might be implementation and how the library fits together.)</p>
<p>I realized that very plausibly suitably regular <code>vector_measure</code>s also correspond to continuous linear maps from compactly supported continuous functions with some codomain to somewhere, via the appropriate integration theory. So the Riesz-Markov-Kakutani flavor might not be totally lost. The cases of real-valued ("signed") and complex-valued measures would certainly be quite relevant! But beyond those two cases my imagination fails me currently --- one definitely needs coherence between the codomain of the continuous functions and the codomain of the vector-valued measure so that a multiplication between them works (as well as completeness assumptions etc.). The multiplication issue is why I can basically only grasp the relevance up to vector-valuedness in <code>ℂ</code>, say.</p>
<p>Bourbaki must have thought about this, but I forget what they conclude <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span>.</p>



<a name="250244450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244450">(Aug 22 2021 at 00:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250242558">said</a>:</p>
<blockquote>
<p>In the special cases of <code>nnreal</code>-vectors or <code>ennreal</code>-vectors one could indeed prove equivalence with <code>measure</code>s, finite or not, and then integrate. But if this is needed, it is an extra step. If one defines special kinds of measures (probability measures, finite measures, Radon measures, ...) as subtypes of measures, then passing to a <code>measure</code> appears strictly more innocent.</p>
</blockquote>
<p>I think that getting a measure out to use in a proof using <code>lintegral</code> is not very awkward either way, whether one uses the monoid of nnreal-<code>vector_measure</code>s or the monoid of <code>finite_measure</code>s (where the latter is defined as a subtype of <code>measure</code>).  In either case one defines a coercion from the object to <code>measure</code>, and then integrates with respect to this coercion.</p>
<p>It's true that <strong>defining</strong> the coercion from nnreal-<code>vector_measure</code>s to measures is more difficult than defining the coercion from <code>finite_measure</code>.  The work gets shifted around, and this is a place where one theory is easier roads than the other.</p>



<a name="250244638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244638">(Aug 22 2021 at 00:14)</a>:</h4>
<p>One place where vector measures seem like they would be somewhat painful is, if (as Kalle hints at above) you want to talk about say regular/Radon/left-invariant/... measures, to have to phrase this about a property of the coercion of the vector_measure to a measure, rather than just as a property of the true "underlying measure".</p>



<a name="250244647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244647">(Aug 22 2021 at 00:14)</a>:</h4>
<p>I don't know, I hope the regular measure theory contributors will comment.</p>



<a name="250244715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244715">(Aug 22 2021 at 00:16)</a>:</h4>
<p>Yet another approach is to define <code>finite_measure</code> not as a <em>subtype</em> of <code>measure</code>, but as an <em>add_submonoid</em> (or <code>nnreal</code>-<em>submodule</em>) of <code>measure</code>.</p>



<a name="250244744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244744">(Aug 22 2021 at 00:18)</a>:</h4>
<p>Then at some later point you can take another add_submonoid, like left-invariant measures or regular measures (at least I assume those properties are preserved under addition ...), and consider measures with both properties by taking the intersections of these two add_submonoids.</p>



<a name="250244797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250244797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250244797">(Aug 22 2021 at 00:18)</a>:</h4>
<p>This is how <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.Lp">docs#measure_theory.Lp</a> is done, each Lp space is an add_subgroup of the add_group of almost-everywhere-equal functions.  So in principle (though I don't think anyone's tried it yet) it should be easy to talk about L1 intersect L2.</p>



<a name="250245602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250245602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250245602">(Aug 22 2021 at 00:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250244715">said</a>:</p>
<blockquote>
<p>Yet another approach is to define <code>finite_measure</code> not as a <em>subtype</em> of <code>measure</code>, but as an <em>add_submonoid</em> (or <code>nnreal</code>-<em>submodule</em>) of <code>measure</code>.</p>
</blockquote>
<p>The advantages of this seem nice  (I especially like that it is easy to write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>1</mn></msup><mo stretchy="false">(</mo><mi>μ</mi><mo stretchy="false">)</mo><mo>∩</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>μ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L^1(\mu) \cap L^2(\mu)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">μ</span><span class="mclose">)</span></span></span></span> in the analogous <code>Lp</code> implementation).</p>
<p>But <code>probability_measure(s)</code> would not be an <code>additive_submonoid</code> or anything. They have convex structure, but that's about it. Since this is my main current direction, I'm biased towards implementations that are inclusive of probability measures <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>.</p>



<a name="250245986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250245986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250245986">(Aug 22 2021 at 00:47)</a>:</h4>
<p>Yes, and another advantage of this is that it's efficient.  Very similar to your current implementation but gets rid of some of the boilerplate.  I believe the main disadvantage is that projection notation won't work, i.e. if you define <code>finite_measure</code> as a submodule/add_submonoid, then given <code>μ : finite_measure X</code>, you can't refer to <code>μ.useful_lemma_about_finite_measures</code>.</p>



<a name="250246083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250246083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250246083">(Aug 22 2021 at 00:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373986">Kalle Kytölä</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence/near/250245602">said</a>:</p>
<blockquote>
<p>But <code>probability_measure(s)</code> would not be an <code>additive_submonoid</code> or anything. They have convex structure, but that's about it. Since this is my main current direction, I'm biased towards implementations that are inclusive of probability measures <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>.</p>
</blockquote>
<p>This is an issue though (one approach which preserves the possibility of taking intersections among various sub-objects of <code>measure X</code> neatly is to make <code>probability_measure</code> a set in <code>measure X</code> rather than a subtype of it).</p>



<a name="250246321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250246321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250246321">(Aug 22 2021 at 00:55)</a>:</h4>
<p>Actually, having <code>finite_measure(s)</code> be an <code>nnreal</code> module (which it obviously should eventually be, unlike probability measures) is somewhat orthogonal to the definition of the topology. For the definition of the topology I only want that every <code>(μ : finite_measures α)</code> gives rise to an element of <code>(α →ᵇ ℝ≥0) →L[ℝ≥0] ℝ≥0</code>. It just seemed natural to try to state that we have a linear mapping</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">finite_measures</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">]</span> <span class="o">((</span><span class="n">α</span> <span class="bp">→ᵇ</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">]</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>but this is a bit of an aside.</p>



<a name="250246918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250246918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250246918">(Aug 22 2021 at 01:08)</a>:</h4>
<p>To summarize: here are three ways to implement bundled finite measures and probability measures on a measurable space <code>X</code>.  We want them bundled so they can hold a topology; the former will also hold a <code>(ℝ≥0)</code>-module structure.</p>
<p>A. (Kalle's current implementation): as subtypes of <code>measure X</code></p>
<p>B. as a <code>submodule (ℝ≥0) (measure X)</code> (for finite measures) and a <code>set (measure X)</code> (for probability measures), coerced to types when we want to put a topology on them</p>
<p>C. as <code>vector_measure (ℝ≥0) X</code> (for finite measures) and a subtype of that (for probability measures), with (with a bit of work) a coercion defined from this to <code>measure X</code>.</p>



<a name="250247086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250247086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250247086">(Aug 22 2021 at 01:12)</a>:</h4>
<p>Separately: should we rename the current typeclasses <code>finite_measure</code> and <code>probability_measure</code> to <code>is_finite(_measure)</code> and <code>is_probability(_measure)</code>, freeing the former names for the bundled version (whatever implementation is chosen).  Floris, Kalle and I say, yes!</p>



<a name="250387471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250387471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250387471">(Aug 23 2021 at 17:56)</a>:</h4>
<p>I made <a href="https://github.com/leanprover-community/mathlib/issues/8831">#8831</a> for the renaming.</p>



<a name="250401238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250401238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250401238">(Aug 23 2021 at 19:40)</a>:</h4>
<p>I'd vote for A (subtype of measures). My reason is that there is also a topology on (possibly infinite) Radon measures, defined as weak-* convergence with respect to compactly supported continuous functions. The restriction of this topology to probability measures is the one we are discussing here, which would therefore naturally arise as a subtype topology. Note that this only makes sense on locally compact spaces, while convergence of probability measures is relevant in the broader setting of polish spaces, so I am not advocating implementing this litterally, but I am just taking this as a hint that A might be a good idea.</p>



<a name="250401787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250401787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250401787">(Aug 23 2021 at 19:44)</a>:</h4>
<p>Do you think <code>finite_measure X</code> and <code>probability_measure X</code> should both be subtypes of <code>measure X</code>, or should the latter be a subtype of the former?</p>



<a name="250402499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250402499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250402499">(Aug 23 2021 at 19:50)</a>:</h4>
<p>I'd probably let both of them be subtypes of <code>measure X</code> just to minimize the level of nesting, but I don't have a strong opinion there.</p>



<a name="250402722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250402722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250402722">(Aug 23 2021 at 19:53)</a>:</h4>
<p>For the topology, it is clearly better to have probability measures as a subtype of finite measures, but even when they're both subtypes of <code>measure X</code> one could deduce the topology on probability measures from the topology on finite measures by saying it is the topology induced by the coercion from the former to the latter.</p>



<a name="250406534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250406534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250406534">(Aug 23 2021 at 20:25)</a>:</h4>
<p>Thank you Sébastien for the comments!</p>



<a name="250406594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250406594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250406594">(Aug 23 2021 at 20:25)</a>:</h4>
<p>I'm happy, my (mild) preference is also to have  both<code>finite_measure</code> and <code>probability_measure</code> subtypes of <code>measure</code>.</p>
<p>The alternative of having <code>probability_measure</code> a subtype of <code>finite_measure</code> would have looked quite reasonable, too, except that since there will presumably naturally be at least a few more different subtypes of measures, it might be that realizing all "inclusions" among them as subtypes would be too much. On the other hand, I probably didn't yet grasp the full advantages of getting the subtype topology vs. having the induced topology from a coercion... (I suppose some part of the API would come for free, but I don't see how significant that would be, since the <code>embedding</code> is obtained after just a few lemmas.)</p>



<a name="250406840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250406840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250406840">(Aug 23 2021 at 20:27)</a>:</h4>
<p>And thank you Heather for the PR improving the naming!</p>



<a name="250407104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250407104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250407104">(Aug 23 2021 at 20:29)</a>:</h4>
<p>There is one issue that I didn't perhaps treat with its due seriousness yet. It may even have become more relevant now that with Heather's new PR, the naming will be changed, and these types will be given the very nice names <code>finite_measure</code> and <code>probability_measure</code>. </p>
<p>The issue is that the topology of weak convergence is just one of the possible topologies on <code>finite_measure</code> and <code>probability_measure</code>. In particular, in view of the Riesz-Markov-Kakutani -type results, realizing (suitable) measures as the dual of <code>bounded_continuous_function</code>, the topology coming from the <em>total variation distance</em> might be seen as more canonical. Under reasonable regularity assumptions, the total variation distance coincides with the metric coming from the dual norm...</p>



<a name="250407231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250407231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250407231">(Aug 23 2021 at 20:30)</a>:</h4>
<p>For this reason, the topology <code>instance</code> may be too generous for the topology of weak convergence of measures. Should we instead define <code>finite_measures</code> and <code>probability_measures</code> without topology (or even with the "total variation metric" /  "norm topology") and create a type synonym that has the topology of weak convergence?</p>



<a name="250407368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250407368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250407368">(Aug 23 2021 at 20:31)</a>:</h4>
<p>I must say that I care the most about the topology of weak convergence (I'd assume most probabilists do, at least in mathematical statistical physics and constructive field theory).</p>
<p>I think for <code>finite_measure</code> I would not mind having the total variation as the default instance, but I would be a bit sad if <code>probability_measure</code> had a default topology other than that of "convergence in distribution" / "convergence in law", i.e., the weak convergence of measures.</p>



<a name="250407583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238337%20Weak%20convergence/near/250407583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238337.20Weak.20convergence.html#250407583">(Aug 23 2021 at 20:33)</a>:</h4>
<p>Normally, the first topology to be defined is put on the main type, and the other ones are put on type synonyms :-) So I'd also go for convergence in distribution as the default topology. (My first sentence is only half a joke: usually, one goes first for the most important stuff, so it's not surprising the first topology we define is also the most useful one).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
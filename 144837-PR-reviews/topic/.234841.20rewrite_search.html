---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.234841.20rewrite_search.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html">#4841 rewrite_search</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215146749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/215146749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#215146749">(Oct 30 2020 at 20:29)</a>:</h4>
<p>I opened a pull request for the rewrite_search tactic. This is a feature that a number of people like <span class="user-mention" data-user-id="110087">@Scott Morrison</span> and <span class="user-mention" data-user-id="112680">@Johan Commelin</span> worked on for a while in a branch. This pull request is kind of a subset of about a quarter of the functionality of that branch; some of the configuration flags are removed and data structures are simplified. Scott suggested this approach of getting a subset merged into master so here's my take. Basically the idea is that it automatically searches for chains of rewrites to prove an equality goal.</p>



<a name="215176922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/215176922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#215176922">(Oct 31 2020 at 06:14)</a>:</h4>
<p><span class="user-mention" data-user-id="238605">@Kevin Lacker</span> Thank you so much for reviving this! I left a ton of minor cosmetic comments. Someone with more experience in tactic writing should review the content.</p>



<a name="218901286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218901286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218901286">(Dec 04 2020 at 22:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> you had questions about the performance of <code>rb_map string</code> vs <code>rb_map expr</code> and I thought it would be easier to follow up here. I don't have a fancy performance test, I am just timing how long it takes to recompile the one file of unit tests. Originally I didn't realize that <code>rb_map expr</code> would work at all, because I assumed that &lt; wasn't defined on expressions. I still don't really know where lean is getting the comparator from. Is that something that should be just as fast as string comparison? I was assuming that string comparisons would be fast because the vm manages to do those in C++, and that other comparisons were probably not fast, but I am not too expert on this.</p>



<a name="218905880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218905880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218905880">(Dec 04 2020 at 23:50)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/expr.lt">docs#expr.lt</a> says Compares expressions, ignoring binder names, and sorting by hash, its defined in C++</p>



<a name="218906090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906090">(Dec 04 2020 at 23:54)</a>:</h4>
<p>hmmm. it doesn't seem like it should be drastically slower than a string comparison</p>



<a name="218906115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906115">(Dec 04 2020 at 23:55)</a>:</h4>
<p>or at least, it seems like the time should still be dominated by lean interactions and not by the c++ code</p>



<a name="218906194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906194">(Dec 04 2020 at 23:56)</a>:</h4>
<p>but, it's certainly slower on this recompilation. i'll try profiling and seeing if anything else becomes apparent</p>



<a name="218906229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906229">(Dec 04 2020 at 23:57)</a>:</h4>
<p>yeah if the hash is created at expression creation time then it should really be faster</p>



<a name="218906277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906277">(Dec 04 2020 at 23:58)</a>:</h4>
<p>So I don't have time tonight to experiment, but yes, my instinct was that <code>expr.lt</code> should be faster than <code>pp</code> + string comparison. <code>expr.lt</code> is used a lot in many places, it isn't slow. And <code>pp</code> needs to traverse the whole <code>expr</code>.</p>



<a name="218906287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906287">(Dec 04 2020 at 23:58)</a>:</h4>
<p>maybe this actually is short circuiting with some expressions that have pp equality but not hash equality</p>



<a name="218906293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906293">(Dec 04 2020 at 23:58)</a>:</h4>
<p>this isn't too intertwined with the code, fortunately, this map is only directly accessed in a few places</p>



<a name="218906488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906488">(Dec 05 2020 at 00:02)</a>:</h4>
<p>Right, the possible downside to <code>expr.lt</code> is that it's a very strict comparison, it doesn't even take alpha or beta equivalence into account. In particular, if you have the "same" expr with different type class instances or an unreduced lambda application, it won't match.</p>



<a name="218906496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906496">(Dec 05 2020 at 00:02)</a>:</h4>
<p>But "pp equivalence" is an inherently hacky notion of equivalence.</p>



<a name="218906546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906546">(Dec 05 2020 at 00:03)</a>:</h4>
<p>I didn't even look, does the tactic specify pp options somehow? Or can you change the behavior of <code>rewrite_search</code> by setting <code>pp.implicit</code> to true before calling it?</p>



<a name="218906573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906573">(Dec 05 2020 at 00:03)</a>:</h4>
<p>no, it doesn't specify pp options</p>



<a name="218906650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906650">(Dec 05 2020 at 00:05)</a>:</h4>
<p>Ideally things would be matched up to defeq with a low reducibility setting. This isn't too expensive. But doing this to match keys in a map forces O(n) lookups.</p>



<a name="218906682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906682">(Dec 05 2020 at 00:06)</a>:</h4>
<p><code>linarith</code>, <code>ring</code>, etc bite the bullet. But I think <code>rewrite_search</code> does way way more lookups.</p>



<a name="218906861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/218906861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#218906861">(Dec 05 2020 at 00:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/218906287">said</a>:</p>
<blockquote>
<p>maybe this actually is short circuiting with some expressions that have pp equality but not hash equality</p>
</blockquote>
<p>This would be interesting to know and pretty easy to check, just print the full exprs (or just whether they're equal) when you find a match. I wonder how often they're different.</p>



<a name="219113310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219113310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219113310">(Dec 07 2020 at 17:50)</a>:</h4>
<p>OK the difference comes up when rewrite_search is solving this problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constants</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℚ</span>

<span class="kd">lemma</span> <span class="n">test_algebra</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">))</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rewrite_search</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">left_distrib</span><span class="o">,</span> <span class="n">right_distrib</span><span class="o">]</span>
</code></pre></div>
<p>The graph search ends up with two nodes that both <code>pp</code> to <code>a * (b * d) + a * (c * d)</code>, but they don't compare to equal</p>



<a name="219113922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219113922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219113922">(Dec 07 2020 at 17:54)</a>:</h4>
<p>it reproduces with similar arithmetic too: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">simpler_test</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rewrite_search</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">]</span>
</code></pre></div>
<p>some sort of equality notion is not caught by the straight <code>=</code> operator there. I don't know enough about the forms of equivalence to immediately intuit what's going on here, though</p>



<a name="219114014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219114014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219114014">(Dec 07 2020 at 17:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> any idea what this could be?</p>



<a name="219114100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219114100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219114100">(Dec 07 2020 at 17:56)</a>:</h4>
<p>curiously, it <em>does</em> eventually find a solution! it just takes much longer</p>



<a name="219114120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219114120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219114120">(Dec 07 2020 at 17:56)</a>:</h4>
<p>(when requiring exact equality rather than pp)</p>



<a name="219127661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219127661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219127661">(Dec 07 2020 at 19:37)</a>:</h4>
<p>It's almost certainly a difference in type class instances. The expressions are definitionally equal but take different routes to finding <code>has_add rat</code> or something like that. The <code>pp</code> version succeeds on this example when it thinks the two terms match, right?</p>



<a name="219127901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219127901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219127901">(Dec 07 2020 at 19:39)</a>:</h4>
<p>yeah</p>



<a name="219127913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219127913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219127913">(Dec 07 2020 at 19:39)</a>:</h4>
<p>Ideally we'd have some kind of hash on <code>expr</code> that ignores type class arguments. It could be implemented but I don't know how bad the performance hit would be.</p>



<a name="219128043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128043">(Dec 07 2020 at 19:40)</a>:</h4>
<p>I really think that the <code>pp</code> version is going to hit a lot of false positives. Numerals and coercions are just two common examples where different things pretty print the same.</p>



<a name="219128080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128080">(Dec 07 2020 at 19:41)</a>:</h4>
<p>that's true, i mean this tactic is going to fail lots of the time</p>



<a name="219128114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128114">(Dec 07 2020 at 19:41)</a>:</h4>
<p>what exactly is a "type class argument"</p>



<a name="219128195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128195">(Dec 07 2020 at 19:42)</a>:</h4>
<p>my heuristic here is, if I have to write c++ to make it fast, then I want to punt until lean 4 exists</p>



<a name="219128380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128380">(Dec 07 2020 at 19:43)</a>:</h4>
<p><code>has_add.add : Pi {T : Type}, [has_add T] -&gt; T -&gt; T -&gt; T</code> infers the argument of type <code>has_add T</code> using type class resolution. That's the "type class argument."</p>



<a name="219128532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128532">(Dec 07 2020 at 19:44)</a>:</h4>
<p>The idea being, it's generally (not always) safe to ignore those when comparing terms because there's usually one unique instance up to defeq.</p>



<a name="219128596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128596">(Dec 07 2020 at 19:45)</a>:</h4>
<p>Which isn't true for regular implicit arguments, which are also ignored by <code>pp</code>.</p>



<a name="219128667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128667">(Dec 07 2020 at 19:45)</a>:</h4>
<p>so if everything mentioned in this problem is just a rational constant, why would anything be type-class-resolving differently</p>



<a name="219128936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128936">(Dec 07 2020 at 19:47)</a>:</h4>
<p>Who knows what instances appear after you're rewritten with some generic lemmas. You can <code>set_option pp.implicit true</code> to see how those expressions differ.</p>



<a name="219128994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219128994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219128994">(Dec 07 2020 at 19:48)</a>:</h4>
<p>Oh, wait, maybe you can't, changing the <code>pp</code> options will probably change the behavior of <code>rewrite_search</code> right now. Which is another issue.</p>



<a name="219129034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129034">(Dec 07 2020 at 19:48)</a>:</h4>
<p>it should be the single lemma <code>add_assoc</code> here</p>



<a name="219129141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129141">(Dec 07 2020 at 19:48)</a>:</h4>
<p>well, i can add it to figure things out i believe</p>



<a name="219129238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129238">(Dec 07 2020 at 19:49)</a>:</h4>
<p>mm, i guess i can't set_option from within a tactic? hmm</p>



<a name="219129521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129521">(Dec 07 2020 at 19:51)</a>:</h4>
<p>is there a way to call <code>pp</code> with a fixed set of options, rather than paying attention to the global <code>set_option</code> stuff</p>



<a name="219129629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129629">(Dec 07 2020 at 19:52)</a>:</h4>
<p>For example, see the change in the <code>has_add nat</code> instance here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">open</span> <span class="n">tactic</span>
<span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">pp.notation</span> <span class="n">false</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219129708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129708">(Dec 07 2020 at 19:53)</a>:</h4>
<p>There's <a href="https://leanprover-community.github.io/mathlib_docs/find/pp_using">docs#pp_using</a></p>



<a name="219129722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129722">(Dec 07 2020 at 19:53)</a>:</h4>
<p>Not exactly sure how it works.</p>



<a name="219129946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129946">(Dec 07 2020 at 19:55)</a>:</h4>
<p>ugh, what a mess</p>



<a name="219129985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219129985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219129985">(Dec 07 2020 at 19:55)</a>:</h4>
<p>so the rewrite is doing something like, replacing the addition with "we know nat has addition because it's a semigroup" but deduping only happens later</p>



<a name="219130090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130090">(Dec 07 2020 at 19:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> do you have any thoughts about this? It's not unrelated to what we did in <code>ring</code> and <code>linarith</code> parsing. Basically, if you want to match exprs up to defeq you can't use <code>rb_map</code> or any hash-based method, each lookup has to be O(n). Not a problem in those cases because it's outweighed by the rest of the tactic, but here there are way more lookups happening.</p>



<a name="219130181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130181">(Dec 07 2020 at 19:57)</a>:</h4>
<p>How important is it to work up to defeq?</p>



<a name="219130185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130185">(Dec 07 2020 at 19:57)</a>:</h4>
<p>rw doesn't</p>



<a name="219130272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130272">(Dec 07 2020 at 19:58)</a>:</h4>
<p>Syntactic eq is too strong, as in Kevin's example above. It's not for the sake of rewrite but for figuring out when to stop the algorithm -- you're working on a rhs and a lhs and want to stop when they're defeq.</p>



<a name="219130327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130327">(Dec 07 2020 at 19:58)</a>:</h4>
<p>if I understand correctly, if you have statement a and you want to prove statement b and theorem c does it, you can write <code>by rw c</code> because somewhere in there, there's a defeq happening</p>



<a name="219130335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130335">(Dec 07 2020 at 19:58)</a>:</h4>
<p>But you have many branches on each side and need to check against all of htem.</p>



<a name="219130396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130396">(Dec 07 2020 at 19:59)</a>:</h4>
<p>You can save the defeq test for when it looks pretty close?</p>



<a name="219130460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130460">(Dec 07 2020 at 19:59)</a>:</h4>
<p>"looks pretty close" by what measure? pp equality?</p>



<a name="219130474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130474">(Dec 07 2020 at 20:00)</a>:</h4>
<p>sure</p>



<a name="219130588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130588">(Dec 07 2020 at 20:00)</a>:</h4>
<p>That's not so different from what it's doing now (with different failure behavior when defeq fails I guess) but it feels really hacky.</p>



<a name="219130602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130602">(Dec 07 2020 at 20:00)</a>:</h4>
<p>if that's what rewrite search is using to explore the space then it's already available</p>



<a name="219130630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130630">(Dec 07 2020 at 20:01)</a>:</h4>
<p>what's already available</p>



<a name="219130680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130680">(Dec 07 2020 at 20:01)</a>:</h4>
<p>If you have some other metric like tree diffing that would work too</p>



<a name="219130716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130716">(Dec 07 2020 at 20:01)</a>:</h4>
<p>I'm sure the ML folks have thought about this problem</p>



<a name="219130746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130746">(Dec 07 2020 at 20:02)</a>:</h4>
<p>This version of rewrite_search doesn't use string edit distance like the one Scott showed years ago. AFAIK this comparison is the only place where string comparisons would be used.</p>



<a name="219130807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130807">(Dec 07 2020 at 20:02)</a>:</h4>
<p>what does it use?</p>



<a name="219130837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130837">(Dec 07 2020 at 20:02)</a>:</h4>
<p>the ML folks do a lot of mapping things onto strings, and then reimporting the eventual proof into the theorem prover to double check that the string conversion worked ok</p>



<a name="219130843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130843">(Dec 07 2020 at 20:02)</a>:</h4>
<p>"Do all the rewrites until the two sides are the same"</p>



<a name="219130873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130873">(Dec 07 2020 at 20:02)</a>:</h4>
<p>so no guidance at all?</p>



<a name="219130875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130875">(Dec 07 2020 at 20:02)</a>:</h4>
<p>for what it's worth, the PR used to use edit distance. it's just faster to scrap that</p>



<a name="219130969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130969">(Dec 07 2020 at 20:03)</a>:</h4>
<p>it's just breadth-first searching from both LHS and RHS</p>



<a name="219130982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219130982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219130982">(Dec 07 2020 at 20:03)</a>:</h4>
<p>from what I recall of Scott's original version, he thought that was pretty important on the larger examples because of the exponential growth of possible moves</p>



<a name="219131076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131076">(Dec 07 2020 at 20:04)</a>:</h4>
<p>I would be happy to have an example where this was the case</p>



<a name="219131100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131100">(Dec 07 2020 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219130982">said</a>:</p>
<blockquote>
<p>from what I recall of Scott's original version, he thought that was pretty important on the larger examples because of the exponential growth of possible moves</p>
</blockquote>
<p>Which was my broader comment reviewing the PR, I don't really see how this scales, but I'm trying to work with what we have.</p>



<a name="219131483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131483">(Dec 07 2020 at 20:07)</a>:</h4>
<p>My impression is, with the current architecture of rb_maps using pp equality, it's hard to recover and continue from a false match.</p>



<a name="219131548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131548">(Dec 07 2020 at 20:07)</a>:</h4>
<p>It is possible to code up a comparison that ignores implicit args but that sounds like a lot of pure lean processing, it may be worse than just calling defeq all the time</p>



<a name="219131598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131598">(Dec 07 2020 at 20:08)</a>:</h4>
<p>I think it's hard, but I also don't have a any example of a false match, and it's far more common to simply fail because the search doesn't find anything</p>



<a name="219131696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131696">(Dec 07 2020 at 20:09)</a>:</h4>
<p>this PR is based on Scott's original branch, so I originally had all the edit distance code. the problem is, lean string processing is so slow, it ends up spending most of the time calculating string diffs</p>



<a name="219131741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131741">(Dec 07 2020 at 20:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131483">said</a>:</p>
<blockquote>
<p>My impression is, with the current architecture of rb_maps using pp equality, it's hard to recover and continue from a false match.</p>
</blockquote>
<p>Hashmaps already face this issue. The solution is to store all putatively-equal expressions, and linear search through them with the more accurate test</p>



<a name="219131826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131826">(Dec 07 2020 at 20:10)</a>:</h4>
<p>this is a solvable problem - stick any diffing logic in C++, use a data structure like a priority queue - but I dont' want to mess around with c++ components pre lean 4</p>



<a name="219131837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131837">(Dec 07 2020 at 20:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131548">said</a>:</p>
<blockquote>
<p>It is possible to code up a comparison that ignores implicit args but that sounds like a lot of pure lean processing, it may be worse than just calling defeq all the time</p>
</blockquote>
<p>But it isn't just the cost of calling defeq all the time, it's O(n) defeqs vs O(log n) hash comparisons. It will definitely make things scale even worse.</p>



<a name="219131884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131884">(Dec 07 2020 at 20:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131741">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131483">said</a>:</p>
<blockquote>
<p>My impression is, with the current architecture of rb_maps using pp equality, it's hard to recover and continue from a false match.</p>
</blockquote>
<p>Hashmaps already face this issue. The solution is to store all putatively-equal expressions, and linear search through them with the more accurate test</p>
</blockquote>
<p>This is maybe the "reliable and doable" solution.</p>



<a name="219131934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219131934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219131934">(Dec 07 2020 at 20:11)</a>:</h4>
<p>Use pp equality as a first pass and then check defeq to confirm, then you can keep going if you hit a false positive match.</p>



<a name="219132043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132043">(Dec 07 2020 at 20:12)</a>:</h4>
<p>I promise that when people start using this they're going to find examples and come to Zulip saying "why did rewrite_search fail here?"</p>



<a name="219132064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132064">(Dec 07 2020 at 20:12)</a>:</h4>
<p>I would be so excited to respond to that complaint in zulip</p>



<a name="219132094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132094">(Dec 07 2020 at 20:12)</a>:</h4>
<p>If there's not a good story to tell in response, there will be a neverending stream of this question.</p>



<a name="219132114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132114">(Dec 07 2020 at 20:13)</a>:</h4>
<p>right now I don't have any examples of this problem happening though</p>



<a name="219132152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132152">(Dec 07 2020 at 20:13)</a>:</h4>
<p>how about, we get this code in, and then once one person runs into this problem in the wild i'll make it fail over to defeq</p>



<a name="219132289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132289">(Dec 07 2020 at 20:14)</a>:</h4>
<p>This is why SMT folks care about completeness of the search algorithm. It's not because completeness itself is that great but rather when you throw heuristics together it fails in weird ways and they have to deal with questions they don't want to answer</p>



<a name="219132411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132411">(Dec 07 2020 at 20:16)</a>:</h4>
<p>If you can add something that detects when the mismatch happens, I'm willing to consider it!</p>



<a name="219132503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132503">(Dec 07 2020 at 20:16)</a>:</h4>
<p>And gives a reasonable error message, that is.</p>



<a name="219132533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132533">(Dec 07 2020 at 20:17)</a>:</h4>
<p>is there a sane way to construct an example where this happens, that two expressions are pp equal but not defeq?</p>



<a name="219132564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132564">(Dec 07 2020 at 20:17)</a>:</h4>
<p>the only way I could think of was to create some new sort of object that had this property</p>



<a name="219132659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132659">(Dec 07 2020 at 20:18)</a>:</h4>
<p>but, maybe there's some normal situation where this happens</p>



<a name="219132716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132716">(Dec 07 2020 at 20:18)</a>:</h4>
<p>It comes up routinely in questions from users</p>



<a name="219132749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132749">(Dec 07 2020 at 20:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails:  f ↑0 = f ↑0</span>
</code></pre></div>



<a name="219132770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132770">(Dec 07 2020 at 20:19)</a>:</h4>
<p>usually they rewrote their goal by some lemma and got a non-canonical instance</p>



<a name="219132781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132781">(Dec 07 2020 at 20:19)</a>:</h4>
<p>or they unfolded something they shouldn't have</p>



<a name="219132814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132814">(Dec 07 2020 at 20:19)</a>:</h4>
<p>are those functions supposed to be equal, or not equal</p>



<a name="219132902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132902">(Dec 07 2020 at 20:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="c1">-- succeeds</span>
</code></pre></div>



<a name="219132908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132908">(Dec 07 2020 at 20:20)</a>:</h4>
<p>the two coerced zeros are equal but not defeq</p>



<a name="219132990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219132990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219132990">(Dec 07 2020 at 20:21)</a>:</h4>
<p>I'd expect rewrite_search to be able to prove this goal (with the right lemmas in scope anyway)</p>



<a name="219133013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219133013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219133013">(Dec 07 2020 at 20:21)</a>:</h4>
<p>it would be great if you could turn off pretty printing just for coe, as that's going to be a big contributor to pp false positives</p>



<a name="219133398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219133398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219133398">(Dec 07 2020 at 20:24)</a>:</h4>
<p>it's definitely a hack. hmm. maybe i should write essentially a custom pp here, just to map things onto a string in such a way that string equality is expected to be defeq. how do I "get at the parts" of an expr? is there a reasonable way to write lean code that does this without like adding some custom thing to every type</p>



<a name="219133959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219133959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219133959">(Dec 07 2020 at 20:29)</a>:</h4>
<p>I'd skip the strings completely. Yes, you can deconstruct an expr, it's an inductive type (<a href="https://leanprover-community.github.io/mathlib_docs/find/expr/src">src#expr</a>). You can tell which arguments are type class arguments using the <a href="https://leanprover-community.github.io/mathlib_docs/find/binder_info">docs#binder_info</a> argument to <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.pi/src">src#expr.pi</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.lam/src">src#expr.lam</a> . Doing this from scratch is just slightly less than straightforward I think. Not sure off the top of my head if there's an api in mathlib to help.</p>



<a name="219134018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134018">(Dec 07 2020 at 20:30)</a>:</h4>
<p>You can just strip the type class arguments out completely and construct a (badly typed) expr, then hash that.</p>



<a name="219134090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134090">(Dec 07 2020 at 20:30)</a>:</h4>
<p>what about turning it into a pexpr?</p>



<a name="219134102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134102">(Dec 07 2020 at 20:30)</a>:</h4>
<p>is that a thing?</p>



<a name="219134211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134211">(Dec 07 2020 at 20:31)</a>:</h4>
<p>You can't (easily) deelaborate, no...</p>



<a name="219134252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134252">(Dec 07 2020 at 20:31)</a>:</h4>
<p>A badly typed expr and a pexpr are the same thing.</p>



<a name="219134262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134262">(Dec 07 2020 at 20:31)</a>:</h4>
<p>the only reason I'd use a string is that AFAICT I can't efficiently use a regular int32 in lean. so if I want something to be the key of a hash table, the best thing is a string</p>



<a name="219134389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134389">(Dec 07 2020 at 20:32)</a>:</h4>
<p><code>lemma test_pp_heuristic : idf (0 : ℕ) = idf (0 : ℚ) := by rewrite_search [nat.cast_zero, rat.cast_zero]</code> just works</p>



<a name="219134410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134410">(Dec 07 2020 at 20:32)</a>:</h4>
<p>I need a better example that does not work with the status quo</p>



<a name="219134524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219134524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219134524">(Dec 07 2020 at 20:33)</a>:</h4>
<p>what about, two expressions that are <em>not</em> equal, but their <code>pp</code> is equal. that would bork the existing algorithm. is there some way to naturally construct examples of that?</p>



<a name="219135031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135031">(Dec 07 2020 at 20:37)</a>:</h4>
<p>Okay, I don't know why that succeeds based on my understanding of rewrite_search from the review, but:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>shouldn't be provable.</p>



<a name="219135149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135149">(Dec 07 2020 at 20:38)</a>:</h4>
<p>lol lean has too many coercions</p>



<a name="219135257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135257">(Dec 07 2020 at 20:39)</a>:</h4>
<p>There's a coercion from <code>fin n</code> to nat? Is that because it's now a subtype or was it always there?</p>



<a name="219135420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135420">(Dec 07 2020 at 20:40)</a>:</h4>
<p>It has always been there but it was made the recommended idiom around july</p>



<a name="219135437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135437">(Dec 07 2020 at 20:40)</a>:</h4>
<p>over things like fin.val</p>



<a name="219135470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135470">(Dec 07 2020 at 20:41)</a>:</h4>
<p>it is a subtype, so it's not unreasonable</p>



<a name="219135569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135569">(Dec 07 2020 at 20:42)</a>:</h4>
<p>in fact in retrospect it seems good that we have <code>fin</code> and <code>zmod</code> as separate things since they have different algebraic roles</p>



<a name="219135637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135637">(Dec 07 2020 at 20:42)</a>:</h4>
<p>how does one actually prove that? (I dont know what <code>fin</code> is, sorry)</p>



<a name="219135649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135649">(Dec 07 2020 at 20:42)</a>:</h4>
<p><code>fin n</code> is the set of numbers less than <code>n</code></p>



<a name="219135676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135676">(Dec 07 2020 at 20:43)</a>:</h4>
<p>how is 2 in <code>fin 1</code> then</p>



<a name="219135677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135677">(Dec 07 2020 at 20:43)</a>:</h4>
<p><code>fin 1 = {0}</code> so it's not hard to figure out what <code>2 : fin 1</code> is</p>



<a name="219135738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135738">(Dec 07 2020 at 20:43)</a>:</h4>
<p>I will give you one guess :)</p>



<a name="219135767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135767">(Dec 07 2020 at 20:43)</a>:</h4>
<p>failures get turned into zeros like 1 - 2 ?</p>



<a name="219135844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135844">(Dec 07 2020 at 20:44)</a>:</h4>
<p>it's not actually failure, it's wraparound</p>



<a name="219135849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135849">(Dec 07 2020 at 20:44)</a>:</h4>
<p>either that or it works like Z_2</p>



<a name="219135874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135874">(Dec 07 2020 at 20:44)</a>:</h4>
<p>er, like Z_1</p>



<a name="219135887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135887">(Dec 07 2020 at 20:44)</a>:</h4>
<p>ok, I got it on the third guess</p>



<a name="219135951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219135951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219135951">(Dec 07 2020 at 20:45)</a>:</h4>
<p>There is no way the way the lean parser works right now to make <code>3 : fin 5</code> ok but not <code>7 : fin 5</code></p>



<a name="219136032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136032">(Dec 07 2020 at 20:46)</a>:</h4>
<p>so addition just wraps around, making it almost <code>zmod n</code></p>



<a name="219136063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136063">(Dec 07 2020 at 20:46)</a>:</h4>
<p>ok great so <code>(2 : fin 1)</code> should <code>pp</code> to <code>2</code> but actually it's zero</p>



<a name="219136080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136080">(Dec 07 2020 at 20:46)</a>:</h4>
<p>yes</p>



<a name="219136173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136173">(Dec 07 2020 at 20:47)</a>:</h4>
<p>it's not like we can evaluate it though, 2 is a perfectly good representation for that number</p>



<a name="219136529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136529">(Dec 07 2020 at 20:50)</a>:</h4>
<p>Here's another (contrived) example that doesn't use coercions.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">classical.prop_decidable</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">g</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="k">if</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">ℕ</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- g 0 = g 0</span>
</code></pre></div>



<a name="219136774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136774">(Dec 07 2020 at 20:53)</a>:</h4>
<p>OK here is something that fails now but could succeed if it continued the search:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test_pp_heuristic</span> <span class="o">:</span> <span class="n">idf</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">idf</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rewrite_search</span> <span class="o">[</span><span class="n">rat.cast_zero</span><span class="o">,</span> <span class="n">nat.cast_zero</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">]</span>
</code></pre></div>
<p>I think the reason the previous one didn't work is that the algorithm doesn't actually test if the LHS and RHS are equal. so it doesn't get caught up by the trivial match and it finds something that works with casts</p>



<a name="219136801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219136801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219136801">(Dec 07 2020 at 20:53)</a>:</h4>
<p>(idf is the identity function, i already had something named f in this test file)</p>



<a name="219137373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219137373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219137373">(Dec 07 2020 at 20:58)</a>:</h4>
<p>OK yeah this is probably more common than i expected since it will come up in coercions and coercions seem like an area where it's exhausting to think of all the details and you might want a rewrite_search.  i'll try to make this actually work, and failing that I will at least put a nice error message</p>



<a name="219137872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219137872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219137872">(Dec 07 2020 at 21:02)</a>:</h4>
<p>slightly less contrived:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">type_of</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">type_of</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">))</span> <span class="bp">≠</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">type_of</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="219143765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219143765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219143765">(Dec 07 2020 at 21:54)</a>:</h4>
<blockquote>
<p>I think the reason the previous one didn't work is that the algorithm doesn't actually test if the LHS and RHS are equal. so it doesn't get caught up by the trivial match and it finds something that works with casts</p>
</blockquote>
<p>I'm not quite sure what this means -- I thought the algorithm checked after each rewrite whether the new expression was in the map corresponding to the other side of the equality.</p>



<a name="219143878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219143878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219143878">(Dec 07 2020 at 21:55)</a>:</h4>
<p>But clearly my mental model is wrong so I'll have to look at the code again to sort myself out.</p>



<a name="219143936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219143936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219143936">(Dec 07 2020 at 21:55)</a>:</h4>
<p>I mean it doesn't check whether the LHS and RHS are themselves equal. it initializes the graph with them. then all the subsequent nodes have a different insertion path</p>



<a name="219144022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144022">(Dec 07 2020 at 21:56)</a>:</h4>
<p>Oh, I see</p>



<a name="219144064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144064">(Dec 07 2020 at 21:56)</a>:</h4>
<p>so if you try to prove <code>x = x</code> with rewrite search i don't think it will find the "no rewrites needed" rewrite.</p>



<a name="219144095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144095">(Dec 07 2020 at 21:57)</a>:</h4>
<p>That's an important edge case, hah. If people use <code>linarith</code> to prove <code>0 &lt; 1</code> they'll also use <code>rewrite_search</code> instead of <code>refl</code>!</p>



<a name="219144234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144234">(Dec 07 2020 at 21:58)</a>:</h4>
<p>sigh you are probably right. <span aria-label="rolling eyes" class="emoji emoji-1f644" role="img" title="rolling eyes">:rolling_eyes:</span> then the explainer needs a special case too</p>



<a name="219144314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144314">(Dec 07 2020 at 21:59)</a>:</h4>
<p>i'll add a test for that</p>



<a name="219144486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144486">(Dec 07 2020 at 22:00)</a>:</h4>
<p>There's a thread somewhere on Zulip with examples of people abusing tactics, it's horrifying</p>



<a name="219144590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144590">(Dec 07 2020 at 22:01)</a>:</h4>
<p>In this particular case it seems legitimate to me. Sometimes <code>refl</code>isn't obvious at all.</p>



<a name="219144736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144736">(Dec 07 2020 at 22:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219144486">said</a>:</p>
<blockquote>
<p>There's a thread somewhere on Zulip with examples of people abusing tactics, it's horrifying</p>
</blockquote>
<p><a href="#narrow/stream/113489-new-members/topic/natural.20number.20game.20%28https.3A.2F.2Ftinyurl.2Ecom.2Fnatgame1234%29/near/179726016">This post</a> comes to mind.</p>



<a name="219144840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219144840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219144840">(Dec 07 2020 at 22:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219144590">said</a>:</p>
<blockquote>
<p>In this particular case it seems legitimate to me. Sometimes <code>refl</code>isn't obvious at all.</p>
</blockquote>
<p>The problem here is only with obvious <code>refl</code>s, when the two sides pretty print the same.</p>



<a name="219285235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/219285235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#219285235">(Dec 09 2020 at 00:52)</a>:</h4>
<p>OK using <code>defeq</code> after it finds <code>pp</code> matches is in</p>



<a name="221769232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/221769232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#221769232">(Jan 06 2021 at 13:57)</a>:</h4>
<p><span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span> this one is in!!!</p>



<a name="221769237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%234841%20rewrite_search/near/221769237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.234841.20rewrite_search.html#221769237">(Jan 06 2021 at 13:57)</a>:</h4>
<p><span class="user-mention" data-user-id="238605">@Kevin Lacker</span> <span class="user-mention" data-user-id="110596">@Rob Lewis</span> thanks a lot!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
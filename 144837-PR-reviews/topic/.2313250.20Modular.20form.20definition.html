---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html">#13250 Modular form definition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="310200456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/310200456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#310200456">(Nov 15 2022 at 13:29)</a>:</h4>
<p>Ok I have another stupid question. I'm getting the following error <code>modular_form.to_slash_invariant_form - def missing doc string</code>. How do I add a doc string to something I've not explicitly defined?</p>



<a name="310200815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/310200815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#310200815">(Nov 15 2022 at 13:30)</a>:</h4>
<p>Is this obtained using <code>simps</code>?</p>



<a name="310202864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/310202864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#310202864">(Nov 15 2022 at 13:41)</a>:</h4>
<p>Ah, it comes from using <code>extends</code>. Does using <a href="https://leanprover-community.github.io/mathlib_docs/attributes.html#ancestor">ancestor</a> fix it?</p>



<a name="310202902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/310202902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#310202902">(Nov 15 2022 at 13:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/310200456">said</a>:</p>
<blockquote>
<p>Ok I have another stupid question. I'm getting the following error <code>modular_form.to_slash_invariant_form - def missing doc string</code>. How do I add a doc string to something I've not explicitly defined?</p>
</blockquote>
<p>Or you can add the doc using the <code>add_decl_doc</code> comman:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Your docstring here -/</span>
<span class="n">add_decl_doc</span> <span class="n">modular_form.to_slash_invariant_form</span>
</code></pre></div>



<a name="310204242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/310204242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#310204242">(Nov 15 2022 at 13:46)</a>:</h4>
<p>Ah thanks, I'll try that!</p>



<a name="311442677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/311442677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#311442677">(Nov 21 2022 at 18:31)</a>:</h4>
<p><span aria-label="ping pong" class="emoji emoji-1f3d3" role="img" title="ping pong">:ping_pong:</span></p>



<a name="311449253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/311449253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#311449253">(Nov 21 2022 at 19:09)</a>:</h4>
<p>Since this is still a huge PR, can you split it? For example all the analysis stuff can be in another PR.</p>



<a name="311449415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/311449415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#311449415">(Nov 21 2022 at 19:10)</a>:</h4>
<p>If you do it, mention that it has already been reviewed. I think that now very few people are confident in all the material (I mean, in mathlib) to merge it without having to think to it twice...</p>



<a name="311449451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/311449451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#311449451">(Nov 21 2022 at 19:10)</a>:</h4>
<p>And these few people are probably busy with the porting</p>



<a name="311554222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/311554222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#311554222">(Nov 22 2022 at 09:45)</a>:</h4>
<p>Sure, I split some of the content into <a href="https://github.com/leanprover-community/mathlib/pull/17675">#17675</a> <a href="https://github.com/leanprover-community/mathlib/pull/17676">#17676</a> <a href="https://github.com/leanprover-community/mathlib/pull/17677">#17677</a></p>



<a name="312482583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313250%20Modular%20form%20definition/near/312482583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition.html#312482583">(Nov 27 2022 at 15:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20definition/near/303533157">said</a>:</p>
<blockquote>
<p>Per one of Moritz' comment on this PR, I think there is a different approach that might be considered for this PR. In particular, I don't think it is quite necessary to realize <code>weakly_modular_form</code> as a submodule of <code>ℍ → ℂ</code>, and similarly for the others. Personally, I think it would make more sense to define the following structures:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">))</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">weakly_modular_form</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
<span class="o">(</span><span class="n">slash_action_eq'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">,</span> <span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">modular_form</span> <span class="kd">extends</span> <span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">structure</span> <span class="n">cusp_form</span> <span class="kd">extends</span> <span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol'</span> <span class="o">:</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_at_infty'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_zero_at_im_infty</span> <span class="o">(</span><span class="n">to_fun</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">class</span> <span class="n">weakly_modular_form_class</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">ℍ</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">slash_action_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="bp">Γ</span><span class="o">),</span> <span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">γ</span><span class="o">]</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">modular_form_class</span> <span class="kd">extends</span> <span class="n">weakly_modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">bdd_at_infty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_bounded_at_im_infty</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">class</span> <span class="n">cusp_form_class</span> <span class="kd">extends</span> <span class="n">weakly_modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mdifferentiable</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℍ'</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_at_infty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">SL</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">is_zero_at_im_infty</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∣</span><span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">]))</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="bp">Γ</span> <span class="bp">𝕜</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">cusp_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="n">modular_form_class</span> <span class="n">F</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">weakly_modular_form_class</span> <span class="o">(</span><span class="n">weakly_modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">modular_form_class</span> <span class="o">(</span><span class="n">modular_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">cusp_form_class</span> <span class="o">(</span><span class="n">cusp_form</span> <span class="bp">Γ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">Γ</span> <span class="n">k</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>After this (and some other boilerplate you should add that comes with the hom class setup) you can provide module instances for <code>weakly_modular_form</code>, <code>modular_form</code> and <code>cusp_form</code>, which is straightforward. You can also provide a graded multiplication operation on relevant types too. And finally, you can take the direct sum of <code>modular_form Γ</code> and put a graded ring structure on it. </p>
<p>All this being said, I'm not a number theorist, and I don't know much about modular forms. I'm posting this on Zulip so there can be discussion around it.</p>
</blockquote>
<p>Here <span class="user-mention" data-user-id="197836">@Jireh Loreaux</span> suggested making <code>modular_form</code> and <code>cusp_form</code> separate types. But I feel like it would make more sense to define <code>cusp_form</code> explicitly as a submodule of <code>modular_form</code>, rather than as a separate type. Thoughts?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
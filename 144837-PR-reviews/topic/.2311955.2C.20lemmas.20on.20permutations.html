---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html">#11955, lemmas on permutations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271546587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271546587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271546587">(Feb 11 2022 at 08:58)</a>:</h4>
<p>I just uploaded a PR <a href="https://github.com/leanprover-community/mathlib/pull/11955">#11955</a> that adds a few results relative to permutations, cycles and signature.</p>
<ul>
<li>
<p><code>nodup_powers_of_cycle_of</code> : shows that the the iterates of an element in the support give rise to a nodup list,<br>
proving that <code>f ^ i x \neq f ^ j x</code> if <code>i &lt; j &lt; (f.cycle_of x).support.card</code>.</p>
</li>
<li>
<p><code>cycle_is_cycle_of</code> : asserts that a given cycle <code>c</code> in <code>f. cycle_factors_finset</code> is equal to <code> f.cycle_of a</code> if  <code>c a \neq a</code></p>
</li>
<li>
<p><code>sign_of_cycle_type</code> : classical formula for the sign of a permutations in terms of its cycle_type — It is simpler to use than the earlier lemma which is renamed as <code>equiv.perm.sign_of_cycle_type'</code>: it only refers to the number of cycles and size of support while the earlier lemma involved a <code>multiset.prod</code>;  it could probably be deleted. <br>
I have adjusted a few proofs (in <a href="https://tqft.net/mathlib/group_theory/perm/cycle_types">file#group_theory/perm/cycle_types</a> and in <a href="https://tqft.net/mathlib/group_theory/specific_groups/alternating">file#group_theory/specific_groups/alternating</a> so that it makes use of the new lemma rather than the previous one.</p>
</li>
</ul>



<a name="271546683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271546683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271546683">(Feb 11 2022 at 08:59)</a>:</h4>
<p>(note that the way to link to files is <a href="https://tqft.net/mathlib/group_theory/perm/basic">file#group_theory/perm/basic</a> etc)</p>



<a name="271621218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271621218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271621218">(Feb 11 2022 at 18:55)</a>:</h4>
<p>Have you looked at <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.to_list">docs#equiv.perm.to_list</a>?</p>



<a name="271621549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271621549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271621549">(Feb 11 2022 at 18:57)</a>:</h4>
<p>In particular <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.form_perm_to_list">docs#equiv.perm.form_perm_to_list</a></p>



<a name="271621720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271621720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271621720">(Feb 11 2022 at 18:58)</a>:</h4>
<p>A stronger claim than your nodup claim: <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.is_cycle.exists_unique_cycle_subtype">docs#equiv.perm.is_cycle.exists_unique_cycle_subtype</a></p>



<a name="271752067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271752067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271752067">(Feb 13 2022 at 15:52)</a>:</h4>
<p>It is not clear to me how I can use <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.is_cycle.exists_unique_cycle_subtype">docs#equiv.perm.is_cycle.exists_unique_cycle_subtype</a> to prove what I need in a future PR ( <code>f ^ i x \neq f ^ j x</code> for some explicit values of <code>i</code> and <code>j</code> smaller than the order of the cycle).</p>



<a name="271752764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271752764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271752764">(Feb 13 2022 at 16:04)</a>:</h4>
<p>First, convert your <code>f ^ i x</code> into <code>(f.to_list _).nth_le n hn</code>. You also know that <code>nodup (f.to_list _)</code> by <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.nodup_to_list">docs#equiv.perm.nodup_to_list</a>. Finally, <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nodup_iff_nth_le_inj">docs#list.nodup_iff_nth_le_inj</a>.</p>



<a name="271752797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271752797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271752797">(Feb 13 2022 at 16:05)</a>:</h4>
<p>I would still ask what you need explicit <code>i, j</code> for, maybe you can phrase your later PR completely over the whole collection (either rooted at an arbitrary element, which is <code>to_list</code>, or the unrooted cycle <code>to_cycle</code>).</p>



<a name="271765527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271765527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271765527">(Feb 13 2022 at 21:06)</a>:</h4>
<p>I'll try this, thank you, and remove the function from the PR (I can always add something later if I need to,<br>
but it seems I won't).</p>



<a name="271765960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271765960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271765960">(Feb 13 2022 at 21:16)</a>:</h4>
<p>Please feel free to message me about any questions regarding permutations and cyclic permutations. It's possible that in making some lemmas, I forgot others, and would be happy to talk it over with you.</p>



<a name="271793010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271793010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271793010">(Feb 14 2022 at 07:51)</a>:</h4>
<p>Here, or elsewhere ? — for example, I had some trouble defining cycles, and ultimately even defined a function that produces a 3-cycle and the implied basic equalities, with this painful proof :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">import</span> <span class="n">data.list.defs</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.equiv.transfer_instance</span>
<span class="kn">import</span> <span class="n">group_theory.perm.concrete_cycle</span>
<span class="kn">import</span> <span class="n">group_theory.perm.list</span>
<span class="kn">import</span> <span class="n">data.list.cycle</span>
<span class="kn">import</span> <span class="n">group_theory.perm.cycle_type</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">equiv</span> <span class="n">equiv.perm</span>
<span class="kn">namespace</span> <span class="n">equiv.perm</span>

<span class="kd">lemma</span> <span class="n">three_cycle_mk</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="c1">-- (g : perm α)</span>
  <span class="o">(</span><span class="n">h12</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h13</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h23</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">),</span> <span class="n">is_three_cycle</span> <span class="n">h</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">h</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">h</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">h.support</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">],</span>
    <span class="k">have</span> <span class="n">l_notnil</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">≠</span> <span class="n">list.nil</span><span class="o">,</span>
    <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">≠</span> <span class="n">list.nil.length</span><span class="o">,</span>
        <span class="n">intro</span> <span class="n">z</span><span class="o">,</span> <span class="n">apply</span> <span class="n">this</span><span class="o">,</span> <span class="n">rw</span> <span class="n">z</span><span class="o">,</span> <span class="n">dec_trivial</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">l_nodup</span> <span class="o">:</span> <span class="n">l.nodup</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h12</span><span class="o">,</span> <span class="n">h13</span><span class="o">,</span> <span class="n">h23</span><span class="o">],</span>

    <span class="k">let</span> <span class="n">cl</span> <span class="o">:</span> <span class="n">cycle</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">],</span>

    <span class="k">let</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">cl.form_perm</span> <span class="n">l_nodup</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">h</span><span class="o">,</span>

    <span class="k">have</span> <span class="n">cl_is_nontrivial</span> <span class="o">:</span> <span class="n">cl.nontrivial</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">cycle.nontrivial_coe_nodup_iff</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">,</span> <span class="n">exact</span> <span class="n">l_nodup</span><span class="o">,</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">h_is_cycle</span> <span class="o">:</span> <span class="n">h.is_cycle</span> <span class="o">:=</span>
      <span class="n">cycle.is_cycle_form_perm</span> <span class="n">cl</span> <span class="n">l_nodup</span> <span class="n">cl_is_nontrivial</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_support_eq_l</span> <span class="o">:</span> <span class="n">h.support</span> <span class="bp">=</span> <span class="n">l.to_finset</span> <span class="o">:=</span>
      <span class="n">cycle.support_form_perm</span> <span class="n">cl</span> <span class="n">l_nodup</span> <span class="n">cl_is_nontrivial</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_is_three_cycle</span> <span class="o">:</span> <span class="n">h.is_three_cycle</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">card_support_eq_three_iff</span> <span class="o">,</span>
      <span class="n">rw</span> <span class="n">h_support_eq_l</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">list.card_to_finset</span> <span class="n">l</span><span class="o">,</span> <span class="n">rw</span> <span class="n">list.nodup.erase_dup</span> <span class="n">l_nodup</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">,</span> <span class="o">},</span>

    <span class="n">apply</span> <span class="n">and.intro</span> <span class="n">h_is_three_cycle</span><span class="o">,</span>

    <span class="n">apply</span> <span class="n">and.intro</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">cycle.form_perm_apply_mem_eq_next</span> <span class="n">cl</span> <span class="n">l_nodup</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">swap</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">true_or</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">],</span>
      <span class="n">change</span> <span class="n">l.next</span> <span class="n">a</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">list.next_cons_cons_eq'</span> <span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>

    <span class="n">apply</span> <span class="n">and.intro</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">cycle.form_perm_apply_mem_eq_next</span> <span class="n">cl</span> <span class="n">l_nodup</span>  <span class="n">b</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">swap</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">true_or</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">or_true</span><span class="o">],</span>
      <span class="n">change</span> <span class="n">l.next</span> <span class="n">b</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">list.next_ne_head_ne_last</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.next_cons_cons_eq</span><span class="o">],</span>
        <span class="n">apply</span> <span class="n">h12.symm</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.last</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">],</span> <span class="n">apply</span> <span class="n">h23</span> <span class="o">},</span> <span class="o">},</span>

    <span class="n">apply</span> <span class="n">and.intro</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">cycle.form_perm_apply_mem_eq_next</span> <span class="n">cl</span> <span class="n">l_nodup</span> <span class="n">c</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">swap</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">or_true</span><span class="o">,</span> <span class="n">list.mem_singleton</span><span class="o">,</span> <span class="n">apply_eq_iff_eq</span><span class="o">],</span>
      <span class="n">change</span> <span class="n">l.next</span> <span class="n">c</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">rw</span>  <span class="n">list.next_last_cons</span> <span class="o">,</span>
        <span class="n">apply</span> <span class="n">h13.symm</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.last</span><span class="o">],</span>
        <span class="n">apply</span> <span class="o">(</span><span class="n">list.nodup_cons.mp</span> <span class="n">l_nodup</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>  <span class="o">},</span>

    <span class="n">rw</span> <span class="n">h_support_eq_l</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">insert_emptyc_eq</span><span class="o">,</span> <span class="n">list.to_finset_nil</span><span class="o">,</span> <span class="n">list.to_finset_cons</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">equiv.perm</span>
</code></pre></div>



<a name="271841225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271841225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271841225">(Feb 14 2022 at 15:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">import</span> <span class="n">data.list.defs</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.equiv.transfer_instance</span>
<span class="kn">import</span> <span class="n">group_theory.perm.concrete_cycle</span>
<span class="kn">import</span> <span class="n">group_theory.perm.list</span>
<span class="kn">import</span> <span class="n">data.list.cycle</span>
<span class="kn">import</span> <span class="n">group_theory.perm.cycle_type</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">equiv</span> <span class="n">equiv.perm</span>
<span class="kn">namespace</span> <span class="n">equiv.perm</span>

<span class="kd">lemma</span> <span class="n">three_cycle_mk</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="c1">-- (g : perm α)</span>
  <span class="o">(</span><span class="n">h12</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h13</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h23</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">),</span> <span class="n">is_three_cycle</span> <span class="n">h</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">h</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">h</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">h.support</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">l</span> <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="k">with</span> <span class="n">hl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">l_nodup</span> <span class="o">:</span> <span class="n">l.nodup</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h12</span><span class="o">,</span> <span class="n">h13</span><span class="o">,</span> <span class="n">h23</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">l_support</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.form_perm</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">])</span><span class="bp">.</span><span class="n">support</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">list.support_form_perm_of_nodup</span> <span class="n">_</span> <span class="n">l_nodup</span> <span class="n">_</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">l_is_cycle</span> <span class="o">:</span> <span class="n">l.form_perm.is_cycle</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">list.is_cycle_form_perm</span> <span class="n">l_nodup</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">use</span> <span class="n">l.form_perm</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">l_support</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">is_three_cycle</span><span class="o">,</span> <span class="n">l_is_cycle.cycle_type</span><span class="o">,</span> <span class="n">l_support</span><span class="o">],</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">h12</span><span class="o">,</span> <span class="n">h13</span><span class="o">,</span> <span class="n">h23</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">,</span> <span class="n">swap_apply_of_ne_of_ne</span><span class="o">,</span> <span class="n">h12</span><span class="o">,</span> <span class="n">h13</span><span class="o">,</span> <span class="n">h23</span><span class="o">,</span> <span class="n">h12.symm</span><span class="o">,</span> <span class="n">h13.symm</span><span class="o">,</span> <span class="n">h23.symm</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">equiv.perm</span>
</code></pre></div>



<a name="271841279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/271841279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#271841279">(Feb 14 2022 at 15:25)</a>:</h4>
<p>How did you get  <code>a, b, c</code> and <code>h12, h13, h23</code>?</p>



<a name="272004162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/272004162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#272004162">(Feb 15 2022 at 17:00)</a>:</h4>
<p>From various <code>obtain</code> based on the existence of enough elements in relevant sets.</p>



<a name="272004563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311955%2C%20lemmas%20on%20permutations/near/272004563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311955.2C.20lemmas.20on.20permutations.html#272004563">(Feb 15 2022 at 17:03)</a>:</h4>
<p>This is is from <a href="https://github.com/leanprover-community/mathlib/tree/an-very-simple">branch#an-very-simple</a>, not yet in PR-form.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
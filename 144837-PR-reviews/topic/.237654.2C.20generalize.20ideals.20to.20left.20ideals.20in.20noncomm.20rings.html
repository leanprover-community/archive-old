---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html">#7654, generalize ideals to left ideals in noncomm rings</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240731364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240731364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240731364">(May 30 2021 at 01:24)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7654">#7654</a> is not very exciting, but it is somewhat exposed to bitrot, so I wouldn't mind if it could be merged sooner rather than later.</p>
<p>No new maths, just allows us to talk about <code>ideal</code> in a noncommutative ring, meaning a left ideal.</p>
<p>I thought it best _not_ to change the name to <code>left_ideal</code>, so that in a commutative ring (still our biggest audience!) one doesn't have to write the pesky <code>left_</code>. This will mean however that we'll need a separate name later for two-sided ideals.</p>



<a name="240764198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240764198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240764198">(May 30 2021 at 16:47)</a>:</h4>
<p>This also highlights something that I faced with the order refactor.  One of my reasons was to allow not-necessarily commutative semigroups/monoids/semirings/rings to be ordered.  In this specific case, there were some lemmas that could be proven by using either left- or right- monotonicity.  For instance, <code>1 &lt; a -&gt; 1 &lt; a ^ n</code> that follows from either left or right monotonicity of multiplication.  In this case, I called the two versions <code>left.[name]</code> and <code>right.[name]</code>, though I would be happy with a more consistent naming.  For instance, a convention that the "usual" name is an implied <code>left</code> and that explicitly only <code>right</code> is mentioned.</p>



<a name="240767545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240767545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240767545">(May 30 2021 at 18:15)</a>:</h4>
<p>Another way to resolve "Z follows from either X or Y" where both X and Y are typeclasses are to introduce another typeclass for Z</p>



<a name="240767568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240767568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240767568">(May 30 2021 at 18:15)</a>:</h4>
<p>Then you only need a single <code>z</code> lemma instead of <code>z_X</code> and <code>z_Y</code></p>



<a name="240798742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240798742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240798742">(May 31 2021 at 07:05)</a>:</h4>
<p>Having <code>ideal</code> meaning left ideal feels wrong. An ideal should be the kernel of a ring morphism, and other notions should have longer names. Can't we have a definition of ideals that include both sides and then a constructor for commutative ring where you only have to prove one side? I guess this doesn't work with the trick of using submodule theory to define ideal.</p>



<a name="240799160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240799160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240799160">(May 31 2021 at 07:11)</a>:</h4>
<p>It's still a bi-submodule, right?</p>



<a name="240799369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240799369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240799369">(May 31 2021 at 07:14)</a>:</h4>
<p>Yes, it's a bimodule. But do we have bimodules?</p>



<a name="240799965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240799965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240799965">(May 31 2021 at 07:21)</a>:</h4>
<p>No, but we'll certainly need them if we are generalizing all this stuff. Guess we'll need a new notational class as well? <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span></p>



<a name="240800341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240800341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240800341">(May 31 2021 at 07:25)</a>:</h4>
<p>I have been toying with the idea of having a <code>to_right</code> attribute, similar to <code>to_additive</code> that would convert a <code>left</code> lemma to a <code>right</code> lemma.  If we really take on-board of removing commutativity as much as possible, it may be useful to have it.</p>



<a name="240800694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240800694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240800694">(May 31 2021 at 07:29)</a>:</h4>
<p>We have right-modules now as <code>module (opposite R) M</code></p>



<a name="240800766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240800766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240800766">(May 31 2021 at 07:30)</a>:</h4>
<p>But we would also need a <code>has_ralacs</code> class, with appropriate notation, I think. Because as Eric points out, now we need to use <code>opposite R</code>. I think that's a notational headache.</p>



<a name="240800822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240800822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240800822">(May 31 2021 at 07:31)</a>:</h4>
<p>(at least, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/opposite.monoid.to_mul_action">docs#opposite.monoid.to_mul_action</a> which confers the obvious right action on a monoid on itself)</p>



<a name="240800883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240800883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240800883">(May 31 2021 at 07:31)</a>:</h4>
<p>I don't think we need such a class, a notation for <code>op r \smul m</code> would suffice. I asked about this in another thread recently</p>



<a name="240801133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801133">(May 31 2021 at 07:34)</a>:</h4>
<p>I assume a bimodule is "nothing more" than <code>[module R M] [module (opposite R) M] [smul_comm_class R (opposite R) M]</code>?</p>



<a name="240801166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801166">(May 31 2021 at 07:34)</a>:</h4>
<p>is there a way to enforce the convention that <em>asymmetric</em> things are formulated only for "left" assumptions?  I am thinking of something similar to the convention of never using <code>ge</code>.</p>
<p>I do not know how extensive is the use of <code>right</code>-lemmas in a bi-context.  As Eric points out, if this is relatively rare, the <code>opposite</code> way could be a good compromise, in a situation where you have a bi-something and want to play really with both left and right assumptions.</p>



<a name="240801279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801279">(May 31 2021 at 07:36)</a>:</h4>
<p>I guess that could work. Of course ideals are not rare, but they could be done separately...</p>



<a name="240801361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801361">(May 31 2021 at 07:36)</a>:</h4>
<p>We would still need a new <code>subbimodule</code> structure</p>



<a name="240801381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801381">(May 31 2021 at 07:36)</a>:</h4>
<p>Composition works for typeclasses but not for bundled subobjects</p>



<a name="240801406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801406">(May 31 2021 at 07:37)</a>:</h4>
<p>Unless we come up with a more sophisticated approach to bundling</p>



<a name="240801511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801511">(May 31 2021 at 07:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings/near/240801361">said</a>:</p>
<blockquote>
<p>We would still need a new <code>subbimodule</code> structure</p>
</blockquote>
<p><code>sub_smul_comm_class</code> <span aria-label="shock" class="emoji emoji-1f628" role="img" title="shock">:shock:</span> <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span> <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span> <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="240801579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801579">(May 31 2021 at 07:39)</a>:</h4>
<p>((Un)related: should <code>smul_comm_class</code> be renamed to <code>smul_comm</code>?)</p>



<a name="240801788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801788">(May 31 2021 at 07:41)</a>:</h4>
<p>(and the cryptic <code>is_scalar_tower</code> to <code>smul_assoc</code>?)</p>



<a name="240801917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240801917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240801917">(May 31 2021 at 07:42)</a>:</h4>
<p>ooh, wait, the reason that doesn't work is that the lemmas are already called <code>smul_comm</code> and <code>smul_assoc</code>...</p>



<a name="240802225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240802225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240802225">(May 31 2021 at 07:45)</a>:</h4>
<p>Those could become <code>has_smul_comm</code>, though, right(/opposite)?  Or is <code>has_[...]</code> something else?</p>



<a name="240804305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240804305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240804305">(May 31 2021 at 08:09)</a>:</h4>
<p>I agree there is a problem with naming, on the other hand I don't want to have to do a massive refactor of our handling of ideals just to be able to say that a division ring is noetherian (which requires no new maths at all in current mathlib, just relaxing commutativity assumptions).</p>
<p>I would propose perhaps the following as a path to the utopian world we want:</p>
<ol>
<li>this PR as is, and we hold our noses for a moment about names</li>
<li>in a next PR, we rename <code>ideal</code> to <code>left_ideal</code>, and add a new abbreviation <code>ideal</code> for <code>left_ideal</code>, but only in the presence of commutativity</li>
<li>we add <code>two_sided_ideal</code>, <code>right_ideal</code>, <code>bimodule</code>, <code>subbimodule</code>, <code>has_right_scalar</code> etc... progressively.</li>
</ol>



<a name="240804534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240804534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240804534">(May 31 2021 at 08:12)</a>:</h4>
<p>I agree that this is probably the best way forward</p>



<a name="240809664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240809664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240809664">(May 31 2021 at 09:10)</a>:</h4>
<p>I'm delighted to see this PR and really looking forward to the day we get to bimodules properly, especially as they do come up in even commutative land from time to time.</p>



<a name="240809726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240809726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240809726">(May 31 2021 at 09:11)</a>:</h4>
<p>I had an example just yesterday with something equivalent to the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="c1">-- Alternatively could drop `algebra R A` and  use `smul_comm_class R A M` instead of</span>
<span class="c1">-- `is_scalar_tower R A M` at cost of then needing manual `smul_comm_class.symm` somewhere.</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">works</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="n">N</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="c1">-- Finds `linear_map.module`</span>

<span class="c1">-- This is really `module Aᵒᵖ (M →ₗ[R] N)` but since `A` is commutative `Aᵒᵖ ≃+* A` have below also</span>
<span class="kd">instance</span> <span class="n">fails</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">instance</span> <span class="n">also_fails</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span><span class="bp">ᵒᵖ</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>



<a name="240809940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240809940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240809940">(May 31 2021 at 09:13)</a>:</h4>
<p>The point being that we define the left module structure on linear maps (using the scalar action in the codomain) but not the right module structure (using the scalar action in the domain).</p>



<a name="240830233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240830233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240830233">(May 31 2021 at 12:55)</a>:</h4>
<p>Why is that the right definition of the "right" action? Shouldn't the right action just be the right action in the codomain, to match the left action?</p>



<a name="240830809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240830809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240830809">(May 31 2021 at 13:01)</a>:</h4>
<p>IIUC we agree: I haven't actually proposed a definition of the "right" action the above but just noticed that we only have a definition of the "left" action.</p>



<a name="240831391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240831391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240831391">(May 31 2021 at 13:06)</a>:</h4>
<p>There is no <code>A</code>-action on the codomain <code>N</code> at all.</p>



<a name="240832008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240832008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240832008">(May 31 2021 at 13:13)</a>:</h4>
<p>Isn't that my point? I.e., the reason <code>module A (M →ₗ[R] N)</code> fails is because we define our scalar actions using the scalar action in the codomain so when there isn't one there <code>linear_map.module</code> fails and there is no other instance.</p>



<a name="240832250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240832250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240832250">(May 31 2021 at 13:15)</a>:</h4>
<p>But if we also defined the right <code>A</code> action, then we would find an instance in this case. However to avoid diamond issues (or indeed to work when <code>A</code> is not commutative) it would have to be on the type <code>Aᵒᵖ</code> or else using a new <code>has_right_scalar</code> typeclass.</p>



<a name="240832332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240832332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240832332">(May 31 2021 at 13:16)</a>:</h4>
<p>I think I have this correct but please correct me if I am muddled.</p>



<a name="240832774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240832774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240832774">(May 31 2021 at 13:20)</a>:</h4>
<p>Actually I need to think about this, there is a second action but this is not as simple as a left-right issue.</p>



<a name="240837753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240837753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240837753">(May 31 2021 at 14:07)</a>:</h4>
<p>(deleted)</p>



<a name="240840715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240840715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240840715">(May 31 2021 at 14:36)</a>:</h4>
<p>Our "general philosophy" with pi instances is to inherit structure on the pi type from structure on the codomain. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>N</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">f:N\to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and we want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> to act on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> s somehow, then the natural definition is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>f</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(af)(n)=a(fn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, which works great if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> acts on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>, and the fact that all that's happening is that the brackets are moving around means that the diagrams will commute. However if you imagine writing maps on the right, writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">nf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">fn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">n</span></span></span></span> (which is just a notational change, i.e. it doesn't matter that this is not Lean syntax) then we now want to know what <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">af</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> should be and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>a</mi><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(af)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> now looks like it should naturally be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mi>a</mi><mo stretchy="false">)</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">(na)f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">na</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, meaning that there is a natural left-action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom(N,M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> has a right <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-action.</p>



<a name="240840953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240840953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240840953">(May 31 2021 at 14:38)</a>:</h4>
<p>Mathematically I've just convinced myself that in bimodule land, being left-linear kills off the ring you're linear over but retains the other two rings each module carried an action of.</p>



<a name="240841026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841026">(May 31 2021 at 14:39)</a>:</h4>
<p>I.e. if <code>M</code> is an <code>(A, B)</code>-bimodule and <code>N</code> is an <code>(A, C)</code>-bimodule then we can talk about left-<code>A</code>-linear maps and these are a <code>(B, C)</code>-bimodule.</p>



<a name="240841039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841039">(May 31 2021 at 14:39)</a>:</h4>
<p>Yes, that sounds right -- analogous to the fact that the tensor product of an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>-bimodule and a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B,C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>-bimodule is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A,C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>-bimodule.</p>



<a name="240841050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841050">(May 31 2021 at 14:39)</a>:</h4>
<p>(or <code>(C, B)</code> for maps the other way)</p>



<a name="240841101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841101">(May 31 2021 at 14:40)</a>:</h4>
<p>And of course similar story for right-linear if its the right rings the two modules have in common.</p>



<a name="240841154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841154">(May 31 2021 at 14:40)</a>:</h4>
<p>So when people say linear maps over a non-commutative ring are just an abelian group it's because they only had Z actions on the other side of their bimodules etc.</p>



<a name="240841183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841183">(May 31 2021 at 14:41)</a>:</h4>
<p>Right, and my "write maps on the right" viewpoint convinces you that a right action of an object on the domain of a hom set naturally translates to a left action of the object on the hom set (for me, this is not so "natural" if you just write down the algebra with maps on the left.)</p>



<a name="240841337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841337">(May 31 2021 at 14:42)</a>:</h4>
<p>I think so. I'm 99% convinced. One moment.</p>



<a name="240841394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841394">(May 31 2021 at 14:42)</a>:</h4>
<p>Now 100%</p>



<a name="240841399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841399">(May 31 2021 at 14:42)</a>:</h4>
<p>Another way of seeing it is that Hom(M,N) is covariant in N but contravariant in M.</p>



<a name="240841675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841675">(May 31 2021 at 14:45)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>M</mi><mo>∗</mo></msup><mo>⊗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\mathrm{Hom}(M,N) = M^* \otimes N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Hom</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.772026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>



<a name="240841791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841791">(May 31 2021 at 14:46)</a>:</h4>
<p>I think then you can transfer all the natural actions from the tensor product to Hom in a natural way.</p>



<a name="240841795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841795">(May 31 2021 at 14:46)</a>:</h4>
<p>I often secretly use this <span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span>to figure out what should be true and then translate back into Hom afterward</p>



<a name="240841885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841885">(May 31 2021 at 14:47)</a>:</h4>
<p>The LaTeX statement is not true in general but it's a pretty good guide to what's going on!</p>



<a name="240841899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240841899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240841899">(May 31 2021 at 14:47)</a>:</h4>
<p>Yes, that's why I only do it secretly.</p>



<a name="240852010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240852010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240852010">(May 31 2021 at 16:32)</a>:</h4>
<p>So did we conclude what <code>has_scalar (opposite R) (R -&gt; R)</code> should mean? IMO it should be <code>fun r f x, f x * r.unop</code> to match the <code>fun r f x, r * f x</code> action of <code>has_scalar R (R -&gt; R)</code>?</p>



<a name="240852318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240852318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240852318">(May 31 2021 at 16:36)</a>:</h4>
<p>(I also suspect the instance of that definition is found by typeclass search today)</p>



<a name="240852583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240852583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240852583">(May 31 2021 at 16:39)</a>:</h4>
<p><del>Not sure about being found by typeclass today but otherwise agree.</del></p>



<a name="240853035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240853035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240853035">(May 31 2021 at 16:45)</a>:</h4>
<p>I think it's found today for <code>monoid R</code> but am not in a position to check</p>



<a name="240853457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240853457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240853457">(May 31 2021 at 16:51)</a>:</h4>
<p>I think I can summarise what I claim is missing as the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="c1">-- Exists</span>
<span class="kd">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">R</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pi.has_scalar</span>

<span class="c1">-- Missing</span>
<span class="kd">instance</span> <span class="n">bar</span> <span class="o">(</span><span class="n">R</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">R</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span><span class="bp">ᵒᵖ</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">r</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">r.unop</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)⟩</span>

<span class="kd">instance</span> <span class="n">baz</span> <span class="o">(</span><span class="n">R</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">R</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">R</span><span class="bp">ᵒᵖ</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">unfold</span> <span class="n">has_scalar.smul</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">has_scalar.smul</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">},</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span><span class="bp">ᵒᵖ</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">))</span> <span class="o">}</span> <span class="c1">-- Finds `bar` above</span>
</code></pre></div>



<a name="240853693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240853693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240853693">(May 31 2021 at 16:54)</a>:</h4>
<p>So we're encoding right actions as left actions by the opposite ring?</p>



<a name="240853729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240853729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240853729">(May 31 2021 at 16:54)</a>:</h4>
<p>In this snippet yes, but I'm not yet convinced this is what we should do in Mathlib.</p>



<a name="240854059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854059">(May 31 2021 at 16:59)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I too am confused again!</p>



<a name="240854074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854074">(May 31 2021 at 16:59)</a>:</h4>
<p>Your snippet is not compatible with the version I propose above that you expressed agreement with!</p>



<a name="240854169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854169">(May 31 2021 at 17:00)</a>:</h4>
<p>I know. I'm just trying to think this through again.</p>



<a name="240854285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854285">(May 31 2021 at 17:01)</a>:</h4>
<p>Eric is proposing using the action on the codomain and Oliver on the domain</p>



<a name="240854327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854327">(May 31 2021 at 17:02)</a>:</h4>
<p>Yes</p>



<a name="240854363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854363">(May 31 2021 at 17:02)</a>:</h4>
<p>Otherwise we have no way to express "use the right action on the codomain"</p>



<a name="240854426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854426">(May 31 2021 at 17:03)</a>:</h4>
<p>And the action on the domain usually isn't as strong - for instance, I don't think it's distributive on general pi types, only on add_monoid_homs</p>



<a name="240854748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854748">(May 31 2021 at 17:07)</a>:</h4>
<p>It might not actually be an action I want after all. In the cases I can think of that I care about (e.g., left-linear maps between bimodules) it isn't.</p>



<a name="240854891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854891">(May 31 2021 at 17:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings/near/240852010">said</a>:</p>
<blockquote>
<p>So did we conclude what <code>has_scalar (opposite R) (R -&gt; R)</code> should mean? IMO it should be <code>fun r f x, f x * r.unop</code> to match the <code>fun r f x, r * f x</code> action of <code>has_scalar R (R -&gt; R)</code>?</p>
</blockquote>
<p>As of now I revert to agreeing with this and mentally bookmark the action I mentioned as a weird thing that exists but which I don't need.</p>



<a name="240854923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240854923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240854923">(May 31 2021 at 17:09)</a>:</h4>
<p>I can't believe I'm still talking about this <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="240859555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240859555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240859555">(May 31 2021 at 18:12)</a>:</h4>
<p>For record I guess we can do the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="kn">open</span> <span class="n">opposite</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">D</span><span class="o">]</span>

<span class="c1">-- Give X left `A` and right `B` action</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">A</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">B</span><span class="bp">ᵒᵖ</span> <span class="n">X</span><span class="o">]</span>

<span class="c1">-- Give Y left `C` and right `D` action</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">C</span> <span class="n">Y</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">D</span><span class="bp">ᵒᵖ</span> <span class="n">Y</span><span class="o">]</span>

<span class="c1">-- Right action on maps from left action on domain (my original action)</span>
<span class="kd">def</span> <span class="n">right_A</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">A</span><span class="bp">ᵒᵖ</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span>     <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">a.unop</span> <span class="bp">•</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">},</span> <span class="o">}</span>

<span class="c1">-- Left action on maps from right action on domain (not previously discussed)</span>
<span class="kd">def</span> <span class="n">left_B</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">B</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span>     <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="bp">$</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span><span class="o">)</span> <span class="bp">•</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b₁</span> <span class="n">b₂</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">},</span> <span class="o">}</span>

<span class="c1">-- Left action on maps from left action on codomain ("usual" pi action)</span>
<span class="kd">def</span> <span class="n">left_C</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">C</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pi.mul_action</span> <span class="n">C</span>

<span class="c1">-- Right action on maps from right action on codomain (Eric's action)</span>
<span class="kd">def</span> <span class="n">right_D</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">D</span><span class="bp">ᵒᵖ</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span>     <span class="o">:=</span> <span class="bp">λ</span> <span class="n">d</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">d</span> <span class="bp">•</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="240859684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240859684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240859684">(May 31 2021 at 18:14)</a>:</h4>
<p>In other words if <code>X</code> carries a left <code>A</code>-action a right <code>B</code>-action and <code>Y</code> carries a left <code>C</code>-action and a right <code>D</code>-action then the maps <code>X → Y</code> carry four actions (two left, two right) covariantly in the codomain and contravariantly in the domain.</p>



<a name="240860501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860501">(May 31 2021 at 18:26)</a>:</h4>
<p>Does <code>infer_instance</code> find <code>right_D</code>?</p>



<a name="240860510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860510">(May 31 2021 at 18:26)</a>:</h4>
<p>Oh, it does!</p>



<a name="240860549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860549">(May 31 2021 at 18:27)</a>:</h4>
<p>Right, of course it should. It's just the usual pi action.</p>



<a name="240860566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860566">(May 31 2021 at 18:27)</a>:</h4>
<p>Exactly</p>



<a name="240860593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860593">(May 31 2021 at 18:28)</a>:</h4>
<p><del>I think we're good here: I feel I understand things and I believe the actions we want are the ones we have, namely the actions on the codomain.</del> I'll have to think about what we should do but at least I understand now.</p>



<a name="240860757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860757">(May 31 2021 at 18:30)</a>:</h4>
<p>I think it probably does make sense to have some way to spell the other actions, perhaps via type aliases</p>



<a name="240860832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860832">(May 31 2021 at 18:30)</a>:</h4>
<p>This thorn has come up on polynomials quite recently, as they provide actions for both domain and codomain (of the evaluation function)</p>



<a name="240860852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860852">(May 31 2021 at 18:31)</a>:</h4>
<p>Which unsurprisingly forms a bad diamond</p>



<a name="240860936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240860936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240860936">(May 31 2021 at 18:32)</a>:</h4>
<p>Actually I tend to think we may have to do something here.</p>



<a name="240861013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240861013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240861013">(May 31 2021 at 18:33)</a>:</h4>
<p><del>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra">docs#monoid_algebra</a> comap is the type alias for monoid algebras. Which naturally is not reused at all for polynomials...</del></p>



<a name="240861147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240861147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240861147">(May 31 2021 at 18:35)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.comap_distrib_mul_action">docs#finsupp.comap_distrib_mul_action</a> is what I'm thinking of</p>



<a name="240861408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237654%2C%20generalize%20ideals%20to%20left%20ideals%20in%20noncomm%20rings/near/240861408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings.html#240861408">(May 31 2021 at 18:39)</a>:</h4>
<p>Which is registered as an instance for <code>monoid_algebra</code> but not finsupp</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
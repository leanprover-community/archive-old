---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html">#8082 has_lt_iff_add_one_le</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246710558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246710558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246710558">(Jul 21 2021 at 12:16)</a>:</h4>
<p>This PR is now ready for review!<br>
I'm introducing a new typeclass to state that <code>∀ a b, a &lt; b ↔ a + 1 ≤ b</code>. This is designed to be satisfied by <code>ℕ</code>, <code>ℤ</code>, <code>fin n</code> and linear sums and disjoint unions of such. I coincidentally started encountering several places where it can be used: finite intervals, equitable functions...</p>



<a name="246710796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246710796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246710796">(Jul 21 2021 at 12:19)</a>:</h4>
<p>I'm really not sure of where should the two new lemmas <code>lt_iff_add_one_le</code>, <code>lt_add_one_iff_le</code> should go. I've currently put one in <code>order.basic</code> right after the class definition and the other one (that requires contravariant stuff) in <code>algebra.ordered_monoid_lemmas</code>. What do you think, <span class="user-mention" data-user-id="321459">@Damiano Testa</span>?</p>



<a name="246712419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246712419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246712419">(Jul 21 2021 at 12:34)</a>:</h4>
<p>What lean type do you mean by linear sums and disjoint unions?</p>



<a name="246734426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734426">(Jul 21 2021 at 15:17)</a>:</h4>
<p>I don't know, actually. Both are orders on <code>α ⊕ β</code>. I don't think we have linear sum (which is all of <code>α</code> &lt; all of <code>β</code>) but disjoint union (all of <code>α</code> incomparable to all of <code>β</code>) could well be some instance already.</p>



<a name="246734554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734554">(Jul 21 2021 at 15:18)</a>:</h4>
<p>Maybe Eric is wondering where the <code>1</code> comes from in the disjoint union?</p>



<a name="246734605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734605">(Jul 21 2021 at 15:18)</a>:</h4>
<p>I guess in this generality it's a "shift" operator</p>



<a name="246734815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734815">(Jul 21 2021 at 15:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le/near/246734426">said</a>:</p>
<blockquote>
<p>I don't know, actually. Both are orders on <code>α ⊕ β</code>. I don't think we have linear sum (which is all of <code>α</code> &lt; all of <code>β</code>) but disjoint union (all of <code>α</code> incomparable to all of <code>β</code>) could well be some instance already.</p>
</blockquote>
<p>We do, that's used in the ordinal sum. I think it's called <code>sum.lex</code> or something</p>



<a name="246734931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734931">(Jul 21 2021 at 15:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le/near/246734605">said</a>:</p>
<blockquote>
<p>I guess in this generality it's a "shift" operator</p>
</blockquote>
<p>That's how I think about it. There's no need for it to make sense arithmetically.</p>



<a name="246734933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734933">(Jul 21 2021 at 15:21)</a>:</h4>
<p>I guess ordinals are an example of this typeclass</p>



<a name="246734985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246734985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246734985">(Jul 21 2021 at 15:21)</a>:</h4>
<p>How does this work for <code>fin n</code>? Is <code>shift</code> the same as <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_rotate">docs#fin_rotate</a>?</p>



<a name="246735137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246735137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246735137">(Jul 21 2021 at 15:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le/near/246734933">said</a>:</p>
<blockquote>
<p>I guess ordinals are an example of this typeclass</p>
</blockquote>
<p>Absolutely!</p>



<a name="246735196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246735196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246735196">(Jul 21 2021 at 15:23)</a>:</h4>
<p>I think it actually doesn't, because you can't define <code>(n - 1) + 1</code> in a way that doesn't conflict with <code>lt_iff_add_one_le</code></p>



<a name="246735231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246735231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246735231">(Jul 21 2021 at 15:23)</a>:</h4>
<p>I would separate the class into two, a "discrete order" (name TBD) which has a <code>succ</code> function satisfying <code>a &lt; b</code> iff <code>succ a &lt;= b</code>, and an extension where there is an addition and a one and <code>succ x = x + 1</code></p>



<a name="246737079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737079">(Jul 21 2021 at 15:37)</a>:</h4>
<p>Oh yeah that sounds right! What about <code>has_lt_iff_succ_le</code>?</p>



<a name="246737250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737250">(Jul 21 2021 at 15:39)</a>:</h4>
<p>how about <code>has_succ</code>? This is just defining what it means to be an (order) successor</p>



<a name="246737276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737276">(Jul 21 2021 at 15:39)</a>:</h4>
<p>Note also that there is potential for the "dual" typeclasses. <code>has_lt_add_one_iff_le</code> (<code>a &lt; b + 1 ↔ a ≤ b</code>) is equivalent under cancellation assumptions but different in general.</p>



<a name="246737392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737392">(Jul 21 2021 at 15:40)</a>:</h4>
<p>That's a good idea but it could sound like it's a semantic typeclass.</p>



<a name="246737398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737398">(Jul 21 2021 at 15:40)</a>:</h4>
<p>What about <code>succ_order</code>?</p>



<a name="246737758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737758">(Jul 21 2021 at 15:44)</a>:</h4>
<p>most examples of succ functions I can think of satisfy both versions <code>succ a &lt;= b</code> iff <code>a &lt; b</code> and <code>a &lt; succ b</code> iff <code> a &lt;= b</code>, but maybe I'm considering linear orders too much</p>



<a name="246737833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246737833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246737833">(Jul 21 2021 at 15:44)</a>:</h4>
<p>if there aren't any good intermediate examples we should just have both axioms in the typeclass</p>



<a name="246738112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246738112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246738112">(Jul 21 2021 at 15:46)</a>:</h4>
<p>Also, should we have the actual dual typeclass <code>pred_order</code>? <code>ℕ</code> doesn't satisfy it this time.</p>



<a name="246738246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246738246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246738246">(Jul 21 2021 at 15:48)</a>:</h4>
<p>I don't think we need it much, although the conjunction of <code>has_succ</code> and <code>has_pred</code> could be useful</p>



<a name="246738369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246738369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246738369">(Jul 21 2021 at 15:48)</a>:</h4>
<p>in theory you can use <code>succ_order (dual X)</code></p>



<a name="246862437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246862437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246862437">(Jul 22 2021 at 15:23)</a>:</h4>
<p>Defining <code>succ_order</code> implies creating a function <code>succ</code> that'll be conflicting with <code>nat.succ</code> and <code>int.succ</code>. How should I go about that?</p>



<a name="246862607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246862607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246862607">(Jul 22 2021 at 15:25)</a>:</h4>
<p>I can just not define <code>int.succ</code> and <code>succ</code> will be available directly, but <code>nat.succ</code> is part of the <em>definition</em> of <code>ℕ</code>, so that sounds harder.</p>



<a name="246862957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246862957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246862957">(Jul 22 2021 at 15:28)</a>:</h4>
<p><code>succ'</code>?</p>



<a name="246863162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246863162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246863162">(Jul 22 2021 at 15:30)</a>:</h4>
<p>Yeah but changing the def of <code>ℕ</code> is hard, right?</p>



<a name="246863200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246863200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246863200">(Jul 22 2021 at 15:30)</a>:</h4>
<p>Also, we won't have the nice dot notation anymore.</p>



<a name="246863639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246863639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246863639">(Jul 22 2021 at 15:33)</a>:</h4>
<p>I mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">succ_order</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">succ'</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">-&gt;</span> <span class="n">X</span><span class="o">)</span>
</code></pre></div>



<a name="246863746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246863746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246863746">(Jul 22 2021 at 15:34)</a>:</h4>
<p>Yeah sure, but then you want to do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">succ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">succ_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">succ_order.succ'</span>
</code></pre></div>
<p>Right?</p>



<a name="246863903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246863903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246863903">(Jul 22 2021 at 15:35)</a>:</h4>
<p>Usually <code>nat.succ</code> is behind <code>nat</code>, doing <code>open nat</code> is a recipe for clashes already.</p>



<a name="246864316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/246864316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#246864316">(Jul 22 2021 at 15:38)</a>:</h4>
<p>I would suggest leaving <code>int.succ</code> and <code>nat.succ</code> as they are and adding a new definition <code>_root_.succ</code>, or probably better <code>succ_order.succ</code> which can be opened if necessary. This class will not be used much.</p>



<a name="247469822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/247469822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#247469822">(Jul 28 2021 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> I do have some ideas about how to allow top orders in the typeclass. The current problem stems from the <code>≤ → &lt;</code> implications, so I'm offering to simply delete those, and reintroduce them under the assumption that <code>a</code> (or <code>b</code>) is not top. I'm looking for the simplest set of hypotheses I can have that achieves this.</p>



<a name="247500621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/247500621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#247500621">(Jul 28 2021 at 18:48)</a>:</h4>
<p>Sorry, missed this thread because I forgot I changed the PR name on GitHub :P</p>



<a name="247501228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/247501228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#247501228">(Jul 28 2021 at 18:52)</a>:</h4>
<p>I believe it's worth the effort to ensure that <code>succ_order</code> is a subsingleton, so we should pick the value of <code>succ \top</code>. <code>\top</code> itself would work if you define <code>succ a</code> as the infimum of all <code>b &gt; a</code>, but <code>\bot</code> would be better if you want to fit addition on <code>fin</code>, so I'm not quite sure what the best option is here.</p>



<a name="247501460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/247501460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#247501460">(Jul 28 2021 at 18:54)</a>:</h4>
<p>I'm leaning towards the first option, also since you suggested deleting the whole <code>succ_eq_add_one_order</code>.</p>



<a name="247502301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/247502301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#247502301">(Jul 28 2021 at 18:59)</a>:</h4>
<p>If we say <code>succ \top = \top</code>, then following the infimum definition the axioms would look something like: <code>∀ a b, a &lt; b → (succ a ≤ b ∧ a &lt; succ a)</code> and <code>∀ a, a ≤ succ a</code></p>



<a name="247502615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%238082%20has_lt_iff_add_one_le/near/247502615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.238082.20has_lt_iff_add_one_le.html#247502615">(Jul 28 2021 at 19:01)</a>:</h4>
<p>Note that the opposite implication <code>∀ a b, (succ a ≤ b ∧ a &lt; succ a) → a &lt; b</code> is transitivity.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
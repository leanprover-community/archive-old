---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/4770.20smul_comm_class.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html">4770 smul_comm_class</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214441055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214441055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214441055">(Oct 24 2020 at 18:07)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib/issues/4770">#4770</a> I suggest we add a typeclass <code>smul_comm_class</code> saying that two actions on the same space commute. I'd like to have some feedback on the idea before I spend time porting existing definitions to this typeclass.</p>



<a name="214441112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214441112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214441112">(Oct 24 2020 at 18:08)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> I think that this class can be used for conjugate semimodules if we regard them as semimodules over <code>opposite complex</code>.</p>



<a name="214441221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214441221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214441221">(Oct 24 2020 at 18:10)</a>:</h4>
<p>And generalize <code>semimodule</code> structure on <code>linear_map</code>s.</p>



<a name="214441698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214441698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214441698">(Oct 24 2020 at 18:21)</a>:</h4>
<p>I don't understand, can you spell out the idea a little more?  The conjugate semimodule is defined to be a scalar multiplication of <code>opposite ℂ</code> on the same space, but then how do linear maps work when the first space is over <code>opposite ℂ</code> and the second space is over <code>ℂ</code>?</p>



<a name="214441881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214441881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214441881">(Oct 24 2020 at 18:24)</a>:</h4>
<p>Would this also help in representation theory, where the action of <code>G</code> on <code>V</code> and the action of <code>K</code> on <code>V</code> commute?</p>



<a name="214441897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214441897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214441897">(Oct 24 2020 at 18:25)</a>:</h4>
<p>Currently we treat representations as modules over <code>monoid_algebra K G</code> but that leads to "ugly" statements</p>



<a name="214442221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442221">(Oct 24 2020 at 18:32)</a>:</h4>
<p>We should have an instance generating an action of <code>monoid_algebra K G</code> from the fact that two actions commute.</p>



<a name="214442311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442311">(Oct 24 2020 at 18:34)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> I was thinking about sesqlinear forms, not conjugate linear maps. Let me think about it a bit more.</p>



<a name="214442722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442722">(Oct 24 2020 at 18:43)</a>:</h4>
<p>One way to generalize this is to have <code>[has_canonical_ring_hom R S]</code> typeclass with instances <code>has_canonical_ring_hom R R</code> and <code>[algebra R A] : has_canonical_ring_hom R A</code> and do some parts of linear algebra for maps from <code>semimodule R M</code> to <code>semimodule S M₂</code>.</p>



<a name="214442734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442734">(Oct 24 2020 at 18:43)</a>:</h4>
<p>with notation <code>M →ₗ[R] M'</code> using <code>R=S</code>.</p>



<a name="214442885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442885">(Oct 24 2020 at 18:46)</a>:</h4>
<p>Sometimes there is more than one "canonical" ring hom from R to S :-(</p>



<a name="214442905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442905">(Oct 24 2020 at 18:47)</a>:</h4>
<p>OK, this sounds doable.  Even though it would be a huge refactor, at least it's a joint generalization of linear and conjugate-linear maps, rather than a direct duplication of linear-map theory to conjugate-linear-map theory.</p>



<a name="214442983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442983">(Oct 24 2020 at 18:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Then we can have <code>linear_map (f : R →+* S) M M'</code></p>



<a name="214442986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214442986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214442986">(Oct 24 2020 at 18:48)</a>:</h4>
<p>Also, often all of <code>R</code>, <code>S</code> and the ring hom <code>f : R -&gt; S</code> would be variables, and then it will be annoying to stuff <code>f</code> into an instance even to write the statements of lemmas.</p>



<a name="214443001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443001">(Oct 24 2020 at 18:48)</a>:</h4>
<p>Right, I think we want something more like the latter</p>



<a name="214443028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443028">(Oct 24 2020 at 18:49)</a>:</h4>
<p>With notation both for the general form and <code>linear_map (ring_hom.id R) M M'</code>.</p>



<a name="214443153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443153">(Oct 24 2020 at 18:50)</a>:</h4>
<p>In an <a href="#narrow/stream/116395-maths/topic/Conjugate-linear.20maps">earlier discussion</a> about conjugate-linear maps, Johan mentioned Frobenius-linear maps.  I don't know anything about them, but are they covered by this construction?</p>



<a name="214443172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443172">(Oct 24 2020 at 18:51)</a>:</h4>
<p>I agree this is a useful notion--in technical mumbo-jumbo we're describing the category of (rings+modules) as a displayed category over the category of rings.</p>



<a name="214443336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443336">(Oct 24 2020 at 18:54)</a>:</h4>
<p>A Frobenius-linear map is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f:X\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>λ</mi><mi>p</mi></msup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\lambda x)=\lambda^p f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>. Here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a ring of characteristic <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> acting on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">x\mapsto x^p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> is hence a ring homomorphism.</p>



<a name="214443339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443339">(Oct 24 2020 at 18:54)</a>:</h4>
<p>About the original PR, I think this notion is useful too, but some things that could be instances of it might better be thought of as bimodules.</p>



<a name="214443358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443358">(Oct 24 2020 at 18:55)</a>:</h4>
<p>Where bimodule is defined as ...?</p>



<a name="214443359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443359">(Oct 24 2020 at 18:55)</a>:</h4>
<p>But we don't have right modules yet and thus don't have bimodules either.</p>



<a name="214443371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443371">(Oct 24 2020 at 18:55)</a>:</h4>
<p>Like in the traditional way--a left action of something and a right action of something else, that commute.</p>



<a name="214443429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443429">(Oct 24 2020 at 18:56)</a>:</h4>
<p>I suggest that we use <code>[semimodule R M] [semimodule (opposite R) M] [smul_comm_class R (opposite R) M]</code> for bimodules.</p>



<a name="214443434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443434">(Oct 24 2020 at 18:56)</a>:</h4>
<p>I think this sounds pretty miserable... writing things in the wrong order is a pain, and so is <code>opposite</code></p>



<a name="214443445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443445">(Oct 24 2020 at 18:56)</a>:</h4>
<p>We can introduce notation for right smul.</p>



<a name="214443472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443472">(Oct 24 2020 at 18:57)</a>:</h4>
<p>Something like <code>a ⋅' b = (op b) ⋅ a</code>.</p>



<a name="214443480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443480">(Oct 24 2020 at 18:57)</a>:</h4>
<p>Yes, something like that might be okay (and then we should have <code>right_submodule R M := submodule (opposite R) M</code>, etc.)</p>



<a name="214443571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443571">(Oct 24 2020 at 18:59)</a>:</h4>
<p>Anyways we should wait until someone really wants right modules/bimodules before doing anything there.</p>



<a name="214443582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443582">(Oct 24 2020 at 18:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214443336">said</a>:</p>
<blockquote>
<p>A Frobenius-linear map is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f:X\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>λ</mi><mi>p</mi></msup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\lambda x)=\lambda^p f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>. Here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a ring of characteristic <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> acting on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">x\mapsto x^p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> is hence a ring homomorphism.</p>
</blockquote>
<p>So it's a <code>linear_map frobenius X Y</code>, right?</p>



<a name="214443627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443627">(Oct 24 2020 at 19:00)</a>:</h4>
<p>and likewise we would have <code>linear_map conj V W</code>?</p>



<a name="214443794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443794">(Oct 24 2020 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214443582">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214443336">said</a>:</p>
<blockquote>
<p>A Frobenius-linear map is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f:X\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>λ</mi><mi>p</mi></msup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\lambda x)=\lambda^p f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>. Here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a ring of characteristic <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> acting on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">x\mapsto x^p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> is hence a ring homomorphism.</p>
</blockquote>
<p>So it's a <code>linear_map frobenius X Y</code>, right?</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214443627">said</a>:</p>
<blockquote>
<p>and likewise we would have <code>linear_map conj V W</code>?</p>
</blockquote>
<p>This sounds totally workable, and therefore evidence in favour of Yury's idea.</p>



<a name="214443916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443916">(Oct 24 2020 at 19:06)</a>:</h4>
<p>We'll need someone to write a tactic that takes a fact about <code>linear_map f M N</code> and turns it into a fact about <code>linear_map (ring_hom.id R) M N</code> replacing all applications of <code>f</code> with <code>id</code>s and removing <code>S</code> from the arguments. While I understand how <code>to_additive</code> works, it doesn't modify arity of functions etc.</p>



<a name="214443930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214443930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214443930">(Oct 24 2020 at 19:07)</a>:</h4>
<p>(the new theorem should be defeq to the old one, so no need to convert the proof)</p>



<a name="214444368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214444368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214444368">(Oct 24 2020 at 19:16)</a>:</h4>
<p>Note that we've seen several examples here where R=S but the canonical map isn't the identity.</p>



<a name="214444417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214444417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214444417">(Oct 24 2020 at 19:17)</a>:</h4>
<p>In the conjugation example, I think the map is between <code>opposite ℂ</code> and <code>ℂ</code>, rather than from <code>ℂ</code> to itself?</p>



<a name="214444512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214444512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214444512">(Oct 24 2020 at 19:19)</a>:</h4>
<p>We can think about it both ways</p>



<a name="214444784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214444784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214444784">(Oct 24 2020 at 19:24)</a>:</h4>
<p>There is the following advantage to making it the conjugation homomorphism a map from <code>is_R_or_C</code> to itself (rather than <code>opposite</code>): if I understand correctly, the conjugation will then be defeq to the identity in the case of <code>ℝ</code>, and so a conjugate-linear map over <code>ℝ</code> will, definitionally, be a linear map.  This would allow for cleaner statements of some of the results in <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> ' PR.</p>



<a name="214444860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214444860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214444860">(Oct 24 2020 at 19:26)</a>:</h4>
<p>If R=S then an f-linear map will be linear over the subring of R consisting of things fixed by f I guess.</p>



<a name="214446313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446313">(Oct 24 2020 at 19:58)</a>:</h4>
<p>Unfortunately, we can't make a <code>symm</code> instance for <code>smul_comm_class</code> in Lean 3.</p>



<a name="214446327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446327">(Oct 24 2020 at 19:58)</a>:</h4>
<p>So, we have to choose what comes first.</p>



<a name="214446347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446347">(Oct 24 2020 at 19:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">S</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">R</span> <span class="n">S</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_scalar</span> <span class="n">S</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">f</span> <span class="n">b</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">f.map_add</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">],</span>
  <span class="bp">λ</span> <span class="n">c</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f.map_smul</span><span class="o">,</span> <span class="n">smul_comm</span> <span class="n">c</span><span class="o">]⟩⟩</span>
</code></pre></div>

<p>Should it be like this or <code>smul_comm_class S R M₂</code>?</p>



<a name="214446419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446419">(Oct 24 2020 at 20:00)</a>:</h4>
<p>The class is a <code>Prop</code> anyways, so I think there's not much danger in just picking randomly at the use site and providing both orders at the instance definition site</p>



<a name="214446436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446436">(Oct 24 2020 at 20:01)</a>:</h4>
<p>... though with bimodules you won't have this problem <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="214446465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446465">(Oct 24 2020 at 20:01)</a>:</h4>
<p>I hope we'll see Lean 4 soon, and add <code>symm</code> instance.</p>



<a name="214446479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214446479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214446479">(Oct 24 2020 at 20:02)</a>:</h4>
<p>(where "soon" means "this year")</p>



<a name="214447373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/214447373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#214447373">(Oct 24 2020 at 20:18)</a>:</h4>
<p>As a temporary measure we can have a <code>symm</code> <code>lemma</code> and, though it might not actually be worthwhile, a linter which checks that each instance has a <code>symm</code> version</p>



<a name="220734935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220734935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220734935">(Dec 22 2020 at 21:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214443429">said</a>:</p>
<blockquote>
<p>I suggest that we use <code>[semimodule R M] [semimodule (opposite R) M] [smul_comm_class R (opposite R) M]</code> for bimodules.</p>
</blockquote>
<p><code>smul_comm_class</code> is in mathlib now. Is there a reason (other than time) that I shouldn't make a PR with this definition of <code>bimodule</code> and the other basic API for bimodules that's been discussed?</p>



<a name="220735013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220735013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220735013">(Dec 22 2020 at 21:15)</a>:</h4>
<p>I'd really like to see ideals and two-sided ideals distinguished from each other.</p>



<a name="220739753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220739753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220739753">(Dec 22 2020 at 22:14)</a>:</h4>
<p>Go ahead. I don't know whether we should have a <code>bimodule</code> typeclass that extends three typeclasses, or use these three arguments every time we speak about bimodules. And we need some notation for <code>op a • b</code> (something like <code>b •ᵣ a</code>). If you keep it as a notation (not a <code>def</code>), then you can apply lemmas about <code>smul</code> directly.</p>



<a name="220740223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220740223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220740223">(Dec 22 2020 at 22:20)</a>:</h4>
<p>I ran into trouble getting a <code>bimodule</code>typeclass that extends all three off the ground, so I'm writing a draft that is just an abbreviation for <code>smul_comm_class</code>. I think defining right modules and bimodules is easy enough, but <code>subbimodule</code>s may get kind of weird.</p>



<a name="220740510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220740510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220740510">(Dec 22 2020 at 22:23)</a>:</h4>
<p>You can extend two <code>semimodule</code> classes, have an axiom equivalent to <code>smul_comm_class</code>, and an instances from <code>[bimodule R M]</code> to <code>smul_comm_class R (opposite R) M</code> and <code>smul_comm_class (opposite R) R M</code>. Then you'll be able to apply theorems about <code>smul_comm_class</code>.</p>



<a name="220740603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220740603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220740603">(Dec 22 2020 at 22:24)</a>:</h4>
<p>The problem was with extending two <code>semimodule</code> classes. It didn't work for me, either with or without <code>old_structure_cmd</code>.</p>



<a name="220740713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220740713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220740713">(Dec 22 2020 at 22:25)</a>:</h4>
<p>I've pushed to <a href="https://github.com/leanprover-community/mathlib/tree/bimodule">branch#bimodule</a>, although the API for <code>subbimodule</code> isn't really there yet</p>



<a name="220744110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220744110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220744110">(Dec 22 2020 at 22:59)</a>:</h4>
<p>If you define <code>right_semimodule := semimodule (opposite R) M</code>, can you extend <code>right_semimodule</code> without <code>old_structure_cmd</code>?</p>



<a name="220744145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220744145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220744145">(Dec 22 2020 at 22:59)</a>:</h4>
<p>Because right now your problem is:</p>
<ul>
<li><code>old_structure_cmd = True</code>: you have two <code>zero_add</code> fields, which have different types</li>
<li><code>old_structure_cmd = False</code>: you have two <code>to_semimodule</code> fields, which have different types</li>
</ul>



<a name="220744209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220744209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220744209">(Dec 22 2020 at 23:00)</a>:</h4>
<p>My thinking is maybe you can trick lean into generating one field called <code>to_right_semimodule</code></p>



<a name="220744285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220744285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220744285">(Dec 22 2020 at 23:01)</a>:</h4>
<p>Oh, this is something Reid (I think) told me not to do anyway, for the same reason that <code>semimodule</code> does not extend <code>semiring</code>; you shouldn't extend things that don't use all your type arguments.</p>



<a name="220744704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220744704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220744704">(Dec 22 2020 at 23:06)</a>:</h4>
<p>Sorry, I haven't realized that we're going to have <code>bimodule R S M</code>, not <code>bimodule R M</code>.</p>



<a name="220744757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/4770%20smul_comm_class/near/220744757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/4770.20smul_comm_class.html#220744757">(Dec 22 2020 at 23:07)</a>:</h4>
<p>Yes, <code>bimodule R S M</code> may be an abbreviation (or even a notation) for <code>smul_comm_class R (opposite S) M</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
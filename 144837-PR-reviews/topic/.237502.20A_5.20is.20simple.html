---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html">#7502 A_5 is simple</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238116371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238116371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238116371">(May 10 2021 at 10:14)</a>:</h4>
<p>I was expecting to find the "count conj classes" proof. But this seems to be a different proof. What is the high-level argument? (This should probably be in a module doc.)<br>
I wish most of this proof could be automated, but that's probably not reasonable atm.</p>



<a name="238116399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238116399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238116399">(May 10 2021 at 10:14)</a>:</h4>
<p>(cc: <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> <span class="user-mention" data-user-id="253861">@Thomas Browning</span>)</p>



<a name="238117911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238117911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238117911">(May 10 2021 at 10:29)</a>:</h4>
<p>In general, I'd say nontrivial math arguments should either have a lot of comments in them saying what is going on, or written with a more litterate style that makes it obvious (with a lot of <code>have</code>, or <code>show</code>, or <code>suffices</code>, or <code>obtain</code>) -- or both, maybe. For instance, Line 276 reads</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gA</span><span class="o">⟩,</span> <span class="n">gH</span><span class="o">,</span> <span class="n">g1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">Hb</span><span class="o">,</span>
</code></pre></div>
<p>Just adding the type, with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gA</span><span class="o">⟩,</span> <span class="n">gH</span><span class="o">,</span> <span class="n">g1</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">alternating_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">5</span><span class="o">)),</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">∧</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">:=</span> <span class="n">Hb</span><span class="o">,</span>
</code></pre></div>
<p>helps a lot the reader.</p>



<a name="238118040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238118040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238118040">(May 10 2021 at 10:30)</a>:</h4>
<p>I also agree that this terse comment-free style which we mathematicians inherited from Johannes and Mario should not always be the norm nowadays</p>



<a name="238118071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238118071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238118071">(May 10 2021 at 10:31)</a>:</h4>
<p>(I should also say that your work on Abel-Ruffini is fantastic!)</p>



<a name="238119164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238119164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238119164">(May 10 2021 at 10:40)</a>:</h4>
<p>I very much agree with Sébastien.</p>



<a name="238169963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238169963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238169963">(May 10 2021 at 16:19)</a>:</h4>
<p>I can add comments later to the module doc and throughout the doc itself, but for now as a quick summary, the idea is to show that any nontrivial normal subgroup of A5 contains a 3-cycle. To do that, we pick an element of that nontrivial normal subgroup, and do casework on the size of the largest cycle in that element. If that cycle is a 5-cycle, then the whole permutation is a 5-cycle, and we calculate that we can conjugate-and-multiply a particular 5-cycle to get a 3-cycle. If it's a 4-cycle, there's a contradiction. If it's a 3-cycle, then squaring our permutation is a 3-cycle. If it's a 2-cycle, then our permutation is conjugate to (12)(34), and we check that a particular permutation of this cycle type can generate a 3-cycle.</p>



<a name="238171022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238171022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238171022">(May 10 2021 at 16:25)</a>:</h4>
<p>I will say though that I thought I would originally prove all An (for n&gt;4) are simple this way, hence wanting to avoid doing conj class counting, but then there was just a little too much explicit computation in that proof, so I switched track to just proving it for A5, and then later I'd do an induction... I think the induction will have to include some of these ideas, but the conjugacy class counting may be necessary anyway eventually, for say representation theory.</p>



<a name="238171102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238171102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238171102">(May 10 2021 at 16:26)</a>:</h4>
<p>I can also include a link to a source following this reasoning (but for all large A_n): <a href="https://people.reed.edu/~jerry/332/08ansim.pdf">https://people.reed.edu/~jerry/332/08ansim.pdf</a></p>



<a name="238171202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238171202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238171202">(May 10 2021 at 16:26)</a>:</h4>
<p>It may well actually prove reasonable to follow this explicit 3-cycle computation approach for large A_n once <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> 's work gets far enough</p>



<a name="238172019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238172019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238172019">(May 10 2021 at 16:32)</a>:</h4>
<p>I think it would be a great test case to see if the conj-class-counting proof can be made really short and slick.</p>



<a name="238172200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238172200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238172200">(May 10 2021 at 16:33)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> thanks for explaining the idea behind the proof!</p>



<a name="238180734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238180734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238180734">(May 10 2021 at 17:29)</a>:</h4>
<p>I think that counting conjugacy classes in general could require <em>more</em> dependence on explicit list representations than this, because the proof I'm thinking of really involves an explicit bijection of lists. There may be a way around that though, particularly if we just want to do A5.</p>



<a name="238181827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238181827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238181827">(May 10 2021 at 17:36)</a>:</h4>
<p>If there is a decent orbit-stabilizer way to do it, then that's definitely worth developing.</p>



<a name="238190572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238190572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238190572">(May 10 2021 at 18:32)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Did you consider using Iwasawa's criterion: <a href="https://kconrad.math.uconn.edu/blurbs/grouptheory/PSLnsimple.pdf">https://kconrad.math.uconn.edu/blurbs/grouptheory/PSLnsimple.pdf</a></p>



<a name="238191549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238191549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238191549">(May 10 2021 at 18:39)</a>:</h4>
<p>I haven’t considered that, but that also requires showing that permutations of cycle type (2,2) normal-generate A5, which is a large fraction of my existing proof (at least, that exact argument does)</p>



<a name="238195818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238195818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238195818">(May 10 2021 at 19:08)</a>:</h4>
<p>It does look like a good thing to work on sooner or later, if we want to keep classifying easy simple groups</p>



<a name="238685988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238685988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238685988">(May 13 2021 at 21:46)</a>:</h4>
<p>In retrospect, the right way to start this project, as with all projects, would be to read through all possibly relevant Keith Conrad notes.</p>



<a name="238686030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238686030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238686030">(May 13 2021 at 21:46)</a>:</h4>
<p>I think the best strategy for tackling An in general is probably the second proof here <a href="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf">https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf</a></p>



<a name="238686094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238686094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238686094">(May 13 2021 at 21:47)</a>:</h4>
<p>It basically only requires tools I have and two base cases, A5 and A6</p>



<a name="238689107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238689107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238689107">(May 13 2021 at 22:14)</a>:</h4>
<p>You should get Keith onto the chat :-) I gave a talk at UMD last week and he was there, he asked a bunch of questions about what could be done</p>



<a name="238709773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238709773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238709773">(May 14 2021 at 02:33)</a>:</h4>
<p>I’ve commented my PR more - please let me know if you want further comments</p>



<a name="238709782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238709782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238709782">(May 14 2021 at 02:34)</a>:</h4>
<p>I’ll also check out alternate approaches</p>



<a name="238912759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238912759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238912759">(May 15 2021 at 17:22)</a>:</h4>
<p>I have a somewhat short proof that the commutator of the alternating group is itself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">commutator</span> <span class="o">(</span><span class="n">h5</span> <span class="o">:</span> <span class="mi">5</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⁅</span><span class="n">alternating_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">alternating_group</span> <span class="n">α</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="n">alternating_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">general_commutator_le_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
    <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="n">closure_three_cycles_eq_alternating.symm</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">closure_le</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">g</span> <span class="n">hg</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">s5</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finset.univ.exists_smaller_set</span> <span class="mi">5</span> <span class="n">h5</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">equiv_fin</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">})</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[(</span><span class="n">card_of_subtype</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">iff.refl</span> <span class="n">_</span><span class="o">)),</span> <span class="n">s5</span><span class="o">]</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">is_conj</span> <span class="o">(</span><span class="n">extend_domain</span> <span class="o">(</span><span class="n">fin.cycle_range</span> <span class="mi">2</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">is_conj_iff_cycle_type_eq</span><span class="o">,</span> <span class="n">hg.cycle_type</span><span class="o">,</span> <span class="n">cycle_type_extend_domain</span><span class="o">,</span>
      <span class="n">fin.cycle_type_cycle_range</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">dec_trivial</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">is_conj_iff.1</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">set_like.mem_coe.2</span> <span class="o">((</span><span class="n">general_commutator_normal</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">conj_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">c</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">general_commutator_def</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">subset_closure</span> <span class="o">⟨(</span><span class="n">extend_domain</span> <span class="o">(</span><span class="n">swap</span> <span class="mi">1</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">swap</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">)</span> <span class="n">f</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">(</span><span class="n">extend_domain</span> <span class="o">(</span><span class="n">swap</span> <span class="mi">0</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">swap</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">)</span> <span class="n">f</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_alternating_group</span><span class="o">,</span> <span class="n">sign_extend_domain</span><span class="o">],</span>
    <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_alternating_group</span><span class="o">,</span> <span class="n">sign_extend_domain</span><span class="o">],</span>
    <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">extend_domain_mul</span><span class="o">,</span> <span class="n">mul_inv_rev</span><span class="o">,</span> <span class="n">extend_domain_inv</span><span class="o">,</span> <span class="n">swap_inv</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
  <span class="n">interval_cases</span> <span class="n">x</span><span class="bp">;</span>
  <span class="n">dec_trivial</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238912808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237502%20A_5%20is%20simple/near/238912808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237502.20A_5.20is.20simple.html#238912808">(May 15 2021 at 17:23)</a>:</h4>
<p>This maybe lends support for trying some kind of transitivity proof (by the Iwasawa criterion or similar) and would certainly make a simple proof of non-solvability.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.237118.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html">#7118</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="236179440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236179440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236179440">(Apr 26 2021 at 14:05)</a>:</h4>
<p>I'd like to generalize <code>perm.support</code> to <code>set</code> instead of <code>finset</code>. In my opinion, this leads to cleaner definitions regarding <code>disjoint</code>. Additionally, it allows one to talk about any support, not just over finite permutations. Understandably, some statements about cardinality of supports get more clunky. But one is always free to either provide the support explicitly (as finset) or to conjure a <code>set.finite</code> proof. Happy to hear thoughts. Related to this refactor I have PRs about concrete constructions of <code>perm</code> from a list that is precisely the support, with planned follow-up of a <code>cycle</code> defined as a list quotient. My hope is to provide a notation for <code>perm</code> similar to how <code>data.matrix.notation</code> works</p>



<a name="236208034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236208034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236208034">(Apr 26 2021 at 16:59)</a>:</h4>
<p>Would it make sense to define the subgroup of permutations with finite support? You could have API translating between the two types of permutations, but then the lemmas about cardinality of support would be nicer (because if you are working with permutations with finite support, then the support would be a finset)</p>



<a name="236208418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236208418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236208418">(Apr 26 2021 at 17:01)</a>:</h4>
<p>Do we have <code>fincard</code> yet? One could rely on those too.</p>



<a name="236209083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236209083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236209083">(Apr 26 2021 at 17:05)</a>:</h4>
<p>It just seems to me that a lot of lemmas (in cycles, sign, cycletype, etc...) are really about permutations with finite support, and to me it makes sense to at least bundle permutations with finite support as a subgroup, so that you can easily say things like "the sign is a group homomorphism"</p>



<a name="236209782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236209782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236209782">(Apr 26 2021 at 17:10)</a>:</h4>
<p>Right -- so <code>{p // p.support.finite}</code> as a subgroup?</p>



<a name="236209942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236209942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236209942">(Apr 26 2021 at 17:11)</a>:</h4>
<p>Yes. And once you've done that, it might make sense to define a finset version of support for those permutations (it's possible <code>fincard</code> is good enough, but I haven't used it so I don't know)</p>



<a name="236210135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236210135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236210135">(Apr 26 2021 at 17:12)</a>:</h4>
<p>OK. <code>fincard</code> is a perennial suggestion, doesn't exist yet unfortunately</p>



<a name="236210790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236210790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236210790">(Apr 26 2021 at 17:16)</a>:</h4>
<p>How would you then structure proving the Schreier Ulam theorem referenced here? <a href="https://mathoverflow.net/questions/12291/find-a-natural-group-that-contains-the-quotient-of-the-infinite-symmetric-grou">https://mathoverflow.net/questions/12291/find-a-natural-group-that-contains-the-quotient-of-the-infinite-symmetric-grou</a></p>



<a name="236211214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236211214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236211214">(Apr 26 2021 at 17:19)</a>:</h4>
<p>There's overloading of <code>equiv.perm</code> -- does it mean solely <code>automorphism</code> or restricted to <code>finite permutation</code>?</p>



<a name="236211735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236211735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236211735">(Apr 26 2021 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/144837-PR-reviews/topic/.237118/near/236210790">said</a>:</p>
<blockquote>
<p>How would you then structure proving the Schreier Ulam theorem referenced here? <a href="https://mathoverflow.net/questions/12291/find-a-natural-group-that-contains-the-quotient-of-the-infinite-symmetric-grou">https://mathoverflow.net/questions/12291/find-a-natural-group-that-contains-the-quotient-of-the-infinite-symmetric-grou</a></p>
</blockquote>
<p>Looks like a good theorem, and I sort of see how to prove it, but why do you ask how to structure the proof?</p>



<a name="236211965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236211965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236211965">(Apr 26 2021 at 17:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/144837-PR-reviews/topic/.237118/near/236211214">said</a>:</p>
<blockquote>
<p>There's overloading of <code>equiv.perm</code> -- does it mean solely <code>automorphism</code> or restricted to <code>finite permutation</code>?</p>
</blockquote>
<p>What do you mean by this? As far as I understand, <code>equiv.perm</code> means arbitrary bijective function, and there would be another name for finite permutations.</p>



<a name="236212913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236212913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236212913">(Apr 26 2021 at 17:30)</a>:</h4>
<p>Sorry, I wasn't clear. I was thinking of an API that allows one to make statements like "support = countable union of swaps" or "support = countable union of disjoint cycles".</p>



<a name="236212987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236212987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236212987">(Apr 26 2021 at 17:30)</a>:</h4>
<p>(Also, just noticed that one of the top answers is by Kevin)</p>



<a name="236213055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236213055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236213055">(Apr 26 2021 at 17:31)</a>:</h4>
<p>So, alright, I'll build in the additional <code>equiv.perm.finite</code> subgroup.</p>



<a name="236258799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236258799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236258799">(Apr 26 2021 at 23:10)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> , I implemented the proverbial <code>fincard</code> as <code>nat.card</code></p>



<a name="236258857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236258857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236258857">(Apr 26 2021 at 23:11)</a>:</h4>
<p>Ah, wonderful</p>



<a name="236258969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236258969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236258969">(Apr 26 2021 at 23:12)</a>:</h4>
<p>Doesn't interop with sets though, right?</p>



<a name="236258975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236258975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236258975">(Apr 26 2021 at 23:12)</a>:</h4>
<p>Or, at least, not yet?</p>



<a name="236560771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236560771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236560771">(Apr 28 2021 at 19:02)</a>:</h4>
<p><span class="user-mention" data-user-id="253861">@Thomas Browning</span>  for the subgroup of finite permutations, initially, this would all be <code>noncomputable</code>, correct? Because <code>set.finite</code> doesn't lend itself to a computable fintype easily.</p>



<a name="236561257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236561257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236561257">(Apr 28 2021 at 19:05)</a>:</h4>
<p>I guess so, although I am not super familiar with computability.</p>



<a name="236582575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236582575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236582575">(Apr 28 2021 at 21:21)</a>:</h4>
<p>Feel free to take a look at <a href="https://github.com/leanprover-community/mathlib/tree/pechersky/finite-perm-subgroup">branch#pechersky/finite-perm-subgroup</a> for an extension of <code>perm.sign</code> to any finite perm, even if the underlying type isn't finite. And there is a proof the two are the same if the underlying type _is_ finite.</p>



<a name="236601117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/236601117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#236601117">(Apr 29 2021 at 00:30)</a>:</h4>
<p>Great. Is there any reason to keep the old <code>perm.sign</code> then?</p>



<a name="237103645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/237103645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#237103645">(May 03 2021 at 02:15)</a>:</h4>
<p>Yes, I think there is. I think the refactor has to be done piecemeal</p>



<a name="237103662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%237118/near/237103662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.237118.html#237103662">(May 03 2021 at 02:15)</a>:</h4>
<p>Because most of <code>sign</code> has been used for things over fintype anyway</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
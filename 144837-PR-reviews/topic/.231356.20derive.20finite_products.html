---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html">#1356 derive finite_products</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="174565393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174565393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174565393">(Aug 30 2019 at 17:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> I'd love some feedback on this PR</p>



<a name="174566050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566050">(Aug 30 2019 at 17:35)</a>:</h4>
<p>Which PR do you mean <span class="user-mention" data-user-id="110026">@Simon Hudon</span> ? Nr <a href="https://github.com/leanprover-community/mathlib/issues/1365" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1365">#1365</a> or the one about derive finite_products?</p>



<a name="174566055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566055">(Aug 30 2019 at 17:35)</a>:</h4>
<p>They are not the same...</p>



<a name="174566122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566122">(Aug 30 2019 at 17:36)</a>:</h4>
<p>Aah, you mean <a href="https://github.com/leanprover-community/mathlib/issues/1356" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1356">#1356</a></p>



<a name="174566188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566188">(Aug 30 2019 at 17:37)</a>:</h4>
<p>It seems that Scott developed a competing approach... right?</p>



<a name="174566287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566287">(Aug 30 2019 at 17:38)</a>:</h4>
<p>Or is it complementary?</p>



<a name="174566479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566479">(Aug 30 2019 at 17:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Can you give me a 3-line introduction to <code>enumerable</code>? How does it relate to <code>fintype</code> (which you are substituting it for, in this PR).</p>



<a name="174566499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566499">(Aug 30 2019 at 17:41)</a>:</h4>
<p>Is every <code>enumerable</code> type finite? Or is <code>nat</code> also <code>enumerable</code>?</p>



<a name="174566525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566525">(Aug 30 2019 at 17:41)</a>:</h4>
<p>It is complementary. Here is what I saw happen. I tried to define cartesian categories, Scott came up with a better idea, his idea got merged, now I'm trying to come up with helper functions to facilitate going from specific limits (i.e. binary products) to the general formulation</p>



<a name="174566538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566538">(Aug 30 2019 at 17:41)</a>:</h4>
<p>Aha, I see.</p>



<a name="174566588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566588">(Aug 30 2019 at 17:42)</a>:</h4>
<p>I didn't read the <code>enumerable</code> PR. Maybe I should.</p>



<a name="174566965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566965">(Aug 30 2019 at 17:46)</a>:</h4>
<p>Huh, there was a recent PR on enumerable, right? Or am I hallucinating?</p>



<a name="174566983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566983">(Aug 30 2019 at 17:46)</a>:</h4>
<p>Anyway, <span class="user-mention" data-user-id="110026">@Simon Hudon</span> Can you confirm that an <code>enumerable</code> type is finite?</p>



<a name="174566999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174566999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174566999">(Aug 30 2019 at 17:46)</a>:</h4>
<p>There was one: <a href="https://github.com/leanprover-community/mathlib/pull/1368" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/1368">https://github.com/leanprover-community/mathlib/pull/1368</a></p>



<a name="174567029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174567029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174567029">(Aug 30 2019 at 17:47)</a>:</h4>
<p>Now that I look at it, the documentation is ... lacking</p>



<a name="174567150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174567150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174567150">(Aug 30 2019 at 17:48)</a>:</h4>
<p>It is meant as a (more) constructive substitute for <code>fintype</code>. This we can have access to a bijection between fin (card a) and a without using the axiom of choice</p>



<a name="174567796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174567796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174567796">(Aug 30 2019 at 17:57)</a>:</h4>
<p>Aha, I see.</p>



<a name="174567824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174567824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174567824">(Aug 30 2019 at 17:57)</a>:</h4>
<p>As a mathematician I would expect that <code>nat</code> is also enumerable. But then... what's in a name...</p>



<a name="174568273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568273">(Aug 30 2019 at 18:01)</a>:</h4>
<p>Yeah, me too. I debated it with <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> . It kind of sounds like something from computability theory. We just need a name that says a bit more than that a type is finite. <code>has_equiv_to_fin</code> is not exactly catchy. I feel like there are a lot of bad options here.</p>



<a name="174568368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568368">(Aug 30 2019 at 18:02)</a>:</h4>
<p>Hmm... so does <a href="https://github.com/leanprover-community/mathlib/issues/1356" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1356">#1356</a> (finite products) depend on <a href="https://github.com/leanprover-community/mathlib/issues/1368" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1368">#1368</a> (enum)?</p>



<a name="174568400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568400">(Aug 30 2019 at 18:02)</a>:</h4>
<p>If so, it would be good to point that out on the PR page (and preferably in the title).</p>



<a name="174568437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568437">(Aug 30 2019 at 18:03)</a>:</h4>
<p><code>finumerable</code>?</p>



<a name="174568443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568443">(Aug 30 2019 at 18:03)</a>:</h4>
<p>kidding</p>



<a name="174568602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568602">(Aug 30 2019 at 18:05)</a>:</h4>
<p>Good point. Done :)</p>



<a name="174568608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568608">(Aug 30 2019 at 18:05)</a>:</h4>
<p>So <code>fintype</code> is a property, and <code>enumerable</code> has data. I see. I'm now reading <a href="https://github.com/leanprover-community/mathlib/issues/1368" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1368">#1368</a>...</p>



<a name="174568617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568617">(Aug 30 2019 at 18:05)</a>:</h4>
<p><code>finumerable</code></p>



<a name="174568637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568637">(Aug 30 2019 at 18:05)</a>:</h4>
<p>Well, <code>fintype</code> also has data</p>



<a name="174568723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568723">(Aug 30 2019 at 18:06)</a>:</h4>
<p>Huh, does it?</p>



<a name="174568742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568742">(Aug 30 2019 at 18:06)</a>:</h4>
<p>Oh, you're right</p>



<a name="174568760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568760">(Aug 30 2019 at 18:06)</a>:</h4>
<p>So should I just stop using <code>fintype</code> alltogether?</p>



<a name="174568849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568849">(Aug 30 2019 at 18:08)</a>:</h4>
<p>I would characterize it more as <code>fintype_with_order</code></p>



<a name="174568936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174568936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174568936">(Aug 30 2019 at 18:08)</a>:</h4>
<p>Thanks, that makes sense.</p>



<a name="174569092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174569092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174569092">(Aug 30 2019 at 18:10)</a>:</h4>
<p>I probably won't have time to look at PRs until Tuesday, but for a mathematician "finite products" means products indexed by a finite type and not products indexed by a finite-type-with-order, and I think it's pretty important.</p>



<a name="174569164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174569164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174569164">(Aug 30 2019 at 18:11)</a>:</h4>
<p>Using <code>choice</code> to choose an order to reduce finite products to binary ones should be fine, as that order should not be visible in the API anyways</p>



<a name="174569836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174569836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174569836">(Aug 30 2019 at 18:19)</a>:</h4>
<p>It was pointed out to me that taking different permutations of the same type might not produce limits that are equal, rather, it would produce limits that are equivalent. I wonder if that wouldn't justify making the order more explicit rather than less explicit</p>



<a name="174569928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174569928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174569928">(Aug 30 2019 at 18:20)</a>:</h4>
<p>I mean "... limits that are isomorphic"</p>



<a name="174570363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174570363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174570363">(Aug 30 2019 at 18:25)</a>:</h4>
<p>Hmm... I'm not so sure.</p>



<a name="174570436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174570436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174570436">(Aug 30 2019 at 18:26)</a>:</h4>
<p>If you want a different permutation, you should change the diagram (i.e. functor) not the enumeration of the type.</p>



<a name="174571041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174571041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174571041">(Aug 30 2019 at 18:33)</a>:</h4>
<p>That makes sense. Alright! I'll go back to making things non-constructive.</p>



<a name="174571207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174571207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174571207">(Aug 30 2019 at 18:35)</a>:</h4>
<p>I still think <code>enumerable</code> is a nice type. But maybe not so much for this application )-;</p>



<a name="174571745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174571745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174571745">(Aug 30 2019 at 18:41)</a>:</h4>
<p>This actually makes me doubt the usefulness of <code>enumerable</code>. <code>fintype</code> has this function:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">equiv_fin</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span> <span class="n">fin</span> <span class="o">(</span><span class="n">card</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">...</span>
</pre></div>


<p>which means that you can use a bijection as long as you can prove that any bijection will do. The reason I couldn't use it for finite products is that the result are the same only up to isomorphism, not equality. I'm wondering if it's a signal that destroying the symmetry between the elements of an empty type is not such a good idea.</p>



<a name="174571927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174571927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174571927">(Aug 30 2019 at 18:43)</a>:</h4>
<p>Huh, which empty type are you talking about?</p>



<a name="174572005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174572005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174572005">(Aug 30 2019 at 18:44)</a>:</h4>
<p>"finite type" is what I meant</p>



<a name="174572027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174572027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174572027">(Aug 30 2019 at 18:44)</a>:</h4>
<p>Aha...</p>



<a name="174572089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174572089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174572089">(Aug 30 2019 at 18:45)</a>:</h4>
<p>Maybe <code>def enum [fintype X] [linear_order X] : fin (card X) → X</code>is sufficient for all purposes?</p>



<a name="174572181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174572181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174572181">(Aug 30 2019 at 18:46)</a>:</h4>
<p>Especially if you also have decidable equality... than you might even be able to make that definition constructive(?)</p>



<a name="174572215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174572215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174572215">(Aug 30 2019 at 18:46)</a>:</h4>
<p>You would need a decidable linear order. Then the problem is the same as sorting</p>



<a name="174573698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174573698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174573698">(Aug 30 2019 at 19:04)</a>:</h4>
<p>Maybe you need the idea of an "approximate object", or an isomorphism equivalence class of objects</p>



<a name="174573915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174573915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174573915">(Aug 30 2019 at 19:07)</a>:</h4>
<p>If I may make a last ditch effort to save my <code>enumerable</code>-based solution:</p>
<blockquote>
<p>for a mathematician "finite products" means products indexed by a finite type and not products indexed by a finite-type-with-order, and I think it's pretty important.</p>
</blockquote>
<p>The difference might be less significant than one thinks. If I formulate finite products in terms of <code>enumerable</code> and you want to use it with a type for which you only have <code>fintype</code>, there's a non-computable way to go from <code>fintype</code> to enumerable. By keeping the definition in terms of <code>enumerable</code> that gives you the freedom to use it in a context where you need computability. If you're willing to sacrifice computability, the definition becomes as general as the one using <code>fintype</code> instead of <code>enumerable</code></p>



<a name="174574105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174574105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174574105">(Aug 30 2019 at 19:09)</a>:</h4>
<p>Is there a name for a category where every pair of objects has a designated morphism? Like the category version of the total relation</p>



<a name="174574230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174574230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174574230">(Aug 30 2019 at 19:11)</a>:</h4>
<p>I don't know. Why?</p>



<a name="174574294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174574294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174574294">(Aug 30 2019 at 19:12)</a>:</h4>
<p>Is it for a version of trunc transported onto isomorphisms?</p>



<a name="174574603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174574603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174574603">(Aug 30 2019 at 19:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> A category enriched over pointed sets (types).</p>



<a name="174574648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174574648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174574648">(Aug 30 2019 at 19:17)</a>:</h4>
<p>I assume you want the distinguished morphisms to be stable under composition</p>



<a name="174583718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174583718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174583718">(Aug 30 2019 at 21:24)</a>:</h4>
<p>An approximate object should be a diagram over such a category</p>



<a name="174584197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174584197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174584197">(Aug 30 2019 at 21:32)</a>:</h4>
<p>and a finite product over a fintype yields an approximate object where the index category is the set of <code>enumerable A</code> witnesses to <code>fintype A</code>, and the functor builds the ordered  product from the witness. The morphisms of the index category are bijections on fin n agreeing with the enumerable orders</p>



<a name="174584424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174584424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174584424">(Aug 30 2019 at 21:34)</a>:</h4>
<p>It's not clear to me whether the distinguished morphisms need to be stable under composition, but it does seem natural. In this case it's a poset category so that is automatic</p>



<a name="174584582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174584582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174584582">(Aug 30 2019 at 21:37)</a>:</h4>
<p>I guess an approximate object should also be nonempty, and the sense of nonempty that agrees with the given application is <code>trunc J</code> where <code>J</code> is the index category</p>



<a name="174587257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174587257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174587257">(Aug 30 2019 at 22:21)</a>:</h4>
<p>I think we actually want a nonempty category enriched in singletons; why would you want to pay attention to the "non-designated" morphisms?</p>



<a name="174587979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174587979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174587979">(Aug 30 2019 at 22:33)</a>:</h4>
<p>I like the following picture:</p>
<p>Suppose you are making some construction say of some Widget, that depends on choices. Let J be the set of choices, and think of your construction as a bundle, whose base space is J, and each fibre has the structure of a Widget. Now for each "path" between choices j and j', we want a "parallel transport" identifying the fibre over j with the fibre over j' (as Widgets). At this point we can make the candidate definition that our "real construction" is the set of flat sections of this fibre bundle --- no choices involved! (In some sense, they were 'deferred'.) We need one more fact before this is a satisfactory definition, that is, that our parallel transport is _flat_, i.e. that transporting from j to j' and then to j'' is the same as transporting directly from j to j''. Then an easy consequence is that the "evaluation map" taking a flat section and looking at its value at a point j is an isomorphism for every j.</p>
<p>This description was very geometrical, but it's actually just the purely categorical discussion we've been having. We model J as a category so that <code>\forall X Y, unique (X \hom Y)</code>, and ask that our construction is a functor <code>J \func Widget</code>. This captures nicely the notion of a bundle with a flat connection. Of course "flat sections" can now be interpreted just as the limit of this functor. (If we can take limits in the underlying types, this says that a point in the limit is a point in the product of all the fibres, such that the chosen value in each fibre is carried by the morphisms to the chosen value in the other fibres.)</p>
<p>Of course, non-constructively, any category has limits of shape J when J is nonempty and enriched in singletons --- just pick arbitrarily a point j in J, and declare that <code>limit F = F.obj j</code>.</p>



<a name="174588032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174588032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174588032">(Aug 30 2019 at 22:34)</a>:</h4>
<p>I'm not entirely certain what a "good API" for this idea would look like. Suggestions welcome.</p>



<a name="174588062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174588062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174588062">(Aug 30 2019 at 22:34)</a>:</h4>
<p>I think every mathematician has "used this construction" many times, even if they haven't phrased it this way. It's a lovely way to hide away arbitrary choices in a construction.</p>



<a name="174592592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174592592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174592592">(Aug 31 2019 at 00:19)</a>:</h4>
<blockquote>
<p>If I may make a last ditch effort to save my <code>enumerable</code>-based solution:</p>
<blockquote>
<p>for a mathematician "finite products" means products indexed by a finite type and not products indexed by a finite-type-with-order, and I think it's pretty important.</p>
</blockquote>
<p>The difference might be less significant than one thinks. If I formulate finite products in terms of <code>enumerable</code> and you want to use it with a type for which you only have <code>fintype</code>, there's a non-computable way to go from <code>fintype</code> to enumerable. By keeping the definition in terms of <code>enumerable</code> that gives you the freedom to use it in a context where you need computability. If you're willing to sacrifice computability, the definition becomes as general as the one using <code>fintype</code> instead of <code>enumerable</code></p>
</blockquote>
<p>We could have the <code>enumerable</code> definition and the <code>fintype</code> one built on top of it (using choice), just as long as the <code>fintype</code> one exists.</p>



<a name="174592695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174592695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174592695">(Aug 31 2019 at 00:21)</a>:</h4>
<p>Kind of like <code>list</code> and <code>multiset</code></p>



<a name="174592764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231356%20derive%20finite_products/near/174592764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.231356.20derive.20finite_products.html#174592764">(Aug 31 2019 at 00:23)</a>:</h4>
<p>Binary products are already only defined up to unique isomorphism, so the extra ambiguity of an ordering usually won't matter</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
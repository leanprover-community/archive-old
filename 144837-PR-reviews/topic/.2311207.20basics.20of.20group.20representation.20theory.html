---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html">#11207 basics of group representation theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="277028952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277028952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277028952">(Mar 29 2022 at 16:10)</a>:</h4>
<p>This PR reminded me that the way we say that a space <code>V</code> is a representation of a monoid <code>G</code> over <code>k</code> is currently as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.monoid_algebra.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
</code></pre></div>
<p>What do people think about introducing the redundant typeclass <code>monoid_representation</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.monoid_algebra.basic</span>

<span class="kd">class</span> <span class="n">monoid_representation</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span>
</code></pre></div>
<p>to permit:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">monoid_representation</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
</code></pre></div>
<p>The only advantage would be to reflect informal nomenclature but this might be worth it.</p>



<a name="277029157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277029157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277029157">(Mar 29 2022 at 16:11)</a>:</h4>
<p>I note that we have already allowed something similar with <a href="https://leanprover-community.github.io/mathlib_docs/find/number_field">docs#number_field</a></p>



<a name="277029384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277029384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277029384">(Mar 29 2022 at 16:13)</a>:</h4>
<p>Or maybe we should define <code>group_representation</code> but only for <code>[group G]</code>.</p>



<a name="277042895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277042895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277042895">(Mar 29 2022 at 17:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> has always been advertising <code>module (monoid_algebra K G) V</code> as the correct way of saying that <code>V</code> is a <code>G</code>-representation.</p>



<a name="277042910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277042910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277042910">(Mar 29 2022 at 17:54)</a>:</h4>
<p>I've been coming around to that point of view.</p>



<a name="277043076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277043076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277043076">(Mar 29 2022 at 17:56)</a>:</h4>
<p>What I do think is important is that this induces all the typeclasses mentioned in the posts by Oliver. Especially the scalar action of <code>G</code> (maybe <code>Gᵐᵒᵖ</code>?) on <code>V</code>, and the fact that it commutes with the scalar action of <code>K</code> on <code>V</code>.</p>



<a name="277043949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277043949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277043949">(Mar 29 2022 at 18:03)</a>:</h4>
<p>The problem with alias instances like this is that unlike the thing they alias, mathlib doesn't have any instances available</p>



<a name="277043992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277043992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277043992">(Mar 29 2022 at 18:03)</a>:</h4>
<p>Last time I checked, <a href="https://leanprover-community.github.io/mathlib_docs/find/smul_comm_class">docs#smul_comm_class</a> had 75 instances or so</p>



<a name="277044108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277044108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277044108">(Mar 29 2022 at 18:04)</a>:</h4>
<p>That's a <em>lot</em> of duplication for an equivalent spelling, and you'll probably end up fighting section variables that aren't what you need for half of them</p>



<a name="277044122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277044122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277044122">(Mar 29 2022 at 18:04)</a>:</h4>
<p>This sounds like a job for the typeclass expander we're looking forward to.</p>



<a name="277045345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277045345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277045345">(Mar 29 2022 at 18:13)</a>:</h4>
<p>What about a class that extends the old class and adds zero new members?</p>



<a name="277045467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277045467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277045467">(Mar 29 2022 at 18:14)</a>:</h4>
<p>Isn't that exactly what Oliver is offering?</p>



<a name="277045641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277045641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277045641">(Mar 29 2022 at 18:16)</a>:</h4>
<p>oh, I see, but this shouldn't have any instance problems, right?</p>



<a name="277049068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277049068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277049068">(Mar 29 2022 at 18:46)</a>:</h4>
<p>Yes, you can duplicate the 91 instances, I guess.</p>



<a name="277049227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277049227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277049227">(Mar 29 2022 at 18:48)</a>:</h4>
<p>but <code>monoid_representation.to_smul_comm_class</code> should mean there's no need to duplicate, right?</p>



<a name="277051299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277051299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277051299">(Mar 29 2022 at 19:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277042895">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> has always been advertising <code>module (monoid_algebra K G) V</code> as the correct way of saying that <code>V</code> is a <code>G</code>-representation.</p>
</blockquote>
<p>I worry that this way will become awkward in the Lie group case.  Isn't the correct idea there more like "module over the algebra of continuous functions on <code>G</code>" than just "module over the algebra of functions on <code>G</code>"?</p>



<a name="277051621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277051621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277051621">(Mar 29 2022 at 19:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277049227">said</a>:</p>
<blockquote>
<p>but <code>monoid_representation.to_smul_comm_class</code> should mean there's no need to duplicate, right?</p>
</blockquote>
<p>So you won't ever assume <code>monoid_representation</code> in lemmas? What's the point then?</p>



<a name="277053128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277053128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277053128">(Mar 29 2022 at 19:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277051299">said</a>:</p>
<blockquote>
<p>I worry that this way will become awkward in the Lie group case.  Isn't the correct idea there more like "module over the algebra of continuous functions on <code>G</code>" than just "module over the algebra of functions on <code>G</code>"?</p>
</blockquote>
<p>Maybe the general idea is that you replace <code>monoid_algebra K G</code> with whatever the correct algebra is for the given category. (Finite formal linear combinations? Functions? Continuous functions? L2 functions? etc. etc.)</p>



<a name="277053198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277053198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277053198">(Mar 29 2022 at 19:21)</a>:</h4>
<p>To elaborate on Yaël's point; if you create the alias in the way Oliver suggested but don't also copy all the relevant instances, then every lemma that actually uses the alias will not actually be applicable to any concrete type</p>



<a name="277053984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277053984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277053984">(Mar 29 2022 at 19:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="240862">Oliver Nash</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277028952">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">monoid_representation</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This is reminding me of a feature that would be nice to have, which I've called "abbreviation classes". The role they play in the typeclass system would be that when typeclass search is looking for one, it synthesizes one for you by doing typeclass search for what the class extends. You would be prevented from creating instances of abbreviation classes yourself.</p>
<p>A benefit (vs that <code>[[typeclass]]</code> unfolding idea) would be that instances of abbreviation classes can be cached.</p>



<a name="277054800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277054800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277054800">(Mar 29 2022 at 19:35)</a>:</h4>
<p>I think these can be easily ported to Lean 4 by just adding <code>set_attribute [instance] monoid_representation.mk</code>. This makes use of Lean 4's new-and-improved typeclass resolution system.</p>



<a name="277054844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277054844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277054844">(Mar 29 2022 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277053198">said</a>:</p>
<blockquote>
<p>To elaborate on Yaël's point; if you create the alias in the way Oliver suggested but don't also copy all the relevant instances, then every lemma that actually uses the alias will not actually be applicable to any concrete type</p>
</blockquote>
<p>it'll be nice that this will be a non-issue in lean4</p>



<a name="277055947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277055947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277055947">(Mar 29 2022 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277053984">said</a>:</p>
<blockquote>
<p>This is reminding me of a feature that would be nice to have, which I've called "abbreviation classes".</p>
</blockquote>
<p>Oh, that's I meant by "typeclass expander" above.</p>



<a name="277110834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277110834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277110834">(Mar 30 2022 at 08:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277042895">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> has always been advertising <code>module (monoid_algebra K G) V</code> as the correct way of saying that <code>V</code> is a <code>G</code>-representation.</p>
<p>What I do think is important is that this induces all the typeclasses mentioned in the posts by Oliver.</p>
</blockquote>
<p>I think this approach will be problematic because for the required typeclasses to be induced, the inference logic would have to cope with underdetermined carrier types.</p>



<a name="277110879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277110879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277110879">(Mar 30 2022 at 08:37)</a>:</h4>
<p>To be precise, this is what we currently have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.monoid_algebra.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
</code></pre></div>
<p>and here would be the alternative:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.monoid_algebra.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">V</span><span class="o">]</span>

<span class="c1">-- Problem: `G` is underdetermined</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="n">k</span> <span class="n">V</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="c1">-- Problem: `k` is underdetermined</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="c1">-- Problem: neither `has_scalar k V` and `has_scalar G V` exist for reasons above</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="277111189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277111189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277111189">(Mar 30 2022 at 08:40)</a>:</h4>
<p>Furthermore, how would we say that we have representations of two groups <code>G</code> and <code>H</code> on the same <code>V</code> <em>with the same <code>module k V</code> structure</em>?</p>



<a name="277111542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277111542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277111542">(Mar 30 2022 at 08:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277049227">said</a>:</p>
<blockquote>
<p>but <code>monoid_representation.to_smul_comm_class</code> should mean there's no need to duplicate, right?</p>
</blockquote>
<p>Right: any lemmas stated in terms of <code>smul_comm_class</code> would just work for <code>group_representation</code> but of course not vice-versa. I think this would be fine as long as we obeyed a few rules but it sounds like we should just wait for magical Lean 4 aliases instead.</p>



<a name="277115024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277115024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277115024">(Mar 30 2022 at 09:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="240862">Oliver Nash</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277111189">said</a>:</p>
<blockquote>
<p>Furthermore, how would we say that we have representations of two groups <code>G</code> and <code>H</code> on the same <code>V</code> <em>with the same <code>module k V</code> structure</em>?</p>
</blockquote>
<p>Hmm, that's a good point. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> did you ever think about this?</p>



<a name="277553650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277553650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277553650">(Apr 02 2022 at 21:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277051299">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277042895">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> has always been advertising <code>module (monoid_algebra K G) V</code> as the correct way of saying that <code>V</code> is a <code>G</code>-representation.</p>
</blockquote>
<p>I worry that this way will become awkward in the Lie group case.  Isn't the correct idea there more like "module over the algebra of continuous functions on <code>G</code>" than just "module over the algebra of functions on <code>G</code>"?</p>
</blockquote>
<p>Let me first apologize, because all of the comments below are without any implementation experience in this area; I have not done any representation theory in Lean yet.</p>
<p>But I worry about something similar to what Heather said and probably even more. But first, let me say that I either disagree with or fail to understand the precise details of what was written above (not that it invalidates Heather's point, quite the contrary)... To me, the standard definition of a representation of a Lie group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is a continuous group homomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>G</mi><mo>→</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho \colon G \to \mathrm{Aut}(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Aut</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> (where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Aut}(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Aut</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> itself is a Lie group typically because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> is finite-dimensional over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span>). A module over the algebra of continuous functions on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> seems to me very different from a representation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>! (Usually I'd interpret the algebra of continuous functions as the commutative algebra with pointwise multiplication, which doesn't look appropriate for noncommutative Lie group representations, but maybe the intended product was a convolution, in which case one needs a reference measure and maybe integrability guarantees, and for at least compact Lie groups a good enough Haar measure would indeed exist, but...)</p>
<p>In any case, there is definitely a continuity requirement in a representation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> of a Lie group which is not there for a (plain) group. And the continuity can then be promoted to a differentiability of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>G</mi><mo>→</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho \colon G \to \mathrm{Aut}(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Aut</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>, and one of the first lemmas should be that the differential <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">d</mi><mi>ρ</mi><msub><mi mathvariant="normal">∣</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{d} \rho |_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">ρ</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of a Lie group representation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> at the neutral element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> is a Lie algebra representation, i.e., a Lie algebra homomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Lie}(G) \to \mathrm{End}(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Lie</span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">End</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>. To me Heather's point looks very serious in this light: how do we talk about the differential of <code>module (monoid_algebra ℝ G) V</code> at the neutral element?!?</p>
<p>A super naive thought would be to define a representation of a group <code>G</code> on a vector space (module) <code>V</code> as a group homomorphism <code>ρ : G → Aut(V)</code>, and a Lie group representation as a group homomorphism <code>ρ : G → Aut(V)</code> with an additional assumption <code>continuous ρ</code>, and a representation of a Lie algebra <code>L</code> as a Lie algebra homomorphism <code>L → End(V)</code> --- i.e., just like they are defined in math! (Some tweaks could/should be done to allow for more convenient notation, of course. But notation is always going to be subject to the problem that occasionally we care about multiple representations on the same vector space anyway.) (I of course agree that for plain group representations, <code>module (monoid_algebra ℝ G) V</code> is equivalent, but I don't think it is the usual math definition, and the right generalization to Lie groups is probably a part of the reason.)</p>
<p>I suspect this a naive though must have been discussed before, but could someone please summarize what are the arguments against it? Sorry for my naïveté and thanks for the patience to anyone who will explain the counterarguments.</p>



<a name="277702159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277702159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277702159">(Apr 04 2022 at 09:03)</a>:</h4>
<p><span class="user-mention" data-user-id="373986">@Kalle Kytölä</span> Thank you for sharing your thoughts and certainly no need to apologise for asking good questions.</p>
<p>I see two questions in your words:</p>
<ol>
<li>How would the <code>module (monoid_algebra K G) V</code> approach work for representation of topological groups (including Lie groups)?</li>
<li>Why not just define a representation as a morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>→</mo><mi>A</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G → Aut(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>?</li>
</ol>
<p>Kyle has in fact already answered 1 with this comment: <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277053128">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277053128</a> This approach should work but would probably be awkward and not have various desirable definitional properties. For example, the forgetful functor from a representation of a Lie group <code>G</code> to a representation of <code>G</code> as an abstract group would have to be defined manually rather than automatically existing via typeclass inference.</p>
<p>For 2, we definitely will need to be able to think of representations this way, especially when we want to talk about more than one representation of the same group on the same space. However the question here is really about how to set up the typeclasses for those situations where a space has a single (or distinguished) representation. Note that we already have a setup for doing this for Lie algebras (see for example <a href="https://leanprover-community.github.io/mathlib_docs/find/lie_module.to_endomorphism">docs#lie_module.to_endomorphism</a>).</p>
<p>For my part, I think the <code>module (monoid_algebra K G) V</code> approach should not be the definition for the reasons I outlined a few messages up.</p>



<a name="277715539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277715539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277715539">(Apr 04 2022 at 11:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="240862">Oliver Nash</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory/near/277702159">said</a>:</p>
<blockquote>
<p>Note that we already have a setup for doing this for Lie algebras (see for example <a href="https://leanprover-community.github.io/mathlib_docs/find/lie_module.to_endomorphism">docs#lie_module.to_endomorphism</a>).</p>
</blockquote>
<p>I think the definition for group representation is <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.to_module_aut">docs#distrib_mul_action.to_module_aut</a></p>



<a name="277715627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277715627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277715627">(Apr 04 2022 at 11:17)</a>:</h4>
<p>Arguably we should rename <code>S</code> to <code>G</code> there</p>



<a name="277718058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277718058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277718058">(Apr 04 2022 at 11:43)</a>:</h4>
<p>Who knows, maybe <code>S</code> is the standard name for a <code>distrib</code>?</p>



<a name="277718225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311207%20basics%20of%20group%20representation%20theory/near/277718225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311207.20basics.20of.20group.20representation.20theory.html#277718225">(Apr 04 2022 at 11:44)</a>:</h4>
<p>oh wait I misread it anyways</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
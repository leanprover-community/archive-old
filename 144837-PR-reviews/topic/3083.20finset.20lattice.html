---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/3083.20finset.20lattice.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html">3083 finset lattice</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200940737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200940737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200940737">(Jun 15 2020 at 20:24)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3083">#3083</a> makes <code>finset</code> use <code>lattice</code> operations instead of "set" operations. What do you think about this? <code>data.finset</code> now compiles but I don't want to waste time on porting the rest of <code>mathlib</code> if this is not going to be merged.</p>



<a name="200940990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200940990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200940990">(Jun 15 2020 at 20:27)</a>:</h4>
<p>What's the advantage of this? I think it would be slightly more confusing for newbies who want to use finsets but don't want to think about a lattice, and if I remember correctly the lattice operations already work on finsets anyway</p>



<a name="200941456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200941456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200941456">(Jun 15 2020 at 20:30)</a>:</h4>
<p>I think it's a good idea. It just means you don't need duplicates of all lemmas on lattice operations and set operations. Occasionally I can't <code>rw</code> with a lattice lemma because I've got set operations or vice versa.</p>



<a name="200943935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200943935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200943935">(Jun 15 2020 at 20:51)</a>:</h4>
<p>Does it mean you want to use the obscure lattice notations for set/finset intersection and union?</p>



<a name="200944031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200944031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200944031">(Jun 15 2020 at 20:52)</a>:</h4>
<p>If you want to unify everything I would rather drop the lattice notations and use round intersection and union everywhere instead of the lattice square versions</p>



<a name="200944111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200944111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200944111">(Jun 15 2020 at 20:52)</a>:</h4>
<p>Oh I see Gabriel also likes round notations.</p>



<a name="200944342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200944342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200944342">(Jun 15 2020 at 20:54)</a>:</h4>
<p>Either way it sounds like a drastic change that is not drastically motivated.</p>



<a name="200944394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200944394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200944394">(Jun 15 2020 at 20:55)</a>:</h4>
<p>I would very much prefer having integrals that work.</p>



<a name="200945812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200945812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200945812">(Jun 15 2020 at 21:07)</a>:</h4>
<p>We have the zany lattice notation for ideals and I got used to it in the end. There are advantages of a unified approach. I get annoyed that set.preimage isn't called comap nowadays</p>



<a name="200947945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200947945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200947945">(Jun 15 2020 at 21:25)</a>:</h4>
<p>I was thinking about definitions, not notation.</p>



<a name="200948117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200948117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200948117">(Jun 15 2020 at 21:27)</a>:</h4>
<p>The only question about using <code>∪</code> ant <code>∩</code> for lattice is what to do with <code>≤</code>/<code>&lt;</code>/<code>⊥</code> vs <code>⊆</code>/<code>⊂</code>/<code>∅</code>.</p>



<a name="200948235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200948235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200948235">(Jun 15 2020 at 21:28)</a>:</h4>
<p>I know only one type with different interpretation of <code>≤</code> and <code>⊆</code>: <code>multiset</code>.</p>



<a name="200956593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200956593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200956593">(Jun 15 2020 at 23:09)</a>:</h4>
<p>I think having any types with both <code>≤</code> and <code>⊆</code> is probably a bad idea: just a recipe for confusion. (I remember being dismayed stumbling on this one.) I would propose picking the important one to receive notation (whether it's <code>≤</code> and <code>⊆</code>) and just dealing with being more verbose for the other.</p>



<a name="200963627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200963627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200963627">(Jun 16 2020 at 01:05)</a>:</h4>
<p>Whenever I have to do anything with lattices I struggle a lot with typing <code>\lub</code> and <code>\glb</code> because I have to mentally reconstruct which is which. It doesn't help that we think of them as <code>union</code> and <code>inter</code>, and the lattice names are <code>sup</code> and <code>inf</code>. Maybe it would help if we could also use <code>\lunion</code> and <code>\linter</code> for "lattice union" and "lattice inter", or something like that.</p>



<a name="200964600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200964600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200964600">(Jun 16 2020 at 01:27)</a>:</h4>
<p>what about <code>\sqcap</code> and <code>\sqcup</code>?</p>



<a name="200965030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200965030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200965030">(Jun 16 2020 at 01:36)</a>:</h4>
<p>Yeah, that works for me.</p>



<a name="200965077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200965077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200965077">(Jun 16 2020 at 01:36)</a>:</h4>
<p>I must confess I feel the same as Jeremy about these funny words. I guess I recognise cup as union though</p>



<a name="200967946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200967946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200967946">(Jun 16 2020 at 02:42)</a>:</h4>
<p>Oh, yeah, and when talking about lattices in ordinary mathematics I use "meet" and "join." We give the dictionary here: <a href="https://avigad.github.io/mathematics_in_lean/basics.html#proving-facts-about-algebraic-structures">https://avigad.github.io/mathematics_in_lean/basics.html#proving-facts-about-algebraic-structures</a><br>
I put the translations there to help myself sort them out more than anyone else.</p>



<a name="200968668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200968668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200968668">(Jun 16 2020 at 03:02)</a>:</h4>
<p>Changing <code>sup</code> to <code>join</code> and <code>inf</code> to <code>meet</code> should not be too hard.</p>



<a name="200968684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200968684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200968684">(Jun 16 2020 at 03:02)</a>:</h4>
<p>But I don't want to start any of these refactors until we'll agree on the goal.</p>



<a name="200978015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200978015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200978015">(Jun 16 2020 at 06:38)</a>:</h4>
<p>I would like to maintain readability as much as possible. But uniformity pays off in the long run. And I think the symbols are similar enough that we can explain to anyone that <code>\sqcup</code> is the symbol for union of "set-like" things. Then we only need to tell them that in names</p>
<ul>
<li><code>subset</code> becomes <code>le</code></li>
<li><code>union</code> becomes <code>meet</code></li>
<li><code>inter</code> becomes <code>join</code><br>
and I think all of those are pretty self-explanatory.<br>
The hardest thing might be <code>empty</code> becomes <code>bot</code>...<br>
And of course <code>univ</code> was already confusing to begin with, so replacing it with <code>top</code> doesn't change anything. (-;</li>
</ul>



<a name="200978110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200978110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200978110">(Jun 16 2020 at 06:40)</a>:</h4>
<p>We can use union and inter for meet and join though in some contexts (e.g., <code>supr</code> in <code>real</code>s or <code>ennreal</code>s) this looks funny.</p>



<a name="200979714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200979714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200979714">(Jun 16 2020 at 07:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200967946">said</a>:</p>
<blockquote>
<p>I use "meet" and "join."</p>
</blockquote>
<p>I mix up meet and join <del>pretty often</del> always, I guess mostly because these words don't exist in German.  In German we typically use supremum and infimum, so I prefer the current naming.</p>



<a name="200980268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/200980268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#200980268">(Jun 16 2020 at 07:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200978110">said</a>:</p>
<blockquote>
<p>in some contexts [...] this looks funny.</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>∪</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\sqrt{2} \cup \pi = \pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> doesn't look so bad, it reminds me of Dedekind cuts.</p>



<a name="201001610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201001610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201001610">(Jun 16 2020 at 11:34)</a>:</h4>
<p>I didn't mean to suggest that <code>meet</code> and <code>join</code> are better than <code>sup</code> and <code>inf</code>. It would help if we could reclaim <code>\sup</code> and <code>\inf</code> in VS Code. We already have <code>\supseteq</code> and <code>\infty</code> for the symbols they are assigned to now. It might help to be able to type <code>\sqcap</code> and <code>\sqcup</code> when working with finsets, because <code>\cap</code> and <code>\cup</code> are used in Latex for intersections and unions. But I can probably get used to the fact that intersection is <code>\inf</code> because it is smaller and union is <code>\sup</code> because it is bigger. It's just that <code>\glb</code> and <code>\lub</code> are horrible, because e.g. "greatest" and "lower" go in opposite directions, and I have to stop to think about which one wins.</p>



<a name="201048350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201048350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201048350">(Jun 16 2020 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200980268">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200978110">said</a>:</p>
<blockquote>
<p>in some contexts [...] this looks funny.</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>∪</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\sqrt{2} \cup \pi = \pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> doesn't look so bad, it reminds me of Dedekind cuts.</p>
</blockquote>
<p>I guess this is tongue in cheek? I'm not a fan <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> I guess that for linear orders we want to simp this away to <code>max a b</code> as soon as possible?</p>



<a name="201049077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049077">(Jun 16 2020 at 17:34)</a>:</h4>
<p>I'm 60% serious.  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>⊔</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\sqrt{2} \sqcup \pi = \pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> doesn't look any better to me.  But <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">1 \in \pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> would be too much, even for me.</p>



<a name="201049156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049156">(Jun 16 2020 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/201049077">said</a>:</p>
<blockquote>
<p>I'm 60% serious.  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>⊔</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\sqrt{2} \sqcup \pi = \pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> doesn't look any better to me.</p>
</blockquote>
<p>But it also doesn't look any worse, right? (At least to me...)</p>



<a name="201049307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049307">(Jun 16 2020 at 17:36)</a>:</h4>
<p>I completely agree.  That's why I think <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow></mrow><mo>∪</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">{}\cup{}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span></span></span></span> is the best choice if we want to standardize, because it looks right half of the time (with sets, multisets, etc.).</p>



<a name="201049354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049354">(Jun 16 2020 at 17:36)</a>:</h4>
<p>But on an abstract lattice, it looks "wrongish".</p>



<a name="201049410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049410">(Jun 16 2020 at 17:37)</a>:</h4>
<p>And the problem remains with <code>\le</code> vs <code>\subset</code>, right?</p>



<a name="201049426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049426">(Jun 16 2020 at 17:37)</a>:</h4>
<p>We definitely don't want <code>0 \subset 1</code>.</p>



<a name="201049555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049555">(Jun 16 2020 at 17:38)</a>:</h4>
<p>Yes, <code>⊆</code> vs. <code>≤</code> is the hard one.  How about <code>∅ ≤ A ∩ B</code>? <em>ducks</em></p>



<a name="201049971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201049971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201049971">(Jun 16 2020 at 17:42)</a>:</h4>
<p>I think I prefer to go full lattice notation everywhere.</p>



<a name="201051291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201051291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201051291">(Jun 16 2020 at 17:52)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span>/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∩</span></span></span></span> look really wrong when they are wrong, for example, filters ordered by reverse inclusion.</p>



<a name="201101221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201101221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201101221">(Jun 17 2020 at 04:47)</a>:</h4>
<p>Is it insane to have all the notations mean the same thing (i.e. lattice operations), and let people use different ones in different contexts?</p>



<a name="201101358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201101358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201101358">(Jun 17 2020 at 04:50)</a>:</h4>
<p>Proof state will always use one notation.</p>



<a name="201101954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201101954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201101954">(Jun 17 2020 at 05:03)</a>:</h4>
<p>Is this sort of thing why we have to prove everything for both additive groups and multiplicative groups?</p>



<a name="201102016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201102016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201102016">(Jun 17 2020 at 05:05)</a>:</h4>
<p>For multiplicative and additive groups we also have rings. They use both multiplicative and additive structures.</p>



<a name="201102094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201102094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201102094">(Jun 17 2020 at 05:06)</a>:</h4>
<p>One possible solution is to write a <code>to_additive</code>-style attribute and add it to all the <code>lattice</code> lemmas.</p>



<a name="201102112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/201102112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#201102112">(Jun 17 2020 at 05:07)</a>:</h4>
<p>But then we'll have to decide which notation is better in each case.</p>



<a name="202152032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202152032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202152032">(Jun 26 2020 at 22:45)</a>:</h4>
<p>I wouldn't mind using lattice notation everywhere.<br>
I'm not in favor using set notation for lattices.<br>
The current status quo means we have to redo everything about lattices separately for sets and finsets, which is not great. There have been plenty of cases where I needed a lemma that existed for exactly one of {bUnion, supr} and I needed it for the other one.</p>



<a name="202155277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202155277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202155277">(Jun 26 2020 at 23:30)</a>:</h4>
<p>Even worse, we need to redo lots of stuff separately for sets, finsets, and lattices.</p>



<a name="202356827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202356827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202356827">(Jun 29 2020 at 19:25)</a>:</h4>
<p>Let me revive this thread. What are the reasons <strong>against</strong> migration of <code>set</code>s, <code>multiset</code>s and <code>finset</code>s to <code>lattice</code>?</p>



<a name="202356949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202356949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202356949">(Jun 29 2020 at 19:26)</a>:</h4>
<p>I remember the following:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊔</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊓</mo></mrow><annotation encoding="application/x-tex">\sqcap</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊓</span></span></span></span> look worse than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∩</span></span></span></span>;</li>
<li>it's hard to remember <code>\lub</code> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊔</span></span></span></span>.</li>
</ul>
<p>What else?</p>



<a name="202357129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202357129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202357129">(Jun 29 2020 at 19:28)</a>:</h4>
<p>The second point is no longer valid after all the new additions to the translations file.</p>



<a name="202357133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202357133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202357133">(Jun 29 2020 at 19:28)</a>:</h4>
<p>point 2 has been resolved: there are now many ways to input <code>⊔</code> and <code>⨆</code>.<br>
I think a point that is close to point 1: lattice notation is beginner unfriendly.</p>



<a name="202357350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202357350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202357350">(Jun 29 2020 at 19:30)</a>:</h4>
<p>And defining <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f'(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> using normed spaces and filters is very beginner friendly ;)</p>



<a name="202357488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202357488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202357488">(Jun 29 2020 at 19:31)</a>:</h4>
<p>BTW, when I first saw Lean the fact that <code>⊂</code> means <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊊</mo></mrow><annotation encoding="application/x-tex">\subsetneq</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel amsrm">⊊</span></span></span></span> was very surprising.</p>



<a name="202357493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202357493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202357493">(Jun 29 2020 at 19:31)</a>:</h4>
<p>There is a difference: with a good enough API you don't need to know about normed spaces &amp; filters to work with the derivative on functions <code>real -&gt; real</code>. The lattice operations on <code>set</code> <strong>is</strong> the API.<br>
(just to be clear: I'm in favor of using lattice notation for sets over the status quo)</p>



<a name="202357926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202357926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202357926">(Jun 29 2020 at 19:35)</a>:</h4>
<p>Can we have <code>local notation : ∪ := ⊔</code>, and use it in the set files?</p>



<a name="202358070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202358070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202358070">(Jun 29 2020 at 19:36)</a>:</h4>
<p>Or even have it globally as an input notation in all files?</p>



<a name="202358200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202358200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202358200">(Jun 29 2020 at 19:37)</a>:</h4>
<p>I'm afraid that might make things even more confusing if the lemmas you use are called <code>sup_comm</code> and <code>image_sup</code> (or <code>sup_comm</code> and <code>image_union</code>??).</p>



<a name="202358399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202358399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202358399">(Jun 29 2020 at 19:38)</a>:</h4>
<p><code>image</code> and <code>preimage</code> should <em>clearly</em> be renamed to <code>map</code> and <code>comap</code>... ...<br>
... <span aria-label="confused" class="emoji emoji-1f615" role="img" title="confused">:confused:</span> <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>



<a name="202358501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202358501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202358501">(Jun 29 2020 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202358200">said</a>:</p>
<blockquote>
<p>I'm afraid that might make things even more confusing if the lemmas you use are called <code>sup_comm</code> and <code>image_sup</code> (or <code>sup_comm</code> and <code>image_union</code>??).</p>
</blockquote>
<p>Good point!</p>



<a name="202358696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202358696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202358696">(Jun 29 2020 at 19:41)</a>:</h4>
<p>Also, what does <code>s ≤ t</code> mean to a mathematician (if anything)? Is it pointwise inequalities: <code>∀ x ∈ s, ∀ y ∈ t, x ≤ y</code>? Using lattice notation means that it has to mean <code>subset</code>...</p>



<a name="202359030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359030">(Jun 29 2020 at 19:44)</a>:</h4>
<p>I guess it <em>could</em> mean pointwise ineqs, but I think that's very rare.</p>



<a name="202359072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359072">(Jun 29 2020 at 19:44)</a>:</h4>
<p>I don't think the idea that sets form a partial order w.r.t. inclusion is so alien to mathematicians, so I'd say most would guess it means subset.</p>



<a name="202359260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359260">(Jun 29 2020 at 19:46)</a>:</h4>
<p>It definitely helps that the lattice notation is just a pointy-squary version of the set notation.</p>



<a name="202359637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359637">(Jun 29 2020 at 19:50)</a>:</h4>
<p>But it might take some time to get used to names like <code>le_image_sup : f '' (s ⊔ f ⁻¹' t) ≤ f '' s ⊔ t</code> (or <code>le_map_sup</code>). I do feel like we're losing something when moving from the current notation/naming to the lattice versions...</p>



<a name="202359896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359896">(Jun 29 2020 at 19:53)</a>:</h4>
<p>We would need an attribute like <code>to_additive</code> to create <code>union</code> lemmas from <code>sup</code> lemmas, and a notation <code>union = sup</code>. Then it would be mostly transparent to the user, but with better defeq properties.</p>



<a name="202359932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359932">(Jun 29 2020 at 19:53)</a>:</h4>
<p>How about having something like the <code>to_additive</code> trick, so that we can batch-duplicate lattice theorems with set names and set notation (for types that have that notation defined)?</p>



<a name="202359955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359955">(Jun 29 2020 at 19:53)</a>:</h4>
<p>I was faster :)</p>



<a name="202359960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202359960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202359960">(Jun 29 2020 at 19:53)</a>:</h4>
<p>As a small experiment, I just asked two grad students (in number theory) what <code>X \le Y</code> for <code>X, Y</code> sets means with no hints, one guessed the partial order by inclusion, and one guessed an inequality of cardinals (i.e. exists an injection from <code>X \to Y</code>. It might have been more realistic to pose it as <code>X, Y</code> subsets of <code>Z</code>, what does <code>X\le Y</code> mean.</p>



<a name="202360184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360184">(Jun 29 2020 at 19:55)</a>:</h4>
<p>If we try the <code>to_additive</code> trick, then which notation should we use for <code>submonoid</code>s etc?</p>



<a name="202360464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360464">(Jun 29 2020 at 19:58)</a>:</h4>
<p>I would say: don't touch existing files. Both notations should be completely equivalent, so you can even use <code>\le</code> at one line and <code>\subseteq</code> at the next one.</p>



<a name="202360500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360500">(Jun 29 2020 at 19:58)</a>:</h4>
<p>I guess lattice operations are fine on <code>submonoids</code>, <code>opens</code>, ...<br>
For submonoids you don't even have <code>↑(s ⊔ t) = ↑s ∪ ↑t</code> in general</p>



<a name="202360704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360704">(Jun 29 2020 at 20:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> As an temporary solution? Eventually we will want to name our lemmas in a consistent way (which probably means using <code>_sup_</code> instead of <code>_union_</code> everywhere)</p>



<a name="202360825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360825">(Jun 29 2020 at 20:01)</a>:</h4>
<p>But if we use <code>∪</code> for set, we probably also want it for <code>finset</code>...</p>



<a name="202360840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360840">(Jun 29 2020 at 20:01)</a>:</h4>
<p>I think that <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> is proposing to throw away <code>set/basic.lean</code> and instead tag every lemma in <code>order/lattice.lean</code> with <code>@[to_set]</code>.</p>



<a name="202360868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202360868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202360868">(Jun 29 2020 at 20:01)</a>:</h4>
<p>Exactly.</p>



<a name="202361099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361099">(Jun 29 2020 at 20:03)</a>:</h4>
<p>In more specialized domains, we should settle on one of the choices. I'd say use union and subset for sets and finsets (and more generally if there is a coercion to sets satisfying <code>coe (a sup b) = coe a union coe b</code>), and order notation otherwise.</p>



<a name="202361278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361278">(Jun 29 2020 at 20:04)</a>:</h4>
<p>is the statement of lemma <code>union_comm</code> the same as <code>sup_comm</code>, or is it specialized to sets?</p>



<a name="202361344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361344">(Jun 29 2020 at 20:05)</a>:</h4>
<p>It is exactly the same statement.</p>



<a name="202361388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361388">(Jun 29 2020 at 20:05)</a>:</h4>
<p>(Possibly with a different pretty printer setting so that the sup is shown as a union in the tooltip)</p>



<a name="202361430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361430">(Jun 29 2020 at 20:06)</a>:</h4>
<p>ah ok. that would make it easier.</p>



<a name="202361507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361507">(Jun 29 2020 at 20:06)</a>:</h4>
<p>yeah, you probably still want different <code>has_union</code> and <code>has_sup</code> classes, and let <code>to_set</code> modify the classes as well, so that the goal/lemmas are printed the way you wrote them.</p>
<p>I guess that could work.</p>



<a name="202361576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361576">(Jun 29 2020 at 20:07)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> I agree: if you don't know X and Y are subsets of Z then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\subseteq Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> doesn't make much sense. If they're both subsets of Z then there's at most one canonical injection from X to Y and so now you're more likely to guess the inclusion.</p>



<a name="202361640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361640">(Jun 29 2020 at 20:08)</a>:</h4>
<p>This is going to be a refactor so big that <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span> <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span> <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span></p>



<a name="202361659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202361659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202361659">(Jun 29 2020 at 20:08)</a>:</h4>
<p>I agree, it was a flawed experiment! But someone still got it right!</p>



<a name="202362535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202362535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202362535">(Jun 29 2020 at 20:17)</a>:</h4>
<p>If we have different <code>has_sup</code> and <code>has_union</code> classes, then how can <code>union_comm</code> and <code>sup_comm</code> be the same?</p>



<a name="202362672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202362672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202362672">(Jun 29 2020 at 20:18)</a>:</h4>
<p>I think we should just have one class.</p>



<a name="202362705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202362705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202362705">(Jun 29 2020 at 20:19)</a>:</h4>
<p>Then what should <code>@[to_set]</code> do?</p>



<a name="202362762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202362762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202362762">(Jun 29 2020 at 20:19)</a>:</h4>
<p>And I guess we won't be able to tell pretty-printer to consistently use <code>∪</code> for sets and finsets.</p>



<a name="202362928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202362928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202362928">(Jun 29 2020 at 20:21)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">to_set</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">le_sup_right</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="err">⊔</span> <span class="n">b</span>
</code></pre></div>


<p>should create a theorem <code>subset_union_right</code>which is defeq to <code>le_sup_right</code>, but in which <code>notation union := sup</code> and <code>notation subseteq := \le</code> are activated so that the tooltip shows right.</p>



<a name="202363053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363053">(Jun 29 2020 at 20:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202362762">said</a>:</p>
<blockquote>
<p>And I guess we won't be able to tell pretty-printer to consistently use <code>∪</code> for sets and finsets.</p>
</blockquote>
<p>I agree, but I think this is only a minor annoyance. (And it might be solvable in Lean 4).</p>



<a name="202363381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363381">(Jun 29 2020 at 20:25)</a>:</h4>
<p>What do you mean by "notation ... are activated"? AFAIK, Lean doesn't store notation with lemma statements. It uses currently active notation in <code>#print</code> etc.</p>



<a name="202363384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363384">(Jun 29 2020 at 20:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202362535">said</a>:</p>
<blockquote>
<p>If we have different <code>has_sup</code> and <code>has_union</code> classes, then how can <code>union_comm</code> and <code>sup_comm</code> be the same?</p>
</blockquote>
<p>with two different classes, they are not syntactically equal.<br>
My idea (to get the pretty printing right) is to have separate <code>has_sup</code> and <code>has_union</code> classes. Given a <code>lattice</code> you have instances to both <code>has_sup</code> and <code>has_union</code>, and the underlying maps are definitionally equal.<br>
Then <code>@[to_set]</code> replaces all <code>sup</code>s with <code>union</code>s, in the same way that <code>to_additive</code> does it.</p>



<a name="202363436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363436">(Jun 29 2020 at 20:25)</a>:</h4>
<p>The lemmas will be definitionally equal, but not syntactically equal.</p>



<a name="202363525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363525">(Jun 29 2020 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202363381">said</a>:</p>
<blockquote>
<p>What do you mean by "notation ... are activated"? AFAIK, Lean doesn't store notation with lemma statements. It uses currently active notation in <code>#print</code> etc.</p>
</blockquote>
<p>ok, too bad</p>



<a name="202363628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363628">(Jun 29 2020 at 20:27)</a>:</h4>
<p>If we use different classes, why should we care about <code>defeq</code>?  We can make <code>@[to_set]</code> do the same as <code>@[to_additive]</code>.</p>



<a name="202363824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202363824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202363824">(Jun 29 2020 at 20:29)</a>:</h4>
<p>we don't necessarily care about defeq.</p>



<a name="202364206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202364206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202364206">(Jun 29 2020 at 20:32)</a>:</h4>
<p>I don't remember the start of the thread: wasn't your goal to get union defeq to to \sup to start with?</p>



<a name="202364350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202364350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202364350">(Jun 29 2020 at 20:33)</a>:</h4>
<p>Let's say we consider different options. The goal is to reduce code duplication.</p>



<a name="202364430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202364430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202364430">(Jun 29 2020 at 20:34)</a>:</h4>
<p>Currently we prove quite a few <code>lattice</code> lemmas for (a) <code>set</code>s; (b) <code>finset</code>s; (c) all other lattices.</p>



<a name="202364677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202364677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202364677">(Jun 29 2020 at 20:36)</a>:</h4>
<p>Technically the simplest solution is to start using <code>≤</code>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊓</mo></mrow><annotation encoding="application/x-tex">\sqcap</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊓</span></span></span></span> etc everywhere but this is bad for new users.</p>



<a name="202365255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202365255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202365255">(Jun 29 2020 at 20:41)</a>:</h4>
<p>Other solutions include: (a) use a <code>@[to_additive]</code>-like attribute to transfer lemmas from <code>lattice</code> operations to <code>set</code> operations; (b) allow <code>∪</code> as a (local?) alternative syntax for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊔</span></span></span></span> and use it for <code>set</code>s and <code>finset</code>s.</p>



<a name="202365368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202365368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202365368">(Jun 29 2020 at 20:42)</a>:</h4>
<p>From the discussion, (a) looks like the nicest solution, albeit not the easiest to implement.</p>



<a name="202365625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202365625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202365625">(Jun 29 2020 at 20:44)</a>:</h4>
<p>The main drawback of (a) is that we'll need class names for <code>set</code> versions of everything up to <code>complete_boolean_algebra</code> and, e.g., <code>monotone</code> won't work automatically unless we define <code>has_le</code> as well.</p>



<a name="202365757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202365757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202365757">(Jun 29 2020 at 20:45)</a>:</h4>
<p>I hope that with Lean 4 we'll be able to define a pretty-printer that uses <code>∪</code> for some types and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊔</span></span></span></span> for all other types.</p>



<a name="202366072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202366072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202366072">(Jun 29 2020 at 20:48)</a>:</h4>
<p>So we have option (c): wait for Lean 4.</p>



<a name="202366263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202366263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202366263">(Jun 29 2020 at 20:50)</a>:</h4>
<p>Even with Lean 4, we would need <code>@[to_set]</code> to create lemma names with union and subset instead of sup and le.</p>



<a name="202366413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202366413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202366413">(Jun 29 2020 at 20:51)</a>:</h4>
<p>Is it a problem that <code>order.complete_lattice</code> depends on properties of sets, through <code>order.bounds</code>? On a quick look, <code>order.bounds</code> only uses finite unions and intersections, subset, empty and univ. So maybe it is o.k.</p>



<a name="202366555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202366555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202366555">(Jun 29 2020 at 20:52)</a>:</h4>
<p>It's easy to reorder <code>import</code>s so that <code>data/set/basic</code> will know the <em>definition</em> of <code>complete_boolean_algebra</code> and <em>lemmas</em> about <code>bounded_lattice</code>.</p>



<a name="202367358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202367358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202367358">(Jun 29 2020 at 21:00)</a>:</h4>
<p>(done locally)</p>



<a name="202367460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202367460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202367460">(Jun 29 2020 at 21:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202366263">said</a>:</p>
<blockquote>
<p>Even with Lean 4, we would need <code>@[to_set]</code> to create lemma names with union and subset instead of sup and le.</p>
</blockquote>
<p>It's easier to add <code>alias</code>es with custom names than to modify types.</p>



<a name="202394733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202394733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202394733">(Jun 30 2020 at 04:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202365625">said</a>:</p>
<blockquote>
<p>The main drawback of (a) is that we'll need class names for <code>set</code> versions of everything up to <code>complete_boolean_algebra</code> and, e.g., <code>monotone</code> won't work automatically unless we define <code>has_le</code> as well.</p>
</blockquote>
<p>Well, <code>to_set</code> wouldn't have to replay the proofs (like <code>to_additive</code>) does, if we make sure that things are defeq. Then it just has to modify the name and statement, and can prove the resulting lemma by directly calling the lattice version.<br>
So it generates</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">subset_union_right</span> <span class="o">:</span> <span class="n">the</span><span class="bp">-</span><span class="n">statement</span> <span class="o">:=</span>
<span class="n">le_sup_right</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
</code></pre></div>


<p>To make this work, we have to give <code>set</code> some low-priority <code>has_le</code> and <code>has_sup</code> instances, but it would save us from duplicating the entire lattice class hierarchy for set-like notation.</p>



<a name="202401049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202401049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202401049">(Jun 30 2020 at 06:54)</a>:</h4>
<p>What's wrong with the approach "make <code>\cup</code> and <code>\sqcup</code> two notations for the same operation and make <code>@[to_set]</code> work as <code>alias + autogen name</code>"? This way we can't have good notation in the proof state but we can be sure that any lemma about <code>lattice</code>s work for <code>set</code>s even without a <code>@[to_set]</code> alias.</p>



<a name="202401061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202401061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202401061">(Jun 30 2020 at 06:55)</a>:</h4>
<p>We still can have good notation in the input.</p>



<a name="202401078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202401078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202401078">(Jun 30 2020 at 06:55)</a>:</h4>
<p>(and I hope that we'll be able to have a good notation in the proof state in Lean 4)</p>



<a name="202401693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202401693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202401693">(Jun 30 2020 at 07:06)</a>:</h4>
<p>How exactly should the "defeq" based <code>@[to_set]</code> work? Should we add some instances like <code>has_subset.to_has_le</code> and use them when transforming the statement? Will it play nice with diamonds?</p>



<a name="202401870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202401870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202401870">(Jun 30 2020 at 07:09)</a>:</h4>
<p>Shouldn't we remove completely <code>has_subset</code>, and use subset as a notation for le?</p>



<a name="202402028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202402028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202402028">(Jun 30 2020 at 07:12)</a>:</h4>
<p>With the "make <code>\cup</code> and <code>\sqcup</code> two notations for the same operation" approach yes, we should. But I'm trying to understand what other options do we have, and can't understand the "defeq" approach <span class="user-mention" data-user-id="112680">@Johan Commelin</span> is talking about.</p>



<a name="202402586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202402586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202402586">(Jun 30 2020 at 07:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202401870">said</a>:</p>
<blockquote>
<p>Shouldn't we remove completely <code>has_subset</code>, and use subset as a notation for le?</p>
</blockquote>
<p>Shouldn't we completely remove <code>has_mul</code>, and use <code>*</code> as a notation for <code>has_add</code>?</p>



<a name="202402610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202402610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202402610">(Jun 30 2020 at 07:23)</a>:</h4>
<p>I guess there might be some edge cases where a type has two monoid structures</p>



<a name="202443895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202443895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202443895">(Jun 30 2020 at 14:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Let's discuss lattices, not monoids. Currently there is only one rarely used type (<code>multiset</code>) with both <code>has_subset</code> and <code>has_le</code> and <code>has_le.le ≠ has_subset.subset</code>.</p>



<a name="202444826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202444826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202444826">(Jun 30 2020 at 14:42)</a>:</h4>
<p>So rather fewer edge cases than in the */+ case.</p>



<a name="202447128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202447128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202447128">(Jun 30 2020 at 14:57)</a>:</h4>
<p>And I'm not aware of good structures involving <code>has_subset</code> on <code>multiset</code>, so we can just add a custom notation for this.</p>



<a name="202460808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202460808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202460808">(Jun 30 2020 at 16:29)</a>:</h4>
<p>One more type with sensible <code>has_subset</code> different from <code>has_le</code>: <code>list</code>.</p>



<a name="202461451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/3083%20finset%20lattice/near/202461451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/3083.20finset.20lattice.html#202461451">(Jun 30 2020 at 16:33)</a>:</h4>
<p>IIRC there is more than one reasonable (non-subset) definition of <code>≤</code> on lists.  And only one of them is well-founded (if the order on the elements is well-founded).  Maybe these should be different relations (i.e., not <code>≤</code>) anyhow.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
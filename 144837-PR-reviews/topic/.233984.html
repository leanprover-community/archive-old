---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.233984.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html">#3984</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208495265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495265">(Aug 30 2020 at 17:24)</a>:</h4>
<p><span class="user-mention" data-user-id="255743">@Paul van Wamelen</span> introduces <code>coprime</code> in a <code>comm_monoid_with_zero</code> to mean that two elements share no prime factors. I'd also considered, but not yet implemented, defining <code>coprime a b</code> at the level of a <code>gcd_monoid</code> to mean <code>gcd a b = 1</code>. These unfortunately only agree in the case of unique factorization.</p>



<a name="208495301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495301">(Aug 30 2020 at 17:25)</a>:</h4>
<p>Does anyone have strong opinions on this definition? If no opinions pop up, then Paul's definition should take precedence because Paul has actually implemented it first.</p>



<a name="208495466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495466">(Aug 30 2020 at 17:29)</a>:</h4>
<p>You can still define <code>gcd_monoid.coprime</code>. But how many different notions of <code>coprime</code> will mathlib know by then? I think some of the older ones should maybe be refactored away, if they are generalised by (one of) these.</p>



<a name="208495568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495568">(Aug 30 2020 at 17:31)</a>:</h4>
<p>I'd like to make <code>nat.coprime</code> a property of a <code>gcd_monoid</code> structure on N, but it's in core</p>



<a name="208495654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495654">(Aug 30 2020 at 17:32)</a>:</h4>
<p>Ooh, that's right. And I think <code>gcd</code> has special VM support for fast GMP calculations</p>



<a name="208495677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495677">(Aug 30 2020 at 17:33)</a>:</h4>
<p>I think your latter case is covered by my <code>is_coprime</code></p>



<a name="208495740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495740">(Aug 30 2020 at 17:34)</a>:</h4>
<p>I mean, we could make an instance of <code>gcd_monoid</code> for <code>nat</code> where <code>gcd</code> and <code>lcm</code> are the core definitions, but that wouldn't coincide definitionally with the instance coming from unique factorization, once I get a <code>unique_factorization_monoid</code> instance on N</p>



<a name="208495759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495759">(Aug 30 2020 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233984/near/208495677">said</a>:</p>
<blockquote>
<p>I think your latter case is covered by my <code>is_coprime</code></p>
</blockquote>
<p>Not if we're working in a monoid without addition or subtraction, I don't think.</p>



<a name="208495823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208495823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208495823">(Aug 30 2020 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233984/near/208495568">said</a>:</p>
<blockquote>
<p>I'd like to make <code>nat.coprime</code> a property of a <code>gcd_monoid</code> structure on N, but it's in core</p>
</blockquote>
<p>Ooh wait, we can't rip <code>nat.gcd</code> out of core. But we could definitely rip the definition of coprime away.</p>



<a name="208496016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208496016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208496016">(Aug 30 2020 at 17:39)</a>:</h4>
<p>In <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo stretchy="false">[</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}[X,Y]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span> the elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> are considered to be coprime, because we have a UFD and there's a standard meaning. But the ideals <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> are not, because their sum is not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.  In particular there is already some kind of ambiguity in standard mathematical usage.</p>



<a name="208496386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208496386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208496386">(Aug 30 2020 at 17:47)</a>:</h4>
<p>Personally, I would prefer to restrict the name <code>coprime</code> for coprime ideals and for pairs of elements whose associated ideals are coprime. I think the word "non_associated" (or something like that) would be better for, e.g., the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X,Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> example that Kevin mentioned.</p>



<a name="208496495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208496495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208496495">(Aug 30 2020 at 17:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233984/near/208496386">said</a>:</p>
<blockquote>
<p>Personally, I would prefer to restrict the name <code>coprime</code> for coprime ideals and for pairs of elements whose associated ideals are coprime. I think the word "non_associated" (or something like that) would be better for, e.g., the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X,Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> example that Kevin mentioned.</p>
</blockquote>
<p>Isn't there already <code>comaximal</code> for the ideal definition, when there's no other name for <code>coprime</code> for UFD/naturals?</p>



<a name="208496828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208496828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208496828">(Aug 30 2020 at 17:59)</a>:</h4>
<p>I don't think my "implemented it first" should be a reason for going with my definition. I'm more than happy to wait for Aaron's work and his definition if that would work better. I also doubt that <code>coprime</code> in a <code>comm_monoid_with_zero</code> would ever be used unless you are already in <code>gcd_monoid</code> so no harm in having it "only" in <code>gcd_monoid</code>.</p>



<a name="208497223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208497223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208497223">(Aug 30 2020 at 18:09)</a>:</h4>
<p>coprime/comaximal in a monoid with zero has a very precise meaning, which is not necessarily saying that the two elements do not share a prime factor: it says that in any quotient in which the two elements are identified with zero, all the elements are identified with zero. I.e. the associated congruences are coprime. Whether this will be used in practice is a different question.</p>



<a name="208497281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208497281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208497281">(Aug 30 2020 at 18:10)</a>:</h4>
<p>(note that for monoids it's a very restrictive notion)</p>



<a name="208497970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208497970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208497970">(Aug 30 2020 at 18:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255743">Paul van Wamelen</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233984/near/208496828">said</a>:</p>
<blockquote>
<p>I don't think my "implemented it first" should be a reason for going with my definition. I'm more than happy to wait for Aaron's work and his definition if that would work better. I also doubt that <code>coprime</code> in a <code>comm_monoid_with_zero</code> would ever be used unless you are already in <code>gcd_monoid</code> so no harm in having it "only" in <code>gcd_monoid</code>.</p>
</blockquote>
<p>If that's how you feel, I should probably prioritize my relevant work</p>



<a name="208498216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208498216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208498216">(Aug 30 2020 at 18:32)</a>:</h4>
<p>Should I PR it separately, or add it to your branch, <span class="user-mention" data-user-id="255743">@Paul van Wamelen</span> ?</p>



<a name="208498505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208498505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208498505">(Aug 30 2020 at 18:41)</a>:</h4>
<p>Yours should probably be its own PR.</p>



<a name="208500127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208500127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208500127">(Aug 30 2020 at 19:22)</a>:</h4>
<p>Actually, there is a bit of a problem with defining <code>coprime a b</code> in a UFD (or UFM) as <code>gcd a b = 1</code>: you would first have to pick a <code>normalization</code>. As Kevin has pointed out a few times already, that could get painful...</p>



<a name="208500137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208500137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208500137">(Aug 30 2020 at 19:23)</a>:</h4>
<p>The definition of UFD needs to be changed, it is not a predicate on rings right now</p>



<a name="208500153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208500153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208500153">(Aug 30 2020 at 19:23)</a>:</h4>
<p>I have a predicate-on-rings (actually on monoids) definition on my branch, but I'm afraid I don't have a great answer to the normalization problem</p>



<a name="208500201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208500201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208500201">(Aug 30 2020 at 19:24)</a>:</h4>
<p>We could generalize <code>gcd_monoid</code> to not require normalization, and only have all of the equations be true up to <code>associated</code>, and then have a separate normalized version</p>



<a name="208500205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208500205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208500205">(Aug 30 2020 at 19:25)</a>:</h4>
<p>and then we'd define <code>coprime a b</code> as <code>is_unit (gcd a b)</code></p>



<a name="208500273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208500273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208500273">(Aug 30 2020 at 19:26)</a>:</h4>
<p>But that's not going to be defeq to <code>nat.coprime</code></p>



<a name="208501709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208501709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208501709">(Aug 30 2020 at 20:01)</a>:</h4>
<p>I'm finding though that we have a normalization for pretty much every specific example we care about - is this not the case here?</p>



<a name="208502222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502222">(Aug 30 2020 at 20:13)</a>:</h4>
<p>Oh right, there's another definition, which still isn't definitionally equal to <code>nat.coprime</code>, but which I think is always at least equivalent to what we want: instead of saying that two elements have no common prime factors, say they have no common non-unit factors</p>



<a name="208502387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502387">(Aug 30 2020 at 20:16)</a>:</h4>
<p>(i.e. any common factor must be a unit)</p>



<a name="208502471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502471">(Aug 30 2020 at 20:19)</a>:</h4>
<p>I don't think we have a normalization for <code>gaussian_int</code>, do we?</p>



<a name="208502483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502483">(Aug 30 2020 at 20:19)</a>:</h4>
<p>let A be the integral closure of Z in C. It is well-known that there are no irreducibles in A, so any two elements are trivially coprime1, but one can easily find elements that are not coprime2. (I'm just exploring examples)</p>



<a name="208502485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502485">(Aug 30 2020 at 20:19)</a>:</h4>
<p>Are 2 and 3 coprime2? (edit: yeah they are)</p>



<a name="208502630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502630">(Aug 30 2020 at 20:22)</a>:</h4>
<p>how do coprime1 and coprime2 behave under ring homs?</p>



<a name="208502639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502639">(Aug 30 2020 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255743">Paul van Wamelen</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233984/near/208502471">said</a>:</p>
<blockquote>
<p>I don't think we have a normalization for <code>gaussian_int</code>, do we?</p>
</blockquote>
<p>Hmmm... I think we don't, we should add that.</p>



<a name="208502841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208502841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208502841">(Aug 30 2020 at 20:28)</a>:</h4>
<p>There is no definition of a normalisation which has nice mathematical properties, so why not just use the axiom of choice to make one?</p>



<a name="208503069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208503069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208503069">(Aug 30 2020 at 20:34)</a>:</h4>
<p>I think for now I'm going to redo what I need in terms of <code>(associates.mk a) ⊓ (associates.mk b) = 1</code>. I can always later restate it in terms of whatever coprime definition we come up with.</p>



<a name="208503448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233984/near/208503448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233984.html#208503448">(Aug 30 2020 at 20:42)</a>:</h4>
<p>Go ahead. I think we should have a definition at the <code>comm_monoid_with_zero</code> level or more general, as a property of the common factors: either saying the common factors are all units, or are not prime. I think we can refactor fairly easily if we decide which one's correct without changing any UFD API.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
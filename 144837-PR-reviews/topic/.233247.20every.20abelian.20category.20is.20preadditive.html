---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html">#3247 every abelian category is preadditive</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202570889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202570889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202570889">(Jul 01 2020 at 13:50)</a>:</h4>
<p>Moving the PR comments to Zulip since the discussion started getting long. We want to be able to somehow move between two structures:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">abelian</span> <span class="kn">extends</span> <span class="n">preadditive</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">[</span><span class="n">has_finite_products</span> <span class="o">:</span> <span class="n">has_finite_products</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_kernels</span> <span class="o">:</span> <span class="n">has_kernels</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_cokernels</span> <span class="o">:</span> <span class="n">has_cokernels</span> <span class="n">C</span><span class="o">]</span>
<span class="o">(</span><span class="n">normal_mono</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">mono</span> <span class="n">f</span><span class="o">],</span> <span class="n">normal_mono</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">normal_epi</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">epi</span> <span class="n">f</span><span class="o">],</span> <span class="n">normal_epi</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">non_preadditive_abelian</span> <span class="o">:=</span>
<span class="o">[</span><span class="n">has_zero_object</span> <span class="o">:</span> <span class="n">has_zero_object</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_zero_morphisms</span> <span class="o">:</span> <span class="n">has_zero_morphisms</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_kernels</span> <span class="o">:</span> <span class="n">has_kernels</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_cokernels</span> <span class="o">:</span> <span class="n">has_cokernels</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_finite_products</span> <span class="o">:</span> <span class="n">has_finite_products</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_finite_coproducts</span> <span class="o">:</span> <span class="n">has_finite_coproducts</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="o">(</span><span class="n">normal_mono</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">mono</span> <span class="n">f</span><span class="o">],</span> <span class="n">normal_mono</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">normal_epi</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">epi</span> <span class="n">f</span><span class="o">],</span> <span class="n">normal_epi</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>


<p>Going from <code>abelian</code> to <code>non_preadditive_abelian</code> is easy. Going the other way is the tricky part. There is a proof of the following:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">preadditive</span> <span class="o">[</span><span class="n">non_preadditive_abelian</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">preadditive</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span> <span class="c">/-</span><span class="cm"> 700 lines omitted -/</span>
</code></pre></div>


<p>but when we try to use this result we run into a typeclass issues in the following declaration:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">abelian</span> <span class="o">[</span><span class="n">non_preadditive_abelian</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">abelian</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">has_finite_products</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">has_kernels</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">has_cokernels</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">normal_mono</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="n">normal_mono</span><span class="o">,</span>
  <span class="n">normal_epi</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="n">normal_epi</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">non_preadditive_abelian</span><span class="bp">.</span><span class="n">preadditive</span> <span class="o">}</span>
</code></pre></div>


<p>The problem is in the details: <code>has_kernels</code> requires an instance of <code>has_zero_morphisms</code>. For <code>abelian</code>, this instance comes from <code>preadditive</code>, but for <code>non_preadditive_abelian</code>, it is an explicit argument. So the <code>has_kernels</code> instance from <code>non_preadditive_abelian</code> is slightly different from what's required for <code>abelian</code>, which is why the line <code>has_kernels := infer_instance</code> fails.</p>



<a name="202634542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202634542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202634542">(Jul 01 2020 at 23:14)</a>:</h4>
<p>Interesting. Presumably we could (unpleasantly) use the fact that <code>has_zero_morphisms</code> is a subsingleton. (e.g. by using something like <code>convert infer_instance, ...</code>)</p>



<a name="202634625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202634625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202634625">(Jul 01 2020 at 23:15)</a>:</h4>
<p>But generally the answer here is meant to be "allow different instances, and carry around proofs that they agree". The proofs part here would be empty, because of the subsingleton property. That is --- can we just add a _separate_ <code>has_zero_morphisms</code> instance to <code>preadditive</code>?</p>



<a name="202650023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202650023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202650023">(Jul 02 2020 at 04:47)</a>:</h4>
<p>I haven't tested this, but I'm afraid adding a <code>has_zero_morphisms</code> to <code>preadditive</code> will result in two <code>has_zero</code> instances, so we will end up with the same problem, just in a different place.</p>



<a name="202652572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202652572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202652572">(Jul 02 2020 at 05:53)</a>:</h4>
<p>Yup... we would have two <code>0</code>s in every homset, provably equal, but not defeq.</p>



<a name="202652658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202652658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202652658">(Jul 02 2020 at 05:55)</a>:</h4>
<p>If we really want to fix this, then we need to unfold all the data in <code>preadditive</code>, maybe even the group structure, instead of simply <code>[add_group (X \hom Y)]</code>. And then we can piece everything together again when we derive</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_zero_morphisms</span> <span class="n">C</span> <span class="o">:=</span> <span class="bp">_</span>
<span class="kn">instance</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_group</span> <span class="o">(</span><span class="n">X</span> <span class="err">\</span><span class="n">hom</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">_</span>
<span class="c1">-- etc</span>
</code></pre></div>



<a name="202653310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202653310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202653310">(Jul 02 2020 at 06:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive/near/202634542">said</a>:</p>
<blockquote>
<p>Interesting. Presumably we could (unpleasantly) use the fact that <code>has_zero_morphisms</code> is a subsingleton. (e.g. by using something like <code>convert infer_instance, ...</code>)</p>
</blockquote>
<p>Indeed, this compiles <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">abelian</span> <span class="o">:</span> <span class="n">abelian</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">has_finite_products</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">has_kernels</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">convert</span> <span class="o">(</span><span class="k">show</span> <span class="n">limits</span><span class="bp">.</span><span class="n">has_kernels</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">,</span> <span class="k">from</span> <span class="n">infer_instance</span><span class="o">),</span>
  <span class="n">has_cokernels</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">convert</span> <span class="o">(</span><span class="k">show</span> <span class="n">limits</span><span class="bp">.</span><span class="n">has_cokernels</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">,</span> <span class="k">from</span> <span class="n">infer_instance</span><span class="o">),</span>
  <span class="n">normal_mono</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">introsI</span><span class="o">,</span> <span class="n">convert</span> <span class="n">normal_mono</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">normal_epi</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">introsI</span><span class="o">,</span> <span class="n">convert</span> <span class="n">normal_epi</span> <span class="n">f</span> <span class="o">},</span>
  <span class="bp">..</span><span class="n">non_preadditive_abelian</span><span class="bp">.</span><span class="n">preadditive</span> <span class="o">}</span>
</code></pre></div>



<a name="202653382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202653382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202653382">(Jul 02 2020 at 06:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive/near/202652658">said</a>:</p>
<blockquote>
<p>If we really want to fix this, then we need to unfold all the data in <code>preadditive</code>, maybe even the group structure, instead of simply <code>[add_group (X \hom Y)]</code>.</p>
</blockquote>
<p>Hm, I find it hard to guess whether that would be worth the effort.</p>



<a name="202653411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202653411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202653411">(Jul 02 2020 at 06:11)</a>:</h4>
<p>Same here</p>



<a name="202653922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202653922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202653922">(Jul 02 2020 at 06:23)</a>:</h4>
<p>It sounds like we're on track again. I'm happy with this solution --- although would like to add a comment explaining why the <code>convert</code>s are there, are why Lean can handle the goals.</p>



<a name="202654774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233247%20every%20abelian%20category%20is%20preadditive/near/202654774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive.html#202654774">(Jul 02 2020 at 06:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive/near/202653922">said</a>:</p>
<blockquote>
<p>It sounds like we're on track again. I'm happy with this solution --- although would like to add a comment explaining why the <code>convert</code>s are there, are why Lean can handle the goals.</p>
</blockquote>
<p>I've added such a comment <a href="https://github.com/leanprover-community/mathlib/pull/3247/files#diff-a5f61fc06b4f1dfce77cfed40ab42e71R502">here</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
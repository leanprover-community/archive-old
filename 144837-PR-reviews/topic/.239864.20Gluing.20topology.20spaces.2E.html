---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html">#9864 Gluing topology spaces.</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266775757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266775757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266775757">(Jan 04 2022 at 07:02)</a>:</h4>
<p>This has been sitting in the queue for a while now, and it is blocking quite a lot of follow ups.<br>
It would be great If someone can check on it.<br>
(Pinging <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  since you had reviewed it before)</p>



<a name="266844134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266844134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266844134">(Jan 04 2022 at 18:15)</a>:</h4>
<p>IMHO, both <code>category_theory.glue_data</code> and <code>topology/gluing</code> need better module docstrings. BTW, why <code>V</code> is defined as a function on <code>J × J</code>, not <code>J → J → C</code>?</p>



<a name="266844286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266844286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266844286">(Jan 04 2022 at 18:16)</a>:</h4>
<p>E.g., it would be nice to explain in the docstring the meaning of <code>U</code>, <code>V</code>, etc in the case when we start with a set <code>X</code> and its open covering.</p>



<a name="266844455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266844455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266844455">(Jan 04 2022 at 18:18)</a>:</h4>
<p>Also, I think that we should have a definition <code>Top.glue_data.of_open_covering</code> and a theorem that says that the round-trip results in a space homeomorphic to the original one.</p>



<a name="266844583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266844583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266844583">(Jan 04 2022 at 18:19)</a>:</h4>
<p>Also, I would prefer to see topology-specific terms "(bundled) topological space", "homeomorphism" instead of generic "object", "isomorphism" but it's a matter of taste.</p>



<a name="266846400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266846400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266846400">(Jan 04 2022 at 18:36)</a>:</h4>
<p>The picture I have in mind when someone says "gluing topology spaces" is the following (and it seems that your construction is more general): we have a family of topological spaces <code>U i</code>; for each pair <code>(i, j)</code> we have a set in <code>U i</code> and a set in <code>U j</code> that are identified via some map; if <code>i = j</code>, then this map is the identity map, the construction is symmetric in <code>i</code>, <code>j</code>, and we have the cocycle condition. It seems that <code>V i j</code> is an abstract topological space that is identified both with a set in <code>U i</code> and with a set in <code>V i</code> via <code>f i j</code> and <code>f j i</code>, respectively. Instead of saying that <code>V i j</code> is isomorphic to <code>V j i</code>, you introduce additional maps <code>t'</code>. It would be nice to have an explanation (and a constructor in the case <code>V : sym2 J → C</code> and/or in the case <code>V i j ≅ V j i</code>).</p>



<a name="266849316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266849316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266849316">(Jan 04 2022 at 19:02)</a>:</h4>
<p>The existence of such a map <code>t'</code> does not really loosen the condition that <code>V i j ≅ V j i</code>. It's just that we can infer <code>V i j ≅ V j i</code> from the<br>
data given so that we does not need to provide it explicitly.<br>
The <code>t'</code> is merely a translation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>∩</mo><msub><mi>V</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>⊆</mo><msubsup><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>V</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><mo>∩</mo><msub><mi>V</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_{ij} \cap V_{ik} \subseteq t _{ij}^{-1}(V_{ji} \cap V_{jk})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2672em;vertical-align:-0.413em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8542em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">jk</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> into a more categorical language.<br>
And I should probably say this in the doc string.</p>



<a name="266952242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/266952242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#266952242">(Jan 05 2022 at 15:54)</a>:</h4>
<p>I've added a constructor that is less categorically flavoured and provided the "gluing open subsets" stuff.<br>
I also added some more clarifications in the docs but I'm not sure if that is enough or not.</p>



<a name="267053767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267053767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267053767">(Jan 06 2022 at 12:11)</a>:</h4>
<p>Does anyone want to give this a final look before I kick this on the queue?<br>
There were quite some changes since it was delegated.<br>
Specifically, I added a new file to contain the <code>elementwise</code> lemmas to fix the lint error.<br>
As a sidenote, does <code>local attribute [reassoc]</code> do the same thing as <code>attribute [reassoc]</code>?<br>
If so, should we add a linter to forbid the former? (same for <code>elementwise</code>).</p>



<a name="267053833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267053833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267053833">(Jan 06 2022 at 12:12)</a>:</h4>
<p><code>local attribute [x]</code> only adds the attribute to <code>x</code> for that file, so if other files import the file, they won't get the attribute.</p>



<a name="267053971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267053971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267053971">(Jan 06 2022 at 12:13)</a>:</h4>
<p>Adding the attribute <code>reassoc</code> to a lemma generates a new simp lemma, but that lemma does not seem to be private or local, and it caused a naming clash when the linter imported <code>all.lean</code>.</p>



<a name="267054432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267054432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267054432">(Jan 06 2022 at 12:19)</a>:</h4>
<p>Oh of course! So specific to <code>reassoc</code> the question is interesting. Sorry, I'd missed your point.</p>



<a name="267065742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267065742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267065742">(Jan 06 2022 at 14:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> I guess this is a question for you guys <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span></p>



<a name="267066314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267066314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267066314">(Jan 06 2022 at 14:27)</a>:</h4>
<p>Yes, I agree it would make sense if <code>local attribute [reassoc]</code> generated a private (or at least non-global) lemma.  I don't think we have a function to add private definitions though (so we'd need to make a name ourselves).</p>



<a name="267066458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%239864%20Gluing%20topology%20spaces./near/267066458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.239864.20Gluing.20topology.20spaces.2E.html#267066458">(Jan 06 2022 at 14:28)</a>:</h4>
<p>BTW, you can also write <code>simp [reassoc_of my_lemma]</code> if you only need it once or twice.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
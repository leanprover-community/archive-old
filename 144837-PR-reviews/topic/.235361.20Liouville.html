---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.235361.20Liouville.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html">#5361 Liouville</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220000343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/220000343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#220000343">(Dec 15 2020 at 16:05)</a>:</h4>
<p>I left several comments on the partial PR <a href="https://github.com/leanprover-community/mathlib/issues/5361">#5361</a>.  I am still hoping to get the <code>t2_space</code> stuff in.  In the meantime, though, I hope that the suggestions that I proposed are viewed as improvements!</p>



<a name="220350419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/220350419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#220350419">(Dec 18 2020 at 09:24)</a>:</h4>
<p>After a further clean up, I pushed a version of this PR that is hopefully a step closer to being imported to mathlib.</p>
<p>I tried to maintain lemmas with the literal statements of the initial PR, but I proved them as consequences of other lemmas that I believe are more direct.  Once I take a look at the subsequent PR, I may be in a better position to know which form is preferable.</p>
<p>I created a separate file <code>prelims_polynomial.lean</code> containing results that do not belong to the main file of this PR and that may be scattered around.  Rather than scattering them around already, I preferred to keep them all together: these results may not be needed in the end, depending on the final shape of the main lemmas.</p>



<a name="221132881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221132881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221132881">(Dec 29 2020 at 13:09)</a>:</h4>
<p>One more step in the direction of importing this PR: I created PR <a href="https://github.com/leanprover-community/mathlib/issues/5523">#5523</a> with 4 lemmas on discrete subsets of a topological space.  The lemmas are due to Patrick, the naming is my addition: feel free to suggest better names!</p>



<a name="221388503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221388503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221388503">(Jan 02 2021 at 07:24)</a>:</h4>
<p>Happy 2021!</p>
<p>In the process of cleaning up this PR, I reduced one of the statements to the two lemmas below.  If anyone has any golfing tips for simplifying the arguments, I would be glad to hear them!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.irrational</span>

<span class="kd">def</span> <span class="n">is_liouville</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
  <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">int.mul_lt_mul_pow_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span>
 <span class="o">(</span><span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span>
 <span class="o">(</span><span class="n">q1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">q2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span>
    <span class="o">(</span><span class="n">pow_le_pow_of_le_left</span> <span class="n">zero_le_two</span> <span class="o">((</span><span class="n">int.lt_iff_add_one_le</span> <span class="mi">1</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">q1</span><span class="o">)</span> <span class="n">n</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">^</span><span class="n">n</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">le_mul_iff_one_le_left</span> <span class="o">(</span><span class="n">pow_pos</span> <span class="n">zero_lt_two</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">((</span><span class="n">int.lt_iff_add_one_le</span> <span class="mi">0</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">a0</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ'</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">mul_lt_mul_right</span> <span class="o">(</span><span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">q1</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">_</span> <span class="n">a2</span><span class="o">)</span> <span class="n">q2</span><span class="o">),</span>
  <span class="n">exact_mod_cast</span> <span class="n">nat.lt_two_pow</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">irrational_of_is_liouville</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_liouville</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">irrational</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">irrational_of_ne_int_div_pos_nat</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h_b_pos</span> <span class="n">h_rid</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">subst</span> <span class="n">h_rid</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">q1</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">a1</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">qR0</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="o">(</span><span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">q1</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">bR0</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="n">h_b_pos</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">b0</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">h_b_pos</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">div_sub_div</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">b0</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">qR0</span><span class="o">),</span> <span class="n">abs_div</span><span class="o">]</span> <span class="n">at</span> <span class="n">a0</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">lt_div_iff</span> <span class="o">(</span><span class="n">abs_pos.mpr</span> <span class="o">(</span><span class="n">mul_ne_zero</span> <span class="n">b0</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">qR0</span><span class="o">))),</span> <span class="n">zero_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">a0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">div_lt_div_iff</span> <span class="n">_</span> <span class="o">(</span><span class="n">pow_pos</span> <span class="n">qR0</span> <span class="n">_</span><span class="o">),</span> <span class="bp">@</span><span class="n">abs_of_pos</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_pos</span> <span class="n">bR0</span> <span class="n">qR0</span><span class="o">),</span> <span class="n">one_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">not_le.mpr</span> <span class="n">a1</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="o">(</span><span class="n">int.mul_lt_mul_pow_succ</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">a0</span><span class="o">)</span> <span class="n">q1</span><span class="o">))</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">abs_pos.mpr</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="o">(</span><span class="n">mul_pos</span> <span class="n">bR0</span> <span class="n">qR0</span><span class="o">))</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221397326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221397326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221397326">(Jan 02 2021 at 12:11)</a>:</h4>
<p>Your first lemma is about nonnegative ints. Here's my effort:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- should be in mathlib</span>
<span class="kd">lemma</span> <span class="n">nat.lt_mul_of_pos_of_lt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">),</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="n">one_mul</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">hbc</span><span class="o">,</span> <span class="n">lt_of_lt_of_le</span>
    <span class="o">(</span><span class="n">nat.lt_mul_of_pos_of_lt</span> <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">hbc</span><span class="o">)</span>
    <span class="o">(</span><span class="n">nat.mul_le_mul_right</span> <span class="n">c</span> <span class="o">(</span><span class="n">nat.le_succ</span> <span class="n">_</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">nat.mul_lt_mul_pow_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">q1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">n</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ'</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_lt_mul_right</span> <span class="o">(</span><span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">q1</span><span class="o">)],</span>
  <span class="n">exact</span> <span class="n">nat.lt_mul_of_pos_of_lt</span> <span class="n">a0</span> <span class="o">(</span><span class="n">nat.lt_pow_self</span> <span class="n">q1</span> <span class="n">n</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">int.mul_lt_mul_pow_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">q1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">lift</span> <span class="n">a</span> <span class="n">to</span> <span class="n">ℕ</span> <span class="n">using</span> <span class="n">le_of_lt</span> <span class="n">a0</span><span class="o">,</span>
  <span class="n">lift</span> <span class="n">q</span> <span class="n">to</span> <span class="n">ℕ</span> <span class="n">using</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">zero_le_one</span><span class="o">)</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">q1</span><span class="o">),</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.mul_lt_mul_pow_succ</span> <span class="n">a0</span> <span class="n">q1</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Your second lemma doesn't compile for me, I don't have <code>irrational_of_ne_int_div_pos_nat</code></p>



<a name="221402251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221402251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221402251">(Jan 02 2021 at 14:32)</a>:</h4>
<p>Ah, thanks!</p>
<p>That lemma is in data.real.irrational: I copy the beginning below!</p>
<p>Thanks again!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.sqrt</span>
<span class="kn">import</span> <span class="n">data.rat.sqrt</span>
<span class="kn">import</span> <span class="n">ring_theory.int.basic</span>
<span class="kn">import</span> <span class="n">data.polynomial.eval</span>
<span class="kn">import</span> <span class="n">data.polynomial.degree</span>
<span class="kn">import</span> <span class="n">tactic.interval_cases</span>
<span class="c">/-</span><span class="cm">!</span>
<span class="cm"># Irrational real numbers</span>

<span class="cm">In this file we define a predicate `irrational` on `ℝ`, prove that the `n`-th root of an integer</span>
<span class="cm">number is irrational if it is not integer, and that `sqrt q` is irrational if and only if</span>
<span class="cm">`rat.sqrt q * rat.sqrt q ≠ q ∧ 0 ≤ q`.</span>

<span class="cm">We also provide dot-style constructors like `irrational.add_rat`, `irrational.rat_sub` etc.</span>
<span class="cm">-/</span>

<span class="kn">open</span> <span class="n">rat</span> <span class="n">real</span> <span class="n">multiplicity</span>

<span class="sd">/-- A real number is irrational if it is not equal to any rational number. -/</span>
<span class="kd">def</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">irrational_iff_ne_rational</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">irrational</span> <span class="n">x</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">irrational</span><span class="o">,</span> <span class="n">rat.forall</span><span class="o">,</span> <span class="n">cast_mk</span><span class="o">,</span> <span class="n">not_exists</span><span class="o">,</span> <span class="n">set.mem_range</span><span class="o">,</span> <span class="n">cast_coe_int</span><span class="o">,</span> <span class="n">cast_div</span><span class="o">,</span>
  <span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">irrational_of_ne_int_div_pos_nat</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">):</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">a</span><span class="bp">/</span><span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">irrational</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">irrational_iff_ne_rational</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="mi">0</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b_gt</span> <span class="bp">|</span> <span class="n">b_0</span> <span class="bp">|</span> <span class="n">b_lt</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">lift</span> <span class="n">b</span> <span class="n">to</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b_gt</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_of_lt</span> <span class="n">b_gt</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hrid</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">b_0</span><span class="o">,</span> <span class="n">int.cast_zero</span><span class="o">,</span> <span class="n">div_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">hrid</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">int.cast_zero</span><span class="o">,</span> <span class="n">zero_div</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="n">hrid</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">b.nat_abs</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int.abs_eq_nat_abs</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs_of_neg</span> <span class="n">b_lt</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">rat.mk_eq_div</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">cast_coe_int</span><span class="o">,</span> <span class="n">cast_neg</span><span class="o">,</span> <span class="n">int.cast_neg</span><span class="o">,</span> <span class="n">cast_div</span><span class="o">,</span> <span class="n">neg_div_neg_eq</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">zify</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int.abs_eq_nat_abs</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs_pos</span><span class="o">],</span> <span class="n">exact</span> <span class="n">ne_of_lt</span> <span class="n">b_lt</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221402417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221402417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221402417">(Jan 02 2021 at 14:37)</a>:</h4>
<p>That's not what the version in mathlib master looks like.</p>



<a name="221404219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221404219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221404219">(Jan 02 2021 at 15:31)</a>:</h4>
<p>Oh, I hadn't realized that: I simply used the version that came with the liouville PR...</p>



<a name="221404225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221404225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221404225">(Jan 02 2021 at 15:31)</a>:</h4>
<p>Anyway, the above should work, right?  It appears to work on my computer</p>



<a name="221405197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405197">(Jan 02 2021 at 15:58)</a>:</h4>
<p>it doesn't work for me with mathlib master. Maybe you should merge master into the branch and fix up issues?</p>



<a name="221405461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405461">(Jan 02 2021 at 16:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221404219">said</a>:</p>
<blockquote>
<p>Oh, I hadn't realized that: I simply used the version that came with the liouville PR...</p>
</blockquote>
<p>The version of data.real.irrational which comes with the PR we're talking about does not have <code>irrational_of_ne_int_div_pos_nat</code> either. I don't know what you posted! But it seems to me that sticking with mathlib master is a better idea.</p>



<a name="221405542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405542">(Jan 02 2021 at 16:07)</a>:</h4>
<p>Ok, once I am back at my computer, I will <code>git pull</code> and then proceed from there!</p>
<p>Given that we are here, what is the proof with the <code>|</code>?  From what I picked up in other threads, this might be called the "equation compiler"?  Or something like this?</p>



<a name="221405546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405546">(Jan 02 2021 at 16:07)</a>:</h4>
<p>Yeah it's the equation compiler. It's just induction or recursion, if you use it with naturals. It's <code>blah.rec</code> but with a different syntax.</p>



<a name="221405600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405600">(Jan 02 2021 at 16:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fibonacci</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fibonacci</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>If you think about it, it's done something clever here, because usual (weak) induction would not have access to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">F_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="221405686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405686">(Jan 02 2021 at 16:11)</a>:</h4>
<p>I see.  So the <code>rintro ⟨⟩</code> bit in the proof above is to let Lean know that this (<code>a = 0</code>) contradicts one of the assumptions, right?</p>



<a name="221405764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405764">(Jan 02 2021 at 16:13)</a>:</h4>
<p>Right. The three inputs after the <code>|</code> are a,b,c, and so after the := the goal is <code>0 &lt; 0 -&gt; ...</code> and I kill it with <code>rintro ⟨⟩</code> because I know that <code>&lt;</code> on nat is defined as an inductive Prop and that there aren't any cases.</p>



<a name="221405808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405808">(Jan 02 2021 at 16:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩</span>
</code></pre></div>



<a name="221405882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405882">(Jan 02 2021 at 16:17)</a>:</h4>
<p>Ok, thanks for the explanation!  It is a little imperscrutable, since in term mode, the sidebar is not particularly friendly, if you are trying to figure out how the syntax works!</p>



<a name="221405886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405886">(Jan 02 2021 at 16:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">2</span><span class="bp">+</span><span class="mi">2</span><span class="bp">=</span><span class="mi">5</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h_ᾰ</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>That proof is bad because it contains the character of which we should not speak, but I don't know how to name it.</p>



<a name="221405939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405939">(Jan 02 2021 at 16:18)</a>:</h4>
<p>This proof actually can be golfed away completely:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">5</span><span class="bp">.</span>
</code></pre></div>
<p>I can't find any way to use this trick with the equation compiler though.</p>



<a name="221405940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405940">(Jan 02 2021 at 16:18)</a>:</h4>
<p>You can always use <code>begin sorry end</code> to try and figure out what the heck is going on anywhere. The syntax is: you don't use <code>:=</code>, you use <code>|</code> and then the inputs are all the things after the colon. It's all explained in chapters 7 and 8 of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> so I have known it for a while, but I totally agree that it doesn't really seem to come up that often in proper maths!</p>



<a name="221405954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221405954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221405954">(Jan 02 2021 at 16:19)</a>:</h4>
<p>Here Bryan's full stop means "we have finished" -- and something (I thought it was the equation compiler!) verifies that indeed there are no cases.</p>



<a name="221406080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406080">(Jan 02 2021 at 16:23)</a>:</h4>
<p>Ah, maybe it is related to the equation compiler. I just mean that I don't know how to use that in your proof of <code>nat.lt_mul_of_pos_of_lt</code>.</p>



<a name="221406150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406150">(Jan 02 2021 at 16:25)</a>:</h4>
<p>Ok, it is vaguely making sense although I will try to read about it in tpil to see if I understand it better!</p>
<p>Also, the lemma <code>lt_mul_of_lt_of_one_le</code> exists for an <code>ordered_cancel_comm_monoid</code>, which I guess means that <code>*</code> is the only operation, right?</p>



<a name="221406151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406151">(Jan 02 2021 at 16:25)</a>:</h4>
<p>This is weird:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">2</span><span class="bp">+</span><span class="mi">2</span><span class="bp">=</span><span class="mi">5</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span><span class="bp">?</span><span class="o">,</span> <span class="c1">-- solves the goal and suggests Try this: rintro (_ | _)</span>
<span class="kd">end</span>

<span class="c1">-- However, the suggestion doesn't solve the goal:</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">2</span><span class="bp">+</span><span class="mi">2</span><span class="bp">=</span><span class="mi">5</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">_</span><span class="o">),</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">1 goal</span>
<span class="cm">ᾰ_ᾰ: 3.succ.less_than_or_equal 0</span>
<span class="cm">⊢ 2 + 2 = 5</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221406200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406200">(Jan 02 2021 at 16:26)</a>:</h4>
<p>It doesn't solve the goal for me -- I get the funky metavariable error (I do get Goals Accomplished though!)</p>



<a name="221406210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406210">(Jan 02 2021 at 16:27)</a>:</h4>
<p>Oh, you're right. I missed the red squiggles at the end.</p>
<p><strong>edit</strong>: I've added this example to <a href="https://github.com/leanprover-community/mathlib/issues/2794">#2794</a>, which has a few other examples like this.</p>



<a name="221406222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406222">(Jan 02 2021 at 16:27)</a>:</h4>
<p>I have never got to the bottom of how to name that variable though. Yours is even worse than mine -- badsymbol_badsymbol!</p>



<a name="221406274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406274">(Jan 02 2021 at 16:28)</a>:</h4>
<p>Why doesn't <code>rintro (_ | h),</code> work?</p>



<a name="221406295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406295">(Jan 02 2021 at 16:29)</a>:</h4>
<p>The unicode name for <code>ᾰ</code> is something like "alpha with vrachy", where "vrachy" is apparently one name for that diacritic; <a href="https://en.wikipedia.org/wiki/Breve">the Wikipedia article calls it "breve"</a>.</p>



<a name="221406305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406305">(Jan 02 2021 at 16:30)</a>:</h4>
<p>Oh I think it's because <code>rintro (_ | ⟨_ | _⟩)</code> isn't allowed syntax. Oh it's coming back to me now. You can't hope to do arbitrary unravellings with the <code>rintro</code> syntax, or something.</p>



<a name="221406466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406466">(Jan 02 2021 at 16:33)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/rintro.20.3C.20equation.20compiler.3F/near/214405665">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rintro.20.3C.20equation.20compiler.3F/near/214405665</a></p>



<a name="221406613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406613">(Jan 02 2021 at 16:37)</a>:</h4>
<p>Not sure whether this counts as "being in mathlib", but this is also a proof of that lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.lt_mul_of_pos_of_lt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">),</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">a0</span> <span class="n">bc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_mul</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_lt_mul'</span> <span class="o">(</span><span class="n">nat.succ_le_iff.mpr</span> <span class="n">a0</span><span class="o">)</span> <span class="n">bc</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">b</span><span class="o">)</span> <span class="n">a0</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221406675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406675">(Jan 02 2021 at 16:38)</a>:</h4>
<p>Yeah I thought the equation compiler would be a nicer way to do it but I hadn't realised there were three cases.</p>



<a name="221406682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406682">(Jan 02 2021 at 16:39)</a>:</h4>
<p>That looks ready to PR (after moving as much as you can "before the colon").</p>



<a name="221406765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406765">(Jan 02 2021 at 16:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.lt_mul_of_pos_of_lt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_mul</span> <span class="n">b</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mul_lt_mul'</span> <span class="o">(</span><span class="n">nat.succ_le_iff.mpr</span> <span class="n">ha</span><span class="o">)</span> <span class="n">hbc</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">b</span><span class="o">)</span> <span class="n">ha</span><span class="o">}</span>
</code></pre></div>
<p>(Unfortunately, I am not at my computer, so I will not be able to make this PR, nor would I really know where to put it...)</p>



<a name="221406804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406804">(Jan 02 2021 at 16:42)</a>:</h4>
<p>Unless one of you makes the PR, I will try to do it later!</p>



<a name="221406809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406809">(Jan 02 2021 at 16:42)</a>:</h4>
<p>Do you know -- I think I have some kind of conceptual misunderstanding of induction here. I want to say "OK proof by induction on a. Base case done by contradiction. Inductive step -- we know b&lt;ac and we want b&lt;(a+1)c so done because c&gt;=0".</p>



<a name="221406822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406822">(Jan 02 2021 at 16:42)</a>:</h4>
<p>[I'm impressed with all that lean code you're writing if you're not at your computer, by the way]</p>



<a name="221406824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406824">(Jan 02 2021 at 16:43)</a>:</h4>
<p>In my mind, the step "multiply by 1 works" is important, though... no?</p>



<a name="221406827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406827">(Jan 02 2021 at 16:43)</a>:</h4>
<p>I am at "a" computer, though not mine: I am using the online lean editor</p>



<a name="221406832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406832">(Jan 02 2021 at 16:43)</a>:</h4>
<p>So I do not have the git stuff</p>



<a name="221406844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406844">(Jan 02 2021 at 16:44)</a>:</h4>
<p><code>b&lt;ac-&gt;b&lt;(a+1)c</code> is always true, and the base case is trivial because it can't happen, so I thought we were done. Is this not a valid proof?</p>



<a name="221406914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406914">(Jan 02 2021 at 16:45)</a>:</h4>
<p>hmmm, it kind of feels like the "all horses are white" proof... I need to think!  I thought that I was a professional mathematician and I am confused by this proof!</p>



<a name="221406979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406979">(Jan 02 2021 at 16:46)</a>:</h4>
<p>there is the assumption ha which plays a big role in the base case and then disappears: this feels wrong to me</p>



<a name="221406987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406987">(Jan 02 2021 at 16:47)</a>:</h4>
<p>(by wrong, I mean for the induction above to work without considering the case a = 1 as well)</p>



<a name="221406989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406989">(Jan 02 2021 at 16:47)</a>:</h4>
<p>Should this lemma be about <code>ordered_semiring </code> instead of <code>nat</code>?</p>



<a name="221406997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406997">(Jan 02 2021 at 16:47)</a>:</h4>
<p>Right! If I put "0&lt;a" in the statement P(a) we're proving by induction on a, then the inductive step needs a proof that 0&lt;d to deal with the d+1 case. But if I don't put it in, I can't prove the base case!</p>



<a name="221406999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221406999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221406999">(Jan 02 2021 at 16:47)</a>:</h4>
<p>Eric we're using 0&lt;a -&gt; 1&lt;=a</p>



<a name="221407054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407054">(Jan 02 2021 at 16:48)</a>:</h4>
<p>This is already in lean for various kind of ordered monoid but under the assumption 1&lt;=a, and furthermore none of the lemmas I could find in mathlib applied to nat, so I figured I'd prove it for nat explicitly and then 1&lt;=a looked a bit daft so I changed it to 0 &lt; a</p>



<a name="221407060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407060">(Jan 02 2021 at 16:49)</a>:</h4>
<p>nat is an ordered_add_monoid but apparently not an ordered_comm_monoid</p>



<a name="221407139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407139">(Jan 02 2021 at 16:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221407060">said</a>:</p>
<blockquote>
<p>nat is an ordered_add_monoid but apparently not an ordered_comm_monoid</p>
</blockquote>
<p>Doesn't that instance come from <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.canonically_ordered_comm_semiring">docs#nat.canonically_ordered_comm_semiring</a>?</p>



<a name="221407196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407196">(Jan 02 2021 at 16:53)</a>:</h4>
<p>I am glad that we solved the "induction" proof!  It works in that way if we phrase it for <code>a.succ</code>, in which case, the base case is the multiplication by 1, and then the implication that Kevin mentions!</p>



<a name="221407204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407204">(Jan 02 2021 at 16:53)</a>:</h4>
<p>(Also, the assumption <code>ha</code> does not play any role with <code>a.succ</code>.)</p>



<a name="221407252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407252">(Jan 02 2021 at 16:54)</a>:</h4>
<p>?? I just assumed that 0 was causing problems and there would be an axiom failing. As far as I can see <code>nat</code> is indeed an <code>ordered_comm_monoid</code>, so in fact one can just use <code>lt_mul_of_one_le_of_lt'</code></p>



<a name="221407272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407272">(Jan 02 2021 at 16:55)</a>:</h4>
<p><code>lt_mul_of_one_le_of_lt'</code> does not unify, though, right?  Am I missing something here?</p>



<a name="221407331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407331">(Jan 02 2021 at 16:57)</a>:</h4>
<p>I think 0 &lt; a might be defeq to 1 &lt;= a? So it might. The main issue is that either I'm making a stupid mistake (which could easily be the case -- either a maths one or a Lean one) or Lean does not have an instance of <code>ordered_comm_monoid ℕ</code>. I might be missing an import.</p>



<a name="221407401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407401">(Jan 02 2021 at 16:59)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mathlib_docs/find/lt_mul_of_one_le_of_lt'">docs#lt_mul_of_one_le_of_lt'</a> for reference)</p>



<a name="221407476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407476">(Jan 02 2021 at 17:00)</a>:</h4>
<p>The field <code>ordered_comm_monoid.lt_of_mul_lt_mul_left</code> doesn't hold for <code>ℕ</code>, does it?</p>



<a name="221407489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407489">(Jan 02 2021 at 17:01)</a>:</h4>
<p>How does the <code>0</code> in nat interact with the "ordered_comm_monoid" that uses <code>1</code> and multiplication?  I feel a little lost...</p>



<a name="221407500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407500">(Jan 02 2021 at 17:01)</a>:</h4>
<p>should it be an <code>ordered_comm_monoid_with_zero</code> thing?</p>



<a name="221407529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407529">(Jan 02 2021 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221407476">said</a>:</p>
<blockquote>
<p>The field <code>ordered_comm_monoid.lt_of_mul_lt_mul_left</code> doesn't hold for <code>ℕ</code>, does it?</p>
</blockquote>
<p>This is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span>
</code></pre></div>
<p>. What's your counterexample?</p>



<a name="221407549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407549">(Jan 02 2021 at 17:02)</a>:</h4>
<p><del>When a = 0...</del></p>



<a name="221407554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407554">(Jan 02 2021 at 17:02)</a>:</h4>
<p>I don't have one because I can't read implications properly</p>



<a name="221407555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407555">(Jan 02 2021 at 17:02)</a>:</h4>
<p>Ah, sorry!</p>



<a name="221407558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407558">(Jan 02 2021 at 17:02)</a>:</h4>
<p>Strict inequality!</p>



<a name="221407756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407756">(Jan 02 2021 at 17:07)</a>:</h4>
<p>Does this mean that with an instance of <code>ordered_comm_monoid</code> on nat, then the lemma above is in mathlib?</p>



<a name="221407766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407766">(Jan 02 2021 at 17:08)</a>:</h4>
<p>I think so, I'm still doing the axiom :-) It's a long time since I played the natural number game!</p>



<a name="221407965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221407965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221407965">(Jan 02 2021 at 17:12)</a>:</h4>
<p>Yes, the lemma is already in mathlib. When I was looking for the lemma earlier, I tried <code>lt_mul_of_one_le_of_lt</code> and <code>lt_mul_of_one_le_of_lt'</code> and neither of them worked, so I just assumed that <code>nat</code> did not satisfy the axioms of  <code>ordered_cancel_comm_monoid</code> or <code>ordered_comm_monoid</code> and proved the lemma directly for nat.</p>



<a name="221408396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408396">(Jan 02 2021 at 17:23)</a>:</h4>
<p>I'm trying to define the instance in <code>data/nat/basic.lean</code>, but vs-code seems to really struggle when you start editing that low</p>



<a name="221408459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408459">(Jan 02 2021 at 17:24)</a>:</h4>
<p>Do you have other files open that are much higher in the import hierarchy?</p>



<a name="221408465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408465">(Jan 02 2021 at 17:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">theorem</span> <span class="n">nat.lt_of_mul_lt_mul_left</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat.mul_le_mul_left</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ordered_comm_monoid</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul_le_mul_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="n">k</span><span class="o">,</span> <span class="n">nat.mul_le_mul_left</span> <span class="n">k</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">nat.lt_of_mul_lt_mul_left</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">nat.comm_monoid</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">nat.partial_order</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nat.lt_mul_of_pos_of_lt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="n">lt_mul_of_one_le_of_lt'</span> <span class="n">ha</span>
</code></pre></div>



<a name="221408476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408476">(Jan 02 2021 at 17:24)</a>:</h4>
<p>Yeah, editing data.nat.basic is not much fun nowadays, especially when you're just adding in a lemma because you're proving a theorem about fancy objects much lower down.</p>



<a name="221408547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408547">(Jan 02 2021 at 17:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221408459">said</a>:</p>
<blockquote>
<p>Do you have other files open that are much higher in the import hierarchy?</p>
</blockquote>
<p>No, but I have a bunch of unsaved buffers open</p>



<a name="221408557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408557">(Jan 02 2021 at 17:27)</a>:</h4>
<p>Btw, this feels like "second-order golfing" to me...</p>



<a name="221408713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408713">(Jan 02 2021 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221408547">said</a>:</p>
<blockquote>
<p>No, but I have a bunch of unsaved buffers open</p>
</blockquote>
<p>That might be the culprit. I usually try to just edit as few files at a time as possible, since I think the Lean server isn't actually able to "close" a file that it's opened in the same session.</p>



<a name="221408758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408758">(Jan 02 2021 at 17:32)</a>:</h4>
<p>So the "visible files" setting in vs-code actually means "all buffers that were at one point visible"?</p>



<a name="221408801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408801">(Jan 02 2021 at 17:33)</a>:</h4>
<p>I'm not sure actually... <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> ?</p>



<a name="221408807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408807">(Jan 02 2021 at 17:33)</a>:</h4>
<p>It's kind of ironic that to prove the implication <code>b &lt; c → b &lt; a * c</code> it suffices to prove <code>a * b &lt; a * c → b &lt; c</code> which seems to go the wrong way!</p>



<a name="221408952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221408952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221408952">(Jan 02 2021 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221408758">said</a>:</p>
<blockquote>
<p>So the "visible files" setting in vs-code actually means "all buffers that were at one point visible"?</p>
</blockquote>
<p>Yeah, kind of.  "Visible files" queues everything that is in a visible file.  If you then close a file, the proofs remain in the queue.</p>



<a name="221409144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221409144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221409144">(Jan 02 2021 at 17:40)</a>:</h4>
<p>Does restarting the lean server clear the queue?</p>



<a name="221409281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221409281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221409281">(Jan 02 2021 at 17:44)</a>:</h4>
<p>Yes, it should.</p>



<a name="221409731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221409731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221409731">(Jan 02 2021 at 17:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221406305">said</a>:</p>
<blockquote>
<p>Oh I think it's because <code>rintro (_ | ⟨_ | _⟩)</code> isn't allowed syntax. Oh it's coming back to me now. You can't hope to do arbitrary unravellings with the <code>rintro</code> syntax, or something.</p>
</blockquote>
<p>The second part of this is correct, but the first isn't - <code>rintro (_ | ⟨_ | _⟩)</code> is allowed syntax, it just doesn't do what you want here. I'm thinking of closing <a href="https://github.com/leanprover-community/mathlib/issues/2794">#2794</a> unless someone proposes a syntax extension that would allow writing <code>rintro ⟨(a|b), if first_case then (_|_) else ⟨_,_,_⟩⟩</code> which is the general structure of inexpressible patterns.</p>



<a name="221409880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221409880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221409880">(Jan 02 2021 at 18:00)</a>:</h4>
<p>Why is this not just <code>rintro ⟨((_|_)|⟨_, _, _⟩)⟩</code>? I clearly still don't understand this properly.</p>



<a name="221409949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221409949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221409949">(Jan 02 2021 at 18:00)</a>:</h4>
<p>If there are some cases that can't be handled, is there a way to make <code>rintro?</code> give an error message instead?</p>



<a name="221409966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221409966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221409966">(Jan 02 2021 at 18:01)</a>:</h4>
<p>Actually in the present example the correct match is <code>rintro (_|⟨_,⟨⟩⟩),</code> which is expressible, so there might actually be a bug</p>



<a name="221410149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410149">(Jan 02 2021 at 18:05)</a>:</h4>
<p>Here's an example of a dependent pattern:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">def</span> <span class="n">P</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">4</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">P</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">ff</span><span class="bp">|</span><span class="n">tt</span><span class="o">,</span> <span class="n">pat</span><span class="o">⟩,</span> <span class="c1">-- we need pat to be two things:</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">pat</span> <span class="k">with</span> <span class="n">h1</span><span class="bp">|</span><span class="n">h2</span><span class="bp">|</span><span class="n">h3</span><span class="bp">;</span> <span class="gr">sorry</span> <span class="o">},</span> <span class="c1">-- an alternation</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">pat</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩</span><span class="bp">;</span> <span class="gr">sorry</span> <span class="o">},</span> <span class="c1">-- but also a tuple</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221410226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410226">(Jan 02 2021 at 18:07)</a>:</h4>
<p>you can't use <code>(h1|h2|h3)|⟨n, h1⟩</code> for <code>pat</code> (try it!) because this actually means "pattern match <code>pat</code> as if it were <code>(0 &lt; 1 ∨ 2 &lt; 3 ∨ 3 &lt; 4) ∨ ∃ n, n &lt; 3</code>" which is true of neither case</p>



<a name="221410285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410285">(Jan 02 2021 at 18:09)</a>:</h4>
<p>Yes here I can see why there is a problem. But I can't see why there's a problem in what I was trying to do -- and I couldn't name my variable either! Is this also expected?</p>



<a name="221410348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410348">(Jan 02 2021 at 18:10)</a>:</h4>
<p>the first level pattern match is actually <code>_|&lt;_,ha&gt;</code> where <code>ha</code> is the one that is actually in the context</p>



<a name="221410385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410385">(Jan 02 2021 at 18:11)</a>:</h4>
<p>that's because <code>nat.less_than_or_equal</code> is an inductive type with two cases, where the first has one constructor argument and the second has two, the second of which is what appears in the context</p>



<a name="221410431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410431">(Jan 02 2021 at 18:12)</a>:</h4>
<p>Could we have another syntax (maybe <code>a |' b</code> for consistency with the <code>∘'</code> notation for <a href="https://leanprover-community.github.io/mathlib_docs/find/function.dcomp">docs#function.dcomp</a>) meaning "use <code>a</code> if it is type-correct else use <code>b</code>"?</p>



<a name="221410452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410452">(Jan 02 2021 at 18:12)</a>:</h4>
<p>Using <code>cases</code> makes this confusing because the first case is immediately proven impossible so you don't see it, and the second case has a variable that has been <code>subst</code>'d away so you also don't see it</p>



<a name="221410469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410469">(Jan 02 2021 at 18:13)</a>:</h4>
<p>but rcases requires that you actually give names according to the original shape of the inductive, to make it more predictable</p>



<a name="221410470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410470">(Jan 02 2021 at 18:13)</a>:</h4>
<p>Is there any way to name the hypothesis you get in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">2</span><span class="bp">+</span><span class="mi">2</span><span class="bp">=</span><span class="mi">5</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">h</span><span class="o">),</span>
  <span class="c1">-- no h in sight</span>
<span class="kd">end</span>
</code></pre></div>
<p>?</p>



<a name="221410514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410514">(Jan 02 2021 at 18:14)</a>:</h4>
<p>Yes, <code>_|&lt;_,h&gt;</code></p>



<a name="221410516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410516">(Jan 02 2021 at 18:14)</a>:</h4>
<p>That's not two pattern matches, it's one</p>



<a name="221410526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410526">(Jan 02 2021 at 18:14)</a>:</h4>
<p>an inductive pattern match is a alt-of-tuples in general</p>



<a name="221410542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410542">(Jan 02 2021 at 18:15)</a>:</h4>
<p>I gave up too early!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">2</span><span class="bp">+</span><span class="mi">2</span><span class="bp">=</span><span class="mi">5</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">_</span><span class="bp">|</span><span class="o">⟨</span><span class="n">_</span><span class="o">,(</span><span class="n">_</span><span class="bp">|</span><span class="n">_</span><span class="o">)⟩),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221410556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410556">(Jan 02 2021 at 18:15)</a>:</h4>
<p>lol wait till I tell my maths chums that <code>(_|⟨_,(_|_)⟩)</code> is a proof that 1&lt;=3</p>



<a name="221410604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410604">(Jan 02 2021 at 18:16)</a>:</h4>
<p>by contradiction</p>



<a name="221410606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410606">(Jan 02 2021 at 18:16)</a>:</h4>
<p>You can actually put any pattern other than a name or underscore in for <code>h</code> to complete the proof. I generally prefer to use <code>&lt;&gt;</code></p>



<a name="221410624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410624">(Jan 02 2021 at 18:17)</a>:</h4>
<p>hence <code>rintro (_|⟨_,⟨⟩⟩),</code></p>



<a name="221410627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410627">(Jan 02 2021 at 18:17)</a>:</h4>
<p>That would be a great entry for the "guess the theorem statement given the proof" competition</p>



<a name="221410636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221410636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221410636">(Jan 02 2021 at 18:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">_</span><span class="bp">|</span><span class="o">⟨</span><span class="n">_</span><span class="o">,⟨⟩⟩)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221412443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221412443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221412443">(Jan 02 2021 at 19:01)</a>:</h4>
<p>Fixed in <a href="https://github.com/leanprover-community/mathlib/issues/5576">#5576</a></p>



<a name="221412494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221412494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221412494">(Jan 02 2021 at 19:02)</a>:</h4>
<p>Thanks! I had run into this "<code>rcases?</code> not working" thing several times.</p>



<a name="221412521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221412521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221412521">(Jan 02 2021 at 19:03)</a>:</h4>
<p>There was a more basic problem with it than I thought, some variable was just not getting passed along as expected</p>



<a name="221412534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221412534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221412534">(Jan 02 2021 at 19:03)</a>:</h4>
<p>the stuff about dependent pattern matching is mostly a red herring since that doesn't come up in these examples</p>



<a name="221420803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221420803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221420803">(Jan 02 2021 at 22:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, do you plan to PR that <code>ordered_comm_monoid nat</code> instance?</p>



<a name="221438739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221438739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221438739">(Jan 03 2021 at 07:25)</a>:</h4>
<p>I planned on waiting for someone to tell me what I was doing wrong</p>



<a name="221438748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221438748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221438748">(Jan 03 2021 at 07:25)</a>:</h4>
<p>Because surely it's already there</p>



<a name="221439790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221439790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221439790">(Jan 03 2021 at 07:56)</a>:</h4>
<blockquote>
<p>Because surely it's already there</p>
</blockquote>
<p>This is how I always feel when I use Lean...</p>



<a name="221447494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221447494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221447494">(Jan 03 2021 at 11:49)</a>:</h4>
<blockquote>
<p>That's not what the version in mathlib master looks like.</p>
</blockquote>
<p>I could not get to the bottom of what is in <code>master</code> and what is not, but I removed the invocation to the lemma <code>irrational_of_ne_int_div_pos_nat</code>.  Below is the second proof, in case anyone is interested in some more golfing!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">irrational_of_is_liouville</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_liouville</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">irrational</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">cases</span> <span class="n">r</span> <span class="k">with</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h_b_pos</span> <span class="n">cop</span><span class="o">,</span>
  <span class="n">change</span> <span class="o">(</span><span class="n">is_liouville</span> <span class="o">(</span><span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">))</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">q1</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">a1</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">qR0</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="o">(</span><span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">q1</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">bR0</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="n">h_b_pos</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">b0</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">h_b_pos</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">div_sub_div</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">b0</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">qR0</span><span class="o">),</span> <span class="n">abs_div</span><span class="o">]</span> <span class="n">at</span> <span class="n">a0</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">lt_div_iff</span> <span class="o">(</span><span class="n">abs_pos.mpr</span> <span class="o">(</span><span class="n">mul_ne_zero</span> <span class="n">b0</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">qR0</span><span class="o">))),</span> <span class="n">zero_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">a0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">div_lt_div_iff</span> <span class="n">_</span> <span class="o">(</span><span class="n">pow_pos</span> <span class="n">qR0</span> <span class="n">_</span><span class="o">),</span> <span class="bp">@</span><span class="n">abs_of_pos</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_pos</span> <span class="n">bR0</span> <span class="n">qR0</span><span class="o">),</span> <span class="n">one_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">not_le.mpr</span> <span class="n">a1</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="o">(</span><span class="n">int.mul_lt_mul_pow_succ</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">a0</span><span class="o">)</span> <span class="n">q1</span><span class="o">))</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">abs_pos.mpr</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="o">(</span><span class="n">mul_pos</span> <span class="n">bR0</span> <span class="n">qR0</span><span class="o">))</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221447513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221447513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221447513">(Jan 03 2021 at 11:49)</a>:</h4>
<p>I would be curious to know how to avoid the <code>change</code>, or at least, making it more "discreet".  Ideally, I would not want to even see what happens between the <code>cases</code> and <code>change</code>.</p>



<a name="221447564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221447564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221447564">(Jan 03 2021 at 11:51)</a>:</h4>
<p>Ah, thanks Kevin!  (I believe that you were addressing to me in the other thread!)</p>



<a name="221447565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221447565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221447565">(Jan 03 2021 at 11:51)</a>:</h4>
<p>You can <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/real/irrational.lean">look on GitHub</a> to get a definitive answer as to what <code>master</code> looks like. Or just switch to <code>master</code> on the bottom left of VS code and then pull.</p>



<a name="221447568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221447568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221447568">(Jan 03 2021 at 11:51)</a>:</h4>
<p>I am now only using the very first lemma from <code>data.real.irrational</code>, which also appears in <code>master</code>!</p>



<a name="221460201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221460201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221460201">(Jan 03 2021 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221438748">said</a>:</p>
<blockquote>
<p>I planned on waiting for someone to tell me what I was doing wrong</p>
<p>Because surely it's already there</p>
</blockquote>
<p>I think the fact that a few of us weren't able to find it here is good enough motivation to open a PR. There are already too many lemmas that appear in Zulip and never make it to mathlib (not to mention all the ones in various <code>for_mathlib</code> folders in various repos...).</p>



<a name="221462516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221462516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221462516">(Jan 03 2021 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I won't get to this today now, feel free to PR.</p>



<a name="221794545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/221794545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#221794545">(Jan 06 2021 at 17:17)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/5645">#5645</a></p>



<a name="222122354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/222122354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#222122354">(Jan 08 2021 at 20:36)</a>:</h4>
<p>^ now merged</p>



<a name="224593213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224593213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224593213">(Jan 30 2021 at 16:31)</a>:</h4>
<p>Dear All,</p>
<p>I just pushed a newer version of PR <a href="https://github.com/leanprover-community/mathlib/issues/4301">#4301</a>.  Many lemmas in the file <code>analysis/transcendental/liouville_constant</code> could be moved to different files, but I am doubtful that they could be useful for other theorems.  What is the standard approach?  Should I still scatter them across mathlib?</p>
<p>Thanks!</p>



<a name="224602608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224602608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224602608">(Jan 30 2021 at 20:07)</a>:</h4>
<p>Eric suggested using a more "metric space" approach to the definition of <code>is_liouville</code>.  While working on this, I had also tried out a similar approach.  The statements are all relatively easy to prove with either definition.  I ended up going with the "classical" definition (see below).</p>
<p>If anyone is seriously thinking of formalizing some continued fractions stuff (à la Khinchin), they may have a serious preference for a specific one.  I personally do not mind much, since the definition is used very superficially in the Liouville story.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- classical</span>
<span class="kd">def</span> <span class="n">is_liouville</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
  <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">n</span>

<span class="c1">-- Eric's "ordered" suggestion</span>
<span class="kd">def</span> <span class="n">is_liouville</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
  <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">Ioo</span> <span class="mi">0</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>

<span class="c1">-- a "topological" definition</span>
<span class="kd">def</span> <span class="n">is_liouville</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">q</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">metric.ball</span> <span class="n">x</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="o">(</span><span class="n">q.2</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="224602677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224602677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224602677">(Jan 30 2021 at 20:08)</a>:</h4>
<p>I don't know much about continued fractions, but we have have a bunch about them in mathlib already.</p>



<a name="224603366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224603366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224603366">(Jan 30 2021 at 20:25)</a>:</h4>
<p>Ok, so then it does not matter much what definition we use!</p>
<p>In fact, might there already be a version of the <code>is_liouville</code> definition?</p>



<a name="224603603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224603603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224603603">(Jan 30 2021 at 20:31)</a>:</h4>
<blockquote>
<p>Ok, so then it does not matter much what definition we use!</p>
</blockquote>
<p>Of course this is the real answer. All three versions should be available and it shouldn't matter which is the definition</p>



<a name="224603649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224603649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224603649">(Jan 30 2021 at 20:32)</a>:</h4>
<p>that said, in the "classical" version it seems a little circumspect to say <code>0 &lt; abs (x - a / b)</code> instead of <code>x != a / b</code></p>



<a name="224605692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224605692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224605692">(Jan 30 2021 at 21:22)</a>:</h4>
<p>Ok, I nothing else, I will at least change <code>0 &lt; abs (x - a / b)</code> to <code>x != a / b</code>!  Not tonight, though!</p>



<a name="224627955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/224627955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#224627955">(Jan 31 2021 at 07:01)</a>:</h4>
<p>A quick update.</p>
<p>First, the definition of <code>is_liouville</code> is now</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_liouville</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
  <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">n</span>
</code></pre></div>
<p>Second, in the current usage, the definition spills out in three places:</p>
<ol>
<li>when proving that a Liouville number is not rational;</li>
<li>when proving that a Liouville number is transcendental (using 1);</li>
<li>when arguing that, for any natural <code>m</code> with <code>2 &lt; m</code>, the sum of the series</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∑'</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">i</span><span class="bp">!</span>
</code></pre></div>
<p>satisfies the definition.</p>
<p>Thus, any change in the definition only needs to be adapted in these three lemmas: this is a very minor change!</p>
<p>I will keep the definition with <code>≠</code> and <code>abs</code> (the one in this post), since it is the one that is already in the file.  If anyone has an even tenuous argument to prefer a different definition, let me know!</p>



<a name="225954541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/225954541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#225954541">(Feb 11 2021 at 07:00)</a>:</h4>
<p>One more step in the Liouville saga: I created PR <a href="https://github.com/leanprover-community/mathlib/issues/6158">#6158</a> that only introduces the definition of Liouville numbers and proves that they are irrational.</p>
<p>A proof of their transcendence is forth-coming, but this is a small PR, which hopefully can get merged!</p>



<a name="226148913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226148913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226148913">(Feb 12 2021 at 15:13)</a>:</h4>
<p>One more step: PR <a href="https://github.com/leanprover-community/mathlib/issues/6201">#6201</a>.</p>
<p>This PR contains three lemmas, two specific for Liouville and one about membership in an <code>Icc</code>.  The two lemmas are somewhat technical.  They lead directly to the proof of transcendence of Liouville numbers.  I left out the proof of transcendence to keep the PR short: as it is, it add 79 lines (including a few doc-strings).</p>
<p>In case it helps, below you can see the proof of transcendence, based on the results in the PR: I will create a PR with the <del>lemma</del> theorem below, once the version in the current PR stabilizes.</p>
<p>As usual, comments, suggestions, improvements and general chat are more than welcome!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">transcendental</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">liouville_x</span> <span class="o">:</span> <span class="n">liouville</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_transcendental</span> <span class="n">ℤ</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">f0</span><span class="o">,</span> <span class="n">ef0</span><span class="o">⟩,</span>
  <span class="n">replace</span> <span class="n">ef0</span> <span class="o">:</span> <span class="o">(</span><span class="n">f.map</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">))</span><span class="bp">.</span><span class="n">eval</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="o">{</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">aeval_def</span><span class="o">,</span> <span class="bp">←</span> <span class="n">eval_map</span><span class="o">]</span> <span class="n">at</span> <span class="n">ef0</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">exists_pos_real_of_irrational_root</span> <span class="n">liouville_x.irrational</span> <span class="n">f0</span> <span class="n">ef0</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">pow_unbounded_of_one_lt</span> <span class="n">A</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b1</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">a1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">liouville_x</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">f.nat_degree</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">b0</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">zero_lt_one.trans</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">int.cast_one</span><span class="o">,</span> <span class="n">exact</span> <span class="n">int.cast_lt.mpr</span> <span class="n">b1</span> <span class="o">}),</span>
  <span class="n">refine</span> <span class="n">lt_irrefl</span> <span class="o">((</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="bp">↑</span><span class="n">a</span> <span class="bp">/</span> <span class="bp">↑</span><span class="n">b</span><span class="o">))</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">lt_div_iff'</span> <span class="o">(</span><span class="n">pow_pos</span> <span class="n">b0</span> <span class="n">_</span><span class="o">),</span> <span class="n">pow_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">((</span><span class="n">_</span>  <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_le</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">lt_div_iff'</span> <span class="n">hA</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">lt_of_le_of_lt</span> <span class="n">_</span> <span class="n">a1</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">_</span> <span class="o">(</span><span class="n">mul_nonneg</span> <span class="o">(</span><span class="n">pow_nonneg</span> <span class="n">b0.le</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">abs_nonneg</span> <span class="n">_</span><span class="o">)),</span>
    <span class="n">refine</span> <span class="n">hn.le.trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">pow_le_pow_of_le_left</span> <span class="n">zero_le_two</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">int.cast_two.symm.le.trans</span> <span class="o">(</span><span class="n">int.cast_le.mpr</span> <span class="o">(</span><span class="n">int.add_one_le_iff.mpr</span> <span class="n">b1</span><span class="o">))</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">lift</span> <span class="n">b</span> <span class="n">to</span> <span class="n">ℕ</span> <span class="n">using</span> <span class="n">zero_le_one.trans</span> <span class="n">b1.le</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b.pred</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">nat.succ_pred_eq_of_pos</span> <span class="o">(</span><span class="n">zero_lt_one.trans</span> <span class="n">_</span><span class="o">),</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="o">(</span><span class="n">div_le_iff</span> <span class="n">hA</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">int.coe_nat_lt.mp</span> <span class="n">b1</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226152664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226152664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226152664">(Feb 12 2021 at 15:38)</a>:</h4>
<p>I have a general comment on the style: in a perfect world, Lean proofs should be as readable as proofs one would write in a math article (ok, for some papers that doesn't mean a lot :-). So, anything that can help to follow the stream of arguments is welcome, be it comments, or <code>obtain</code> statements instead of <code>rcases</code> (to announce what you are getting from the rcases), or additional <code>have</code> to show where you are going, or <code>suffices</code>, or whatever: it helps a lot to say what you are doing instead of applying a sequence of tactics to the main goal without every showing how it looks like currently.</p>
<p>(I don't think everyone here is on this readability line, but most people probably (hopefully? :-))</p>



<a name="226153458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226153458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226153458">(Feb 12 2021 at 15:43)</a>:</h4>
<p>My personal preference would be to add comments: I find that Lean seems to like very much tactics such as <code>refine</code> and <code>exact</code>, progressively less <code>rw</code>, <code>have</code>, <code>obtain</code>, <code>apply</code>, <code>convert</code>.</p>
<p>If you want, I can add comments just before the "important" steps, explaining what they achieve.  Would that be reasonable?</p>



<a name="226153952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226153952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226153952">(Feb 12 2021 at 15:47)</a>:</h4>
<p>Yes, that's perfectly reasonable. As in papers, people have different ways of writing, and that's normal!</p>



<a name="226154340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226154340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226154340">(Feb 12 2021 at 15:50)</a>:</h4>
<p>I totally agree with Sébastien and my experiments with verbose tactics for teaching make me think we could write <em>much</em> more readable tactic proofs, even without modifying existing tactics.</p>



<a name="226154705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226154705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226154705">(Feb 12 2021 at 15:53)</a>:</h4>
<p>Can any of the inequality manipulation be done with <code>calc</code> here? That's my reaction when seeing a lot of <code>.trans</code> terms.</p>



<a name="226155685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226155685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226155685">(Feb 12 2021 at 15:59)</a>:</h4>
<p>Would this style of comments be good?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_pos_real_of_irrational_root</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">irrational</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">f0</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">fa</span> <span class="o">:</span> <span class="n">eval</span> <span class="n">α</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">):</span>
  <span class="bp">∃</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">b.succ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-</span> <span class="o">(</span><span class="n">a</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b.succ</span><span class="o">)))</span> <span class="bp">*</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- fR is f viewed as a polynomial with ℝ coefficients.</span>
  <span class="n">set</span> <span class="n">fR</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">map</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
<span class="c1">-- fR is non-zero, since f is non-zero.</span>
  <span class="n">obtain</span> <span class="n">fR0</span> <span class="o">:</span> <span class="n">fR</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">fR0</span><span class="o">,</span> <span class="o">(</span><span class="n">map_injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">A</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">A</span><span class="o">))</span><span class="bp">.</span><span class="n">ne</span>
    <span class="n">f0</span> <span class="o">(</span><span class="n">fR0.trans</span> <span class="o">(</span><span class="n">polynomial.map_zero</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span>
<span class="c1">-- reformulating assumption fa: α is a root of fR.</span>
  <span class="k">have</span> <span class="n">ar</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">fR.roots.to_finset</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">finset.mem_coe.mpr</span> <span class="o">(</span><span class="n">multiset.mem_to_finset.mpr</span> <span class="o">((</span><span class="n">mem_roots</span> <span class="n">fR0</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">is_root.def.mpr</span> <span class="n">fa</span><span class="o">))),</span>
<span class="c1">-- Since the fR has finitely many roots, there is a closed interval centered at α such that α is</span>
<span class="c1">-- the only root of fR in the interval.</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ζ</span><span class="o">,</span> <span class="n">z0</span><span class="o">,</span> <span class="n">U</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">exists_closed_ball_inter_eq_singleton_of_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">discrete_of_t1_of_finite</span> <span class="n">_</span> <span class="n">ar</span><span class="o">,</span>
<span class="c1">-- Since fR is continuous, it is bounded on the interval above.</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">xm</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h_x_max_range</span><span class="o">,</span> <span class="n">hM</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">is_compact.exists_forall_ge</span> <span class="o">(</span><span class="bp">@</span><span class="n">compact_Icc</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-</span> <span class="n">ζ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="bp">+</span> <span class="n">ζ</span><span class="o">))</span>
    <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">sub_lt_self</span> <span class="n">α</span> <span class="n">z0</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span><span class="o">,</span> <span class="o">(</span><span class="n">lt_add_of_pos_right</span> <span class="n">α</span> <span class="n">z0</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span><span class="o">⟩</span>
    <span class="o">(</span><span class="n">continuous_abs.comp</span> <span class="n">fR.derivative.continuous_aeval</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_on</span><span class="o">,</span>
<span class="c1">-- Use the key lemma above: we are left to show that</span>
<span class="c1">-- 1: denominators are positive</span>
<span class="c1">-- 2: the polynomial fR is Lipschits at α</span>
<span class="c1">-- 3: the weird inequality of Liouville type with powers of the denominators.</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">exists_one_le_pow_mul_dist</span> <span class="n">ℤ</span> <span class="n">ℕ</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">fR.eval</span> <span class="n">y</span><span class="o">)</span> <span class="n">α</span> <span class="n">ζ</span>
    <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">fR.derivative.eval</span> <span class="n">xm</span><span class="o">))</span> <span class="n">_</span> <span class="n">z0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span> <span class="n">a</span> <span class="n">hq</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
<span class="c1">-- 1: the denominators are positive -- essentially by definition;</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">one_le_pow_of_one_le</span> <span class="o">((</span><span class="n">le_add_iff_nonneg_left</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">a.cast_nonneg</span><span class="o">)</span> <span class="n">_</span> <span class="o">},</span> <span class="c1">--simp</span>
<span class="c1">-- 2: the polynomial fR is Lipschits at α -- as it's derivative continuous;</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">closed_ball_Icc</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
<span class="c1">-- apply the Mean value theorem: the bound on the derivative comes from differentiability.</span>
    <span class="n">refine</span> <span class="n">convex.norm_image_sub_le_of_norm_deriv_le</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">fR.differentiable_at</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">fR.deriv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hM</span> <span class="n">_</span> <span class="n">h</span> <span class="o">})</span> <span class="o">(</span><span class="n">convex_Icc</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">hy</span> <span class="o">(</span><span class="n">mem_Icc_iff_abs_le.mp</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">mem_closed_ball_self</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="n">α</span> <span class="n">ζ</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">z0</span><span class="o">)</span> <span class="o">},</span>
<span class="c1">-- 3: weird, Liouville-like inequality.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">eval</span> <span class="n">α</span> <span class="n">fR</span> <span class="bp">-</span> <span class="n">eval</span> <span class="o">(</span><span class="n">z</span> <span class="bp">/</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">fR</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fa</span><span class="o">,</span> <span class="n">zero_sub</span><span class="o">,</span> <span class="n">abs_neg</span><span class="o">],</span>
<span class="c1">-- key observation: the right-hand side of the inequality is an *integer*.  Therefore,</span>
<span class="c1">-- if its absolute value is not at least one, then it vanishes.  Proceed by contradiction</span>
    <span class="n">refine</span> <span class="n">one_le_pow_mul_abs_eval_div</span> <span class="o">(</span><span class="n">int.coe_nat_succ_pos</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
<span class="c1">-- If the evaluation of the polynomial vanishes, then we found a root of fR that is rational.</span>
<span class="c1">-- We know that α is the only root of fR in our interval, and α is irrational: follow your nose.</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">irrational_iff_ne_rational</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">ha</span> <span class="n">z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">((</span><span class="n">mem_singleton_iff.mp</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">U</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">hq</span><span class="o">,</span> <span class="n">finset.mem_coe.mp</span> <span class="o">(</span><span class="n">multiset.mem_to_finset.mpr</span> <span class="n">_</span><span class="o">)⟩,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">mem_roots</span> <span class="n">fR0</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">is_root.def.mpr</span> <span class="n">hy</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226155742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226155742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226155742">(Feb 12 2021 at 15:59)</a>:</h4>
<p>If so, I can produce similar comments for other proofs.</p>



<a name="226157581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226157581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226157581">(Feb 12 2021 at 16:12)</a>:</h4>
<p>Unindenting the comments like that leads to weird code-folding in vs-code, so I'd be inclined to indent them to align with the code</p>



<a name="226157602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226157602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226157602">(Feb 12 2021 at 16:12)</a>:</h4>
<p>I think they should match indentation</p>



<a name="226161242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226161242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226161242">(Feb 12 2021 at 16:38)</a>:</h4>
<p>Comments indented above!</p>



<a name="226161835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226161835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226161835">(Feb 12 2021 at 16:43)</a>:</h4>
<p>Comments in <code>{}</code> should probably match the local indentation too</p>



<a name="226162053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226162053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226162053">(Feb 12 2021 at 16:44)</a>:</h4>
<p>I sometimes use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="c1">-- comment</span>
  <span class="n">first</span> <span class="n">line</span><span class="o">,</span>
  <span class="c1">-- comment</span>
  <span class="n">second</span> <span class="n">line</span> <span class="o">},</span>
</code></pre></div>
<p>for comments associated to the first line of a block</p>



<a name="226162137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226162137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226162137">(Feb 12 2021 at 16:45)</a>:</h4>
<p>I think</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- comment</span>
<span class="o">{</span> <span class="n">first</span> <span class="n">line</span><span class="o">,</span>
  <span class="bp">...</span>
</code></pre></div>
<p>is also fine but is better for describing the whole branch</p>



<a name="226163316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226163316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226163316">(Feb 12 2021 at 16:52)</a>:</h4>
<p>I think that, accidentally, the commenting above already matches these conventions.<br>
A comment of the form</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="c1">-- comment</span>
  <span class="o">{</span> <span class="n">tactics</span> <span class="o">}</span>
</code></pre></div>
<p>applies to the whole branch, otherwise it applies almost exactly to the following tactic.</p>



<a name="226163650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226163650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226163650">(Feb 12 2021 at 16:55)</a>:</h4>
<p>Is the consensus that adding these comments makes the PR better?  Should I systematically add similar comments to the longer proofs in the PR?</p>



<a name="226164212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226164212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226164212">(Feb 12 2021 at 16:59)</a>:</h4>
<p>Lipschits → Lipschitz, but now I can roughly follow the proof, so that's nice</p>



<a name="226164407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226164407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226164407">(Feb 12 2021 at 17:00)</a>:</h4>
<p>Great: thanks for the typo and the feedback!<br>
[Typo corrected.]</p>



<a name="226165209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226165209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226165209">(Feb 12 2021 at 17:05)</a>:</h4>
<p>I think that's great! One thing you could add in the <code>obtain</code>s is to give the type explicitly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ζ</span><span class="o">,</span> <span class="n">z0</span><span class="o">,</span> <span class="n">U</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">ζ</span><span class="o">,</span> <span class="bp">...</span>   <span class="o">:=</span>
    <span class="bp">@</span><span class="n">exists_closed_ball_inter_eq_singleton_of_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">discrete_of_t1_of_finite</span> <span class="n">_</span> <span class="n">ar</span><span class="o">,</span>
</code></pre></div>
<p>where the <code>...</code> should be filled with the type: then the reader knows exactly what <code>z0</code> and <code>U</code> are.</p>



<a name="226167966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226167966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226167966">(Feb 12 2021 at 17:23)</a>:</h4>
<p>Now with explicit Type assignments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_pos_real_of_irrational_root</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">irrational</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">f0</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">fa</span> <span class="o">:</span> <span class="n">eval</span> <span class="n">α</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">):</span>
  <span class="bp">∃</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">b.succ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-</span> <span class="o">(</span><span class="n">a</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b.succ</span><span class="o">)))</span> <span class="bp">*</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- fR is f viewed as a polynomial with ℝ coefficients.</span>
  <span class="n">set</span> <span class="n">fR</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">map</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
  <span class="c1">-- fR is non-zero, since f is non-zero.</span>
  <span class="n">obtain</span> <span class="n">fR0</span> <span class="o">:</span> <span class="n">fR</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">fR0</span><span class="o">,</span> <span class="o">(</span><span class="n">map_injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">A</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">A</span><span class="o">))</span><span class="bp">.</span><span class="n">ne</span>
    <span class="n">f0</span> <span class="o">(</span><span class="n">fR0.trans</span> <span class="o">(</span><span class="n">polynomial.map_zero</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span>
  <span class="c1">-- reformulating assumption fa: α is a root of fR.</span>
  <span class="k">have</span> <span class="n">ar</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">fR.roots.to_finset</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">finset.mem_coe.mpr</span> <span class="o">(</span><span class="n">multiset.mem_to_finset.mpr</span> <span class="o">((</span><span class="n">mem_roots</span> <span class="n">fR0</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">is_root.def.mpr</span> <span class="n">fa</span><span class="o">))),</span>
  <span class="c1">-- Since the fR has finitely many roots, there is a closed interval centered at α such that α is</span>
  <span class="c1">-- the only root of fR in the interval.</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ζ</span><span class="o">,</span> <span class="n">z0</span><span class="o">,</span> <span class="n">U</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">ζ</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">closed_ball</span> <span class="n">α</span> <span class="n">ζ</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">fR.roots.to_finset</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">exists_closed_ball_inter_eq_singleton_of_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">discrete_of_t1_of_finite</span> <span class="n">_</span> <span class="n">ar</span><span class="o">,</span>
  <span class="c1">-- Since fR is continuous, it is bounded on the interval above.</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">xm</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">hM</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">xm</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">xm</span> <span class="bp">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-</span> <span class="n">ζ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="bp">+</span> <span class="n">ζ</span><span class="o">)),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span>
    <span class="n">y</span> <span class="bp">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-</span> <span class="n">ζ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="bp">+</span> <span class="n">ζ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">abs</span> <span class="o">(</span><span class="n">eval</span> <span class="n">y</span> <span class="o">(</span><span class="n">derivative</span> <span class="n">fR</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="o">(</span><span class="n">eval</span> <span class="n">xm</span> <span class="o">(</span><span class="n">derivative</span> <span class="n">fR</span><span class="o">))</span> <span class="o">:=</span>
    <span class="n">is_compact.exists_forall_ge</span> <span class="o">(</span><span class="n">compact_Icc</span><span class="o">)</span>
    <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">sub_lt_self</span> <span class="n">α</span> <span class="n">z0</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span><span class="o">,</span> <span class="o">(</span><span class="n">lt_add_of_pos_right</span> <span class="n">α</span> <span class="n">z0</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span><span class="o">⟩</span>
    <span class="o">(</span><span class="n">continuous_abs.comp</span> <span class="n">fR.derivative.continuous_aeval</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_on</span><span class="o">,</span>
  <span class="c1">-- Use the key lemma `exists_one_le_pow_mul_dist`: we are left to show that</span>
  <span class="c1">-- 1: denominators are positive</span>
  <span class="c1">-- 2: the polynomial fR is Lipschitz at α</span>
  <span class="c1">-- 3: the weird inequality of Liouville type with powers of the denominators.</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">exists_one_le_pow_mul_dist</span> <span class="n">ℤ</span> <span class="n">ℕ</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">fR.eval</span> <span class="n">y</span><span class="o">)</span> <span class="n">α</span> <span class="n">ζ</span>
    <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">fR.derivative.eval</span> <span class="n">xm</span><span class="o">))</span> <span class="n">_</span> <span class="n">z0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span> <span class="n">a</span> <span class="n">hq</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="c1">-- 1: the denominators are positive -- essentially by definition;</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">one_le_pow_of_one_le</span> <span class="o">((</span><span class="n">le_add_iff_nonneg_left</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">a.cast_nonneg</span><span class="o">)</span> <span class="n">_</span> <span class="o">},</span>
  <span class="c1">-- 2: the polynomial fR is Lipschits at α -- as it's derivative continuous;</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">closed_ball_Icc</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="c1">-- apply the Mean value theorem: the bound on the derivative comes from differentiability.</span>
    <span class="n">refine</span> <span class="n">convex.norm_image_sub_le_of_norm_deriv_le</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">fR.differentiable_at</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">fR.deriv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hM</span> <span class="n">_</span> <span class="n">h</span> <span class="o">})</span> <span class="o">(</span><span class="n">convex_Icc</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">hy</span> <span class="o">(</span><span class="n">mem_Icc_iff_abs_le.mp</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">mem_closed_ball_self</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="n">α</span> <span class="n">ζ</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">z0</span><span class="o">)</span> <span class="o">},</span>
  <span class="c1">-- 3: weird, Liouville-like inequality.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">eval</span> <span class="n">α</span> <span class="n">fR</span> <span class="bp">-</span> <span class="n">eval</span> <span class="o">(</span><span class="n">z</span> <span class="bp">/</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">fR</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fa</span><span class="o">,</span> <span class="n">zero_sub</span><span class="o">,</span> <span class="n">abs_neg</span><span class="o">],</span>
    <span class="c1">-- key observation: the right-hand side of the inequality is an *integer*.  Therefore,</span>
    <span class="c1">-- if its absolute value is not at least one, then it vanishes.  Proceed by contradiction</span>
    <span class="n">refine</span> <span class="n">one_le_pow_mul_abs_eval_div</span> <span class="o">(</span><span class="n">int.coe_nat_succ_pos</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="c1">-- If the evaluation of the polynomial vanishes, then we found a root of fR that is rational.</span>
    <span class="c1">-- We know that α is the only root of fR in our interval, and α is irrational: follow your nose.</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">irrational_iff_ne_rational</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">ha</span> <span class="n">z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">((</span><span class="n">mem_singleton_iff.mp</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">U</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">hq</span><span class="o">,</span> <span class="n">finset.mem_coe.mp</span> <span class="o">(</span><span class="n">multiset.mem_to_finset.mpr</span> <span class="n">_</span><span class="o">)⟩,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">mem_roots</span> <span class="n">fR0</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">is_root.def.mpr</span> <span class="n">hy</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226168224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226168224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226168224">(Feb 12 2021 at 17:25)</a>:</h4>
<p>By the way, thank you all for your contributions!  I will annotate the PR and push the outcome.</p>



<a name="226172375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226172375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226172375">(Feb 12 2021 at 17:51)</a>:</h4>
<p>I pushed the annotated version of the PR.  I hope that this helps with the review and the further enjoyment of the proofs!</p>



<a name="226172581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226172581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226172581">(Feb 12 2021 at 17:52)</a>:</h4>
<p>Honestly, it is extra work to annotate, but it is also gratifying to explain stuff without having to justify it in too much details... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="226173312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226173312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226173312">(Feb 12 2021 at 17:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/226172581">said</a>:</p>
<blockquote>
<p>Honestly, it is extra work to annotate, but it is also gratifying to explain stuff without having to justify it in too much details... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
</blockquote>
<p>I never miss an opportunity to emphasize I see this as part of our great goals: I don't want formalized mathematics to <em>replace</em> sloppy explanations, I want them to allow me to write even sloppier and nicer to read explanations without fear.</p>



<a name="226173524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226173524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226173524">(Feb 12 2021 at 17:58)</a>:</h4>
<p>Just to say that this is exactly how I write the proofs I show the undergraduates, see e.g. <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/cfce84efd51a5f34fd13b5aaf58250845d1d33f3/src/week_4/solutions/Part_C_topology.lean#L144-L291">yesterday's lecture</a> on topology done the old-fashioned way.</p>



<a name="226173907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226173907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226173907">(Feb 12 2021 at 18:01)</a>:</h4>
<p>Ah, thanks Kevin: I will take inspiration!</p>



<a name="226174076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226174076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226174076">(Feb 12 2021 at 18:02)</a>:</h4>
<p>To be quite honest I think that this is the way to write formalised mathematics. The only reason I don't write it like this in mathlib is that I just copy how other people write it, and nobody wrote it like this in 2018. I think it's a great idea to have proofs like this in mathlib, and if people aren't going to object this is great news.</p>



<a name="226174304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226174304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226174304">(Feb 12 2021 at 18:03)</a>:</h4>
<p>Mathlib in 2017 contained a very large number of very short term mode proofs and far fewer longer tactic mode proofs, because of the nature of what was there (we still had 2000+ lines of data.multiset.basic but we didn't have e.g. the complex numbers). But now the entire nature of the library has changed so it's not unreasonable to imagine that the proof style can change too.</p>



<a name="226174672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226174672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226174672">(Feb 12 2021 at 18:06)</a>:</h4>
<p>I can sympathize with the fact that a one-line term-mode proof of a conclusion that is essentially equivalent to the hypothesis may not require a commented proof.  However, I do agree with you Kevin: following an informal proof along a formalized one is very useful, at least to me!</p>



<a name="226174696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226174696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226174696">(Feb 12 2021 at 18:06)</a>:</h4>
<p>I think that as soon as the proofs have some math content it is a very good idea to comment them. (I should do this more.) But of course all the silly boring simp-lemmas should be golfed into oblivion. They are just there because the API needs them, not to enlighten the reader.</p>



<a name="226177820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%235361%20Liouville/near/226177820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.235361.20Liouville.html#226177820">(Feb 12 2021 at 18:33)</a>:</h4>
<p>For those who cannot get enough of annotated Liouville proofs, I also PRed a proof that a Liouville number is transcendental: <a href="https://github.com/leanprover-community/mathlib/issues/6204">#6204</a>!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
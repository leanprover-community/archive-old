---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html">#3387: smooth functions on manifolds</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="203723716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203723716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203723716">(Jul 13 2020 at 14:44)</a>:</h4>
<p>I have updated the PR on smooth functions between manifolds (rather, I have closed the first one and opened a second one). I have a problem, since it is way too big (+1646, -85) but I would really love to have this before Friday for the manifold session. (Or maybe I could do the session from the branch if needed).</p>



<a name="203735549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203735549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203735549">(Jul 13 2020 at 16:15)</a>:</h4>
<p>I will look at this PR bit by bit, but it will need a look-through by more experienced people, too.  First comment:  this new tactic, <code>mfld_set_eq_tac</code>, is wonderful!  A few suggestions for it:</p>



<a name="203735595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203735595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203735595">(Jul 13 2020 at 16:15)</a>:</h4>
<p>(1) Should it be in <code>topology.local_homeomorph</code>rather than in <code>geometry.manifold.charted_space</code>?  There might already be proofs in that file that can be carried out by the tactic.</p>



<a name="203735801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203735801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203735801">(Jul 13 2020 at 16:17)</a>:</h4>
<p>(2) Here is something it can do with one <code>rw</code> hint; would it make sense to add that lemma to <code>mfld_simps</code>? </p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">=</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">image_inter_source_eq</span><span class="o">,</span>
  <span class="n">mfld_set_eq_tac</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203736022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203736022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203736022">(Jul 13 2020 at 16:19)</a>:</h4>
<p>(3) Would it make sense to have a second tactic for proving that a set is a subset of another set?  I know zero about tactic-writing but just modified your tactic to do this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">)</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">mfld_set_subset_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="k">assume</span> <span class="n">my_y</span> <span class="n">h_my_y</span><span class="o">,</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">h_my_y</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">h_my_y</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="o">]</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="err">⊆</span> <span class="n">e</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">e</span><span class="bp">.</span><span class="n">target</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">mfld_set_subset_tac</span>
</code></pre></div>



<a name="203738718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203738718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203738718">(Jul 13 2020 at 16:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203736022">said</a>:</p>
<blockquote>
<p>(3) Would it make sense to have a second tactic for proving that a set is a subset of another set? </p>
</blockquote>
<p>It's funny because at some point I wanted to do exactly this, with the exact code you posted. But then I thought it would be even better to have one single tactic, that would fire one or the other depending on the goal (inclusion or equality). I think this is essentially trivial for someone who knows a little bit of metaprogramming, which is not my case, so I uploaded the PR like that because it's already late for Friday. I'll have a look tonight.</p>



<a name="203738793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203738793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203738793">(Jul 13 2020 at 16:45)</a>:</h4>
<p>Or maybe one of <span class="user-mention" data-user-id="110596">@Rob Lewis</span> 's newly-minted tacticians can do this :)</p>



<a name="203739064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203739064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203739064">(Jul 13 2020 at 16:48)</a>:</h4>
<p>I didn't look at this PR, but my guess is you can do it with "get the target expression" and "pattern match on expressions," both of which should be covered by video 5!</p>



<a name="203739085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203739085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203739085">(Jul 13 2020 at 16:48)</a>:</h4>
<p>Here is the context: depending on the current goal, I want to run the code block</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">ext</span> <span class="n">my_y</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="o">{</span> <span class="k">assume</span> <span class="n">h_my_y</span><span class="o">,</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">h_my_y</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">h_my_y</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="o">}</span>
</code></pre></div>


<p>if the goal is an equality,</p>
<div class="codehilite"><pre><span></span><code>  <span class="k">assume</span> <span class="n">my_y</span> <span class="n">h_my_y</span><span class="o">,</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">h_my_y</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">h_my_y</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span>
</code></pre></div>


<p>if the goal is an inclusion, and fail otherwise.</p>
<p>If you have followed Rob's tutorial, this is yet another exercise for you :-)</p>



<a name="203740383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203740383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203740383">(Jul 13 2020 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203735801">said</a>:</p>
<blockquote>
<p>(2) Here is something it can do with one <code>rw</code> hint; would it make sense to add that lemma to <code>mfld_simps</code>? </p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">=</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">image_inter_source_eq</span><span class="o">,</span>
  <span class="n">mfld_set_eq_tac</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


</blockquote>
<p>The rule of thumb is: images are bad for automation (they involve an existential quantifier, so Lean would have to make some choice), while preimages are good. One could add a few lemmas to normalize images in <code>mfld_simps</code>, but this would be very brittle as the set should be in the precise form where the lemma would apply. For instance, if you add <code>local_homeomorph.image_inter_source_eq</code> to the simp set, then <code>mfld_set_eq_tac</code> succeeds to prove the statement you have given, but it fails to prove <code> e.symm.source ∩ e '' (e.source ∩ s) = e.symm.source ∩ e.symm ⁻¹' s</code>. So, an even better strategy is to never ever use direct images. I try to follow this rule in all the manifold files.</p>



<a name="203740674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203740674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203740674">(Jul 13 2020 at 17:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203739064">said</a>:</p>
<blockquote>
<p>I didn't look at this PR, but my guess is you can do it with "get the target expression" and "pattern match on expressions," both of which should be covered by video 5!</p>
</blockquote>
<p>Thanks Rob!</p>



<a name="203740864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203740864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203740864">(Jul 13 2020 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203735595">said</a>:</p>
<blockquote>
<p>(1) Should it be in <code>topology.local_homeomorph</code>rather than in <code>geometry.manifold.charted_space</code>?  There might already be proofs in that file that can be carried out by the tactic.</p>
</blockquote>
<p>Good idea. I'll check.</p>



<a name="203740972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203740972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203740972">(Jul 13 2020 at 17:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203740383">said</a>:</p>
<blockquote>
<p>The rule of thumb is: images are bad for automation (they involve an existential quantifier, so Lean would have to make some choice), while preimages are good. One could add a few lemmas to normalize images in <code>mfld_simps</code>, but this would be very brittle as the set should be in the precise form where the lemma would apply. For instance, if you add <code>local_homeomorph.image_inter_source_eq</code> to the simp set, then <code>mfld_set_eq_tac</code> succeeds to prove the statement you have given, but it fails to prove <code> e.symm.source ∩ e '' (e.source ∩ s) = e.symm.source ∩ e.symm ⁻¹' s</code>. So, an even better strategy is to never ever use direct images. I try to follow this rule in all the manifold files.</p>
</blockquote>
<p>Thanks, this is very instructive!</p>



<a name="203741477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203741477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203741477">(Jul 13 2020 at 17:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203740383">said</a>:</p>
<blockquote>
<p>So, an even better strategy is to never ever use direct images. I try to follow this rule in all the manifold files.</p>
</blockquote>
<p>Maybe the linter could enforce this :).  It's overkill right now, when you are the author of 99% of the manifold material, but hopefully that will not always be the case.</p>



<a name="203742971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203742971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203742971">(Jul 13 2020 at 17:19)</a>:</h4>
<p>I don't think I like the linter idea, everyone should be free to make his own mistakes :-)</p>



<a name="203744647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203744647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203744647">(Jul 13 2020 at 17:32)</a>:</h4>
<p>More seriously, there are uses you cannot avoid, for instance if you want to say "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(A)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span> is closed". What should be really avoided is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f(A) \subset  B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>



<a name="203744694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203744694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203744694">(Jul 13 2020 at 17:32)</a>:</h4>
<p>since it is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \subset f^{-1}(B)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> which is much better behaved.</p>



<a name="203745597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203745597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203745597">(Jul 13 2020 at 17:40)</a>:</h4>
<p>In manifolds, when you are composing with an equiv (or a local equiv), you can use equivalently <code>e '' A</code> or <code>e.symm ⁻¹' A</code>. The second one should essentially always be favored.</p>



<a name="203745860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203745860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203745860">(Jul 13 2020 at 17:42)</a>:</h4>
<p>does this discussion imply that it's useful to add <code>image_subset_iff</code> to the simp set in this context? (that's this theorem, which already goes in the right direction)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">image_subset_iff</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span> <span class="err">⊆</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">⊆</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">t</span>
</code></pre></div>



<a name="203747748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203747748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203747748">(Jul 13 2020 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203740864">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203735595">said</a>:</p>
<blockquote>
<p>(1) Should it be in <code>topology.local_homeomorph</code>rather than in <code>geometry.manifold.charted_space</code>?  There might already be proofs in that file that can be carried out by the tactic.</p>
</blockquote>
<p>Good idea. I'll check.</p>
</blockquote>
<p>Or even in <code>data.equiv.local_equiv</code>, now that I think about it.</p>



<a name="203751071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203751071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203751071">(Jul 13 2020 at 18:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203745860">said</a>:</p>
<blockquote>
<p>does this discussion imply that it's useful to add <code>image_subset_iff</code> to the simp set in this context?</p>
</blockquote>
<p>I would even add it globally to the simp set.</p>



<a name="203764228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203764228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203764228">(Jul 13 2020 at 20:06)</a>:</h4>
<p>I went for</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">- A very basic tactic to show that sets showing up in manifolds coincide or are included in</span>
<span class="cm">one another. -/</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">mfld_set_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">goal</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">target</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">goal</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">e₁</span> <span class="bp">=</span> <span class="err">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
      <span class="bp">`</span><span class="o">[</span><span class="n">ext</span> <span class="n">my_y</span><span class="o">,</span>
        <span class="n">split</span><span class="bp">;</span>
        <span class="o">{</span> <span class="k">assume</span> <span class="n">h_my_y</span><span class="o">,</span>
          <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">h_my_y</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">h_my_y</span> <span class="o">},</span>
          <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="o">}]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">e₁</span> <span class="err">⊆</span> <span class="err">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
      <span class="bp">`</span><span class="o">[</span><span class="k">assume</span> <span class="n">my_y</span> <span class="n">h_my_y</span><span class="o">,</span>
        <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">h_my_y</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">h_my_y</span> <span class="o">},</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">fail</span> <span class="s2">&quot;goal should be an equality or an inclusion&quot;</span>
  <span class="kn">end</span>
</code></pre></div>


<p>Comments welcome if I did something stupid.</p>



<a name="203764981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203764981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203764981">(Jul 13 2020 at 20:13)</a>:</h4>
<p>Pretty much exactly what I had in mind!</p>



<a name="203767486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203767486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203767486">(Jul 13 2020 at 20:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> , I have a couple of questions about your file abstracting properties of functions between charted-spaces-with-groupoids which are locally invariant.</p>



<a name="203767663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203767663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203767663">(Jul 13 2020 at 20:36)</a>:</h4>
<p>(1) did you make this up yourself? :)  It's not in Kobayashi-Nomizu as far as I can tell.  But if there is a reference, it would be nice to include it.</p>



<a name="203767946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203767946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203767946">(Jul 13 2020 at 20:38)</a>:</h4>
<p>(2) is there an obvious relationship of this material to other theories of locally invariant objects?  I am not really a sheaf-y person, but is it true that one can also characterize (smooth, continuous) maps between manifolds as being morphisms of ringed spaces for the (smooth, continuous) structure sheaf?</p>



<a name="203768170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203768170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203768170">(Jul 13 2020 at 20:40)</a>:</h4>
<p>For ordinary manifold, yes. But it seems that you run into trouble for things like manifolds with corners.</p>



<a name="203768308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203768308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203768308">(Jul 13 2020 at 20:41)</a>:</h4>
<p>I can answer question 1 since I've asked Sébastien many similar questions in the past: he made it up.</p>



<a name="203768391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203768391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203768391">(Jul 13 2020 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203767663">said</a>:</p>
<blockquote>
<p>(1) did you make this up yourself? :)  It's not in Kobayashi-Nomizu as far as I can tell.  But if there is a reference, it would be nice to include it.</p>
</blockquote>
<p>I just made up this precisely for my needs, so no reference, sorry. These things are in general so obvious and intuitive that books wouldn't bother giving the details.</p>



<a name="203768439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203768439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203768439">(Jul 13 2020 at 20:42)</a>:</h4>
<p>For example, if my half-baked check is correct, it should be true that a <code>G</code>-invariant class of functions from <code>H</code> to a topological ring <code>R</code> (with <code>G</code> a closed-under-restriction groupoid for <code>H</code> and <code>R</code> equipped with the trivial groupoid) induces a sheaf on any space <code>M</code> modelled on <code>H</code>.</p>



<a name="203768564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203768564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203768564">(Jul 13 2020 at 20:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203767946">said</a>:</p>
<blockquote>
<p>(2) is there an obvious relationship of this material to other theories of locally invariant objects?  I am not really a sheaf-y person, but is it true that one can also characterize (smooth, continuous) maps between manifolds as being morphisms of ringed spaces for the (smooth, continuous) structure sheaf?</p>
</blockquote>
<p>Sometimes the sheafy point of view works, sometimes it doesn't, depending on the context, if I  recall correctly. For instance, it works well for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi mathvariant="normal">∞</mi></msup></mrow><annotation encoding="application/x-tex">C^\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span></span></span></span></span></span></span></span> functions, but not so well in finite smoothness. In general, I don't think it really buys anything interesting.</p>



<a name="203768896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203768896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203768896">(Jul 13 2020 at 20:46)</a>:</h4>
<p>I am a differential geometer, so I am certainly not going to push the sheaf POV. <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span>  But I think at some point (not in this PR) it would be nice to have files characterizing equivalences between different POVs, eg this<br>
<span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203768439">said</a>:</p>
<blockquote>
<p>For example, if my half-baked check is correct, it should be true that a <code>G</code>-invariant class of functions from <code>H</code> to a topological ring <code>R</code> (with <code>G</code> a closed-under-restriction groupoid for <code>H</code> and <code>R</code> equipped with the trivial groupoid) induces a sheaf on any space <code>M</code> modelled on <code>H</code>.</p>
</blockquote>
<p>if it is true.</p>



<a name="203769133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203769133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203769133">(Jul 13 2020 at 20:48)</a>:</h4>
<p>As stated it's false, but is has a true version.</p>



<a name="203769226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203769226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203769226">(Jul 13 2020 at 20:49)</a>:</h4>
<p>And one more question, inspired by the sheaf POV:  probably there is a theory about the composition of a groupoid-invariant class of partial functions <code>H → H'</code> and another such class <code>H' → H''</code> ?</p>



<a name="203769574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203769574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203769574">(Jul 13 2020 at 20:51)</a>:</h4>
<p>Yes, I'm pretty sure one can do this in the general version, and deduce like this that the composition of smooth functions is smooth.</p>



<a name="203769895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203769895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203769895">(Jul 13 2020 at 20:54)</a>:</h4>
<p>I just pushed a new version of the PR with the generalized <code>mfld_set_tac</code> tactic, and more applications (starting in <code>local_equiv</code> and <code>local_homeomorph</code>). In <code>local_equiv</code>, the proof of</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">trans_source&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span> <span class="bp">=</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">target</span> <span class="err">∩</span> <span class="n">e&#39;</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">symmetry</span><span class="o">,</span> <span class="k">calc</span>
    <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">target</span> <span class="err">∩</span> <span class="n">e&#39;</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">target</span><span class="o">))</span> <span class="err">∩</span> <span class="n">e</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">e&#39;</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:</span>
      <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">preimage_inter</span><span class="o">,</span> <span class="n">inter_assoc</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="n">e</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">e&#39;</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:</span>
      <span class="k">by</span> <span class="o">{</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">apply</span> <span class="n">inter_eq_self_of_subset_left</span> <span class="n">e</span><span class="bp">.</span><span class="n">source_subset_preimage_target</span> <span class="o">}</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span> <span class="o">:</span> <span class="n">rfl</span>
<span class="kn">end</span>
</code></pre></div>


<p>becomes <code>by mfld_set_tac</code>.</p>



<a name="203769940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203769940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203769940">(Jul 13 2020 at 20:54)</a>:</h4>
<p>Great!</p>



<a name="203770529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203770529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203770529">(Jul 13 2020 at 20:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203769226">said</a>:</p>
<blockquote>
<p>And one more question, inspired by the sheaf POV:  probably there is a theory about the composition of a groupoid-invariant class of partial functions <code>H → H'</code> and another such class <code>H' → H''</code> ?</p>
</blockquote>
<p>One of the motivations for this would be that (I think) you can also go backwards:  given a definition of (say) smooth partial-maps from <code>H</code> to <code>ℝ</code> and from <code>H'</code> to <code>ℝ</code>, one can define smooth partial-maps from <code>H to H'</code> as those whose composition with smooth maps <code>H' → ℝ</code> is smooth as a map <code>H → ℝ</code>.  (I think.)</p>



<a name="203770820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203770820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203770820">(Jul 13 2020 at 21:01)</a>:</h4>
<p>And this is probably the sheaf point of view.</p>



<a name="203795549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203795549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203795549">(Jul 14 2020 at 03:27)</a>:</h4>
<p>Okay, <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> , I have another proposed tactic-writing exercise :). Maybe your <code>mfld_set_tac</code>, which currently solves goals of the form <code>s = t</code> and <code>s ⊆ t</code> (for sets), could also solve goals of the form <code>x ∈ s</code>?  With the caveat (again) that I know zero about tactic-writing, I think the algorithm could be a slight twist on what you <a href="#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203764228">already wrote</a>:  <code>mfld_simps</code> all hypotheses of the form <code>x ∈ ...</code>, then <code>mfld_simps</code> the goal.  Here are two examples from <code>geometry.manifold.charted_space</code> that such a tactic could solve:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">manifold</span><span class="bp">.</span><span class="n">charted_space</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">local_homeomorph</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M&#39;&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M&#39;&#39;</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">charted_space</span> <span class="n">H</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">charted_space</span> <span class="n">H</span> <span class="n">M&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">charted_space</span> <span class="n">H</span> <span class="n">M&#39;&#39;</span><span class="o">]</span>

<span class="c1">-- adapted from structure_groupoid.compatible_of_mem_maximal_atlas</span>
<span class="kn">example</span>
  <span class="o">{</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">chart_at</span> <span class="n">H</span> <span class="o">((</span><span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="n">x</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">target</span> <span class="err">∩</span> <span class="err">⇑</span><span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">f</span><span class="bp">.</span><span class="n">source</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">hx</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">hx</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">-- adapted from structomorph.trans</span>
<span class="kn">example</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">homeomorph</span> <span class="n">M</span> <span class="n">M&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e&#39;</span> <span class="o">:</span> <span class="n">homeomorph</span> <span class="n">M&#39;</span> <span class="n">M&#39;&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M&#39;&#39;</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">M&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf₁</span> <span class="o">:</span> <span class="n">f₁</span> <span class="bp">=</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_local_homeomorph</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M&#39;</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">((</span><span class="n">c</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">to_local_homeomorph</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span>
         <span class="n">c&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
  <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">M&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">c</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">f₁</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">chart_at</span> <span class="n">H</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hg₂</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="o">(</span><span class="n">chart_at</span> <span class="n">H</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="n">c</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">f₁</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span> <span class="err">∩</span> <span class="o">(</span><span class="n">c</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">f₁</span><span class="o">)</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">g</span><span class="bp">.</span><span class="n">source</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">hx</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">hx</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203795600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203795600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203795600">(Jul 14 2020 at 03:28)</a>:</h4>
<p>This is not an exercise that I am proposing for the current PR!  But I would be curious to know whether you think it is a good idea.</p>



<a name="203796587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203796587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203796587">(Jul 14 2020 at 03:56)</a>:</h4>
<p>Here is a more subtle test case, by the way:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">}</span>
  <span class="o">{</span><span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">}</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hef</span> <span class="o">:</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e&#39;</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hex</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">source</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">hef</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">hef</span><span class="o">,</span> <span class="bp">-</span><span class="n">hx</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"> (note that the following is not strong enough):</span>
<span class="cm">begin</span>
<span class="cm">  simp only [*, -hx] with mfld_simps at hx,</span>
<span class="cm">  simp only [*] with mfld_simps,</span>
<span class="cm">end -/</span>
</code></pre></div>



<a name="203798630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203798630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203798630">(Jul 14 2020 at 04:50)</a>:</h4>
<p>I think we should see to what extent these new tactics can be integrated into <code>tidy</code>...</p>



<a name="203800762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203800762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203800762">(Jul 14 2020 at 05:46)</a>:</h4>
<p>Anything that "fails fast" when its not relevant (e.g., because it does some pattern matching on the goal) is a good candidate for inclusion in <code>tidy</code>. The other requirement is that it's "conservative" --- i.e. as long as "breaking things into pieces" doesn't count as a bad idea, it never goes down a bad track that a human would know to avoid.</p>



<a name="203880497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203880497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203880497">(Jul 14 2020 at 20:03)</a>:</h4>
<p>There would be the possibility to merge the PR now, and review it properly afterwards. I promiss I would handle any reviewer's comment properly in this case. But it breaks all mathlib rules, so if you don't like it please don't hesitate to say it here and I will try to base Friday's talk on the branch instead!</p>



<a name="203885536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203885536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203885536">(Jul 14 2020 at 20:43)</a>:</h4>
<p>The problem with basing it on a branch is that we're asking a lot from our beginner audience who might not know git and probably have enough trouble with lean already</p>



<a name="203885677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203885677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203885677">(Jul 14 2020 at 20:44)</a>:</h4>
<p>Oh wait, can you just point the toml to the right commit??</p>



<a name="203885731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203885731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203885731">(Jul 14 2020 at 20:45)</a>:</h4>
<p>So all they have to do is git pull and then leanproject get-m?</p>



<a name="203918169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203918169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203918169">(Jul 15 2020 at 05:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> , I have been experimenting with the <code>local_invariant_prop</code> definition.  I decided to prove that being a local structomorphism was a groupoid-invariant property.  With my first definition of local structomorphism,</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_local_structomorph_within_at&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">),</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">eq_on</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>
</code></pre></div>


<p>I ran into difficulties showing that it satisfies the <code>congr</code> field of <code>local_invariant_prop</code>.  I then modified the definition to</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_local_structomorph_within_at</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">interior</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">),</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">eq_on</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>
</code></pre></div>


<p>and everything worked.  Is this the desired behaviour of <code>local_invariant_prop</code>?  (I am not used to thinking about groupoid-invariant properties <em>relative to a subset</em>).</p>



<a name="203919611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203919611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203919611">(Jul 15 2020 at 06:04)</a>:</h4>
<p>(I should have specified that I assumed the groupoid <code>G</code> was <code>closed_under_restriction</code>.)</p>



<a name="203923524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203923524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203923524">(Jul 15 2020 at 07:26)</a>:</h4>
<p>I would change the definition to </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_local_structomorph_within_at&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">),</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">eq_on</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>
</code></pre></div>


<p>Indeed, a property within a set should only speak of the behavior of the function within this set.</p>



<a name="203923593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/203923593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#203923593">(Jul 15 2020 at 07:27)</a>:</h4>
<p>Or maybe even</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_local_structomorph_within_at&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">),</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">eq_on</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>
</code></pre></div>



<a name="204014463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/204014463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#204014463">(Jul 15 2020 at 21:18)</a>:</h4>
<p>I ran into difficulties using your second definition.  (I didn't try the first one yet.). Suppose I want to prove the <code>left_invariance</code> property.  I am given <code>f, x, s</code>, and an element <code>e</code> of <code>G</code>, defined on a neighbourhood of <code>x</code>, which agrees on <code>s ∩ e.source</code> with <code>f</code>; also an element <code>e'</code> of <code>G</code>, whose source contains <code>f x</code> and <code>f '' s</code>. I want an element <code>e''</code> of <code>G</code>, defined on a neighbourhood of <code>x</code>, which agrees on  <code>s ∩ e''.source</code> with <code>f</code>.</p>
<p>I could take <code>e''</code> to be <code>e.trans e'</code>, but for this to work, I need that <code>e x ∈ e'.source</code>, and the only way I could see to get this is if <code>e x = f x</code>, which is only guaranteed if <code>x ∈ s</code>.</p>
<p>Alternatively, if <code>x</code> is not in the closure of <code>s</code>, I could take <code>e''</code> to be the restriction of the identity to a neighbourhood of <code>x</code> not intersecting <code>s</code>.  (I am using the <code>closed_under_restriction</code> property here, together with a separation axiom.)</p>
<p>But what if <code>x</code> is in <code>(closure s) \ s</code>?</p>



<a name="204015526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/204015526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#204015526">(Jul 15 2020 at 21:27)</a>:</h4>
<p>The same argument in Lean code, in case it's easier to follow:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">manifold</span><span class="bp">.</span><span class="n">local_invariant_properties</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">local_homeomorph</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">structure_groupoid</span> <span class="n">H</span><span class="o">)</span> <span class="o">[</span><span class="n">hclosed</span> <span class="o">:</span> <span class="n">closed_under_restriction</span> <span class="n">G</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">structure_groupoid</span>


<span class="n">def</span> <span class="n">is_local_structomorph_within_at</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">),</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">eq_on</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>

<span class="n">include</span> <span class="n">hclosed</span>
<span class="c">/-</span><span class="cm"> Let us try to prove the `left_invariance` property. -/</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">}</span> <span class="o">{</span><span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">}</span>
    <span class="o">(</span><span class="n">he&#39;G</span> <span class="o">:</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">G</span><span class="o">)</span>
    <span class="o">(</span><span class="n">he&#39;</span> <span class="o">:</span> <span class="n">s</span> <span class="err">⊆</span> <span class="n">f</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">e&#39;</span><span class="bp">.</span><span class="n">to_local_equiv</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hfx</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e&#39;</span><span class="bp">.</span><span class="n">to_local_equiv</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">is_local_structomorph_within_at</span> <span class="n">G</span> <span class="n">f</span> <span class="n">s</span> <span class="n">x</span> <span class="bp">→</span>
    <span class="n">is_local_structomorph_within_at</span> <span class="n">G</span> <span class="o">(</span><span class="n">e&#39;</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">s</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">is_local_structomorph_within_at</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">heG</span><span class="o">,</span> <span class="n">hef</span><span class="o">,</span> <span class="n">hex</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- a proof that works if  `x ∈ s`</span>
    <span class="n">use</span> <span class="n">e</span><span class="bp">.</span><span class="n">trans</span> <span class="n">e&#39;</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">G</span><span class="bp">.</span><span class="n">trans</span> <span class="n">heG</span> <span class="n">he&#39;G</span> <span class="o">},</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">unfold</span> <span class="n">eq_on</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">function</span><span class="bp">.</span><span class="n">comp_app</span><span class="o">,</span> <span class="bp">@</span><span class="n">hef</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">hy</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">hy</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span><span class="o">],</span>
      <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="k">with</span> <span class="n">mfld_simps</span><span class="o">,</span>
      <span class="n">unfold</span> <span class="n">eq_on</span> <span class="n">at</span> <span class="n">hef</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hfx</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">hef</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hex</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- a proof that works if `x` has a neighbourhood not intersecting `s`</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">t</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">s</span> <span class="err">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">,</span>
      <span class="n">sorry</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">this</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hxt</span><span class="o">,</span> <span class="n">hst</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">of_set</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">hp</span> <span class="o">:=</span> <span class="n">hclosed</span><span class="bp">.</span><span class="n">closed_under_restriction</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hle</span> <span class="o">:</span> <span class="n">id_restr_groupoid</span> <span class="bp">≤</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="n">closed_under_restriction_iff_id_le</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="k">by</span> <span class="n">assumption</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">structure_groupoid</span><span class="bp">.</span><span class="n">le_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hle</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">id_restr_groupoid_mem</span> <span class="n">ht</span> <span class="o">},</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hst</span><span class="o">],</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span> <span class="n">contradiction</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hxt</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204019352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/204019352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#204019352">(Jul 15 2020 at 22:10)</a>:</h4>
<p>On the other hand, your first definition works!  </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_local_structomorph_within_at&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">H</span> <span class="n">H</span><span class="o">),</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">eq_on</span> <span class="n">f</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span>
</code></pre></div>


<p>I can indeed prove that it is invariant under the groupoid.  Thanks for showing me how to get rid of the weird <code>interior s</code> in my definition.</p>



<a name="204019847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%233387%3A%20smooth%20functions%20on%20manifolds/near/204019847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds.html#204019847">(Jul 15 2020 at 22:17)</a>:</h4>
<p>So let me go back to why I was originally curious about this.  With both of the working definitions (my second one and your first one), I had to use the <code>closed_under_restriction</code> property of the groupoid in order to prove the definition was groupoid-invariant.  (For your definition it was in the <code>is_local</code> step.)  Is that what you would expect?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
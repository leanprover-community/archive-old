---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html">#13979 arbitrary proof terms in `linear_combination`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281367468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281367468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281367468">(May 05 2022 at 22:26)</a>:</h4>
<p>This PR adds a feature to <code>linear_combination</code> but also changes the syntax slightly: in the case where  no coefficient is provided and it defaults to 1, you now need to surround the argument in parentheses. (<code>linear_combination (h1) (h2)</code>). I think this is acceptable and <code>linear_combination</code> isn't heavily used right now, but wanted to check if anyone objects to the change!</p>



<a name="281367956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281367956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281367956">(May 05 2022 at 22:33)</a>:</h4>
<p>How ridiculous and/or viable would it be to change the syntax dramatically to something like <code>linear_combination h1 + 3 • h2</code>?</p>



<a name="281368046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281368046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281368046">(May 05 2022 at 22:34)</a>:</h4>
<p>I think it would be ~impossible to do that and support arbitrary proof term inputs like this PR does</p>



<a name="281368065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281368065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281368065">(May 05 2022 at 22:35)</a>:</h4>
<p>Since it's ambiguous whether the <code>+</code> is part of a proof term or tactic syntax</p>



<a name="281368307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281368307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281368307">(May 05 2022 at 22:38)</a>:</h4>
<p>The + can't be part of a proof term since has_add only works on Type not Prop</p>



<a name="281368369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281368369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281368369">(May 05 2022 at 22:39)</a>:</h4>
<p>But I guess a subterm could contain data. I'm not claiming it's necessarily a good idea!</p>



<a name="281368401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281368401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281368401">(May 05 2022 at 22:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kd">notation</span> <span class="n">p</span> <span class="bp">`+`</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">p</span> <span class="n">q</span>

<span class="k">#check</span> <span class="n">eq.refl</span> <span class="bp">+</span> <span class="mi">0</span>
</code></pre></div>



<a name="281368489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281368489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281368489">(May 05 2022 at 22:40)</a>:</h4>
<p>There may be a way to coerce it into working but it would be hacky and not worth it IMO!</p>



<a name="281382000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281382000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281382000">(May 06 2022 at 02:13)</a>:</h4>
<p>This is my preferred syntax as well, I don't think it's a crazy idea as long as you parse the expressions with the right precedence</p>



<a name="281382168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281382168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281382168">(May 06 2022 at 02:16)</a>:</h4>
<p>see <a href="#narrow/stream/116395-maths/topic/groebner.20basis.20algorithm/near/197257520">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/groebner.20basis.20algorithm/near/197257520</a>, which predates <code>linear_combination</code></p>



<a name="281382187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281382187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281382187">(May 06 2022 at 02:17)</a>:</h4>
<p>the solution to your example <span class="user-mention" data-user-id="110596">@Rob Lewis</span>  is "stop doing that silly thing"</p>



<a name="281382198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281382198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281382198">(May 06 2022 at 02:17)</a>:</h4>
<p>if you redefine basic operators with a local notation then lots of stuff will break</p>



<a name="281384635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281384635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281384635">(May 06 2022 at 03:03)</a>:</h4>
<p>here's a parser:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">expr.get_frozen_name</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">name</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">e.is_annotation</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="bp">`</span><span class="n">frozen_name</span><span class="o">,</span> <span class="n">expr.const</span> <span class="n">n</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">name.anonymous</span>
<span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">pexpr.get_app_args</span> <span class="o">:</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">opt_param</span> <span class="o">(</span><span class="n">list</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">pexpr</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">pexpr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">pexpr.get_app_args</span> <span class="n">e1</span> <span class="o">(</span><span class="n">e2</span><span class="o">::</span><span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e1</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_mul</span> <span class="o">:</span> <span class="n">list</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">pexpr</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="o">:=</span> <span class="n">e</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">e</span><span class="o">::</span><span class="n">es</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">e</span> <span class="bp">*</span> <span class="bp">%%</span><span class="o">(</span><span class="n">mk_mul</span> <span class="n">es</span><span class="o">))</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">as_linear_combo</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">pexpr</span> <span class="bp">×</span> <span class="n">pexpr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pexpr.get_app_args</span> <span class="n">e</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">head.get_frozen_name</span><span class="o">,</span> <span class="n">args</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_add.add</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e1</span> <span class="bp">++</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_sub.sub</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e1</span> <span class="bp">++</span> <span class="n">as_linear_combo</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">neg</span><span class="o">)</span> <span class="n">ms</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_mul.mul</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="o">(</span><span class="n">e1</span><span class="o">::</span><span class="n">ms</span><span class="o">)</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_neg.neg</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">neg</span><span class="o">)</span> <span class="n">ms</span> <span class="n">e1</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">mk_mul</span> <span class="n">ms</span> <span class="k">in</span> <span class="o">[(</span><span class="k">if</span> <span class="n">neg</span> <span class="k">then</span> <span class="bp">``</span><span class="o">(</span><span class="bp">-%%</span><span class="n">m</span><span class="o">)</span> <span class="k">else</span> <span class="n">m</span><span class="o">,</span> <span class="n">e</span><span class="o">)]</span>
  <span class="kd">end</span>

<span class="kn">section</span>
<span class="n">setup_tactic_parser</span>
<span class="kn">open</span> <span class="n">tactic</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.linear_combo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">as_linear_combo</span> <span class="n">ff</span> <span class="o">[]</span> <span class="bp">&lt;$&gt;</span> <span class="n">texpr</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">p</span> <span class="bp">←</span> <span class="n">p.mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩,</span> <span class="k">do</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">i_to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span><span class="o">:</span><span class="n">ℤ</span><span class="o">),</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">i_to_expr</span> <span class="n">b</span><span class="o">,</span> <span class="n">pure</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)),</span>
  <span class="n">trace</span> <span class="n">p</span> <span class="bp">&gt;&gt;</span> <span class="gr">admit</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">linear_combo</span> <span class="bp">-</span><span class="n">h1</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">h2</span>
  <span class="c1">-- [(-1, h1), (-2, h2)]</span>
</code></pre></div>



<a name="281405241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281405241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281405241">(May 06 2022 at 07:54)</a>:</h4>
<p>Going a step further; would something like a <code>has_padd</code> class be possible, which would avoid the need to do any parsing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_padd</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">padd</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>

<span class="c1">-- I think Lean should be able to handle the overloading</span>
<span class="kd">infix</span> <span class="bp">`+`</span> <span class="o">:=</span> <span class="n">has_padd.padd</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_padd</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">padd</span> <span class="o">:=</span> <span class="n">congr_arg2</span> <span class="o">(</span><span class="bp">+</span><span class="o">)}</span>
</code></pre></div>



<a name="281405307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281405307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281405307">(May 06 2022 at 07:55)</a>:</h4>
<p>You could then put instances on things like <code>is_even</code> too (and many things matching <a href="https://leanprover-community.github.io/mathlib_docs/find/.add">docs#.add</a>)</p>



<a name="281421374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281421374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281421374">(May 06 2022 at 10:44)</a>:</h4>
<p>Eric, I do not know if this can really be pulled off, but your suggestion looks <em>great</em>!  If it can be made to work, I can definitely find uses for it!</p>
<p>It feels a little like a "monadic instance of addition".</p>



<a name="281422421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281422421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281422421">(May 06 2022 at 10:58)</a>:</h4>
<p>Adding proofs is definitely unexpected, so I'm not really sold. And I don't see why we should treat addition separately from literally any other operator (inversion, subtraction, power, order ...)</p>



<a name="281422633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281422633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281422633">(May 06 2022 at 11:00)</a>:</h4>
<p>I would be proposing we apply the same gimmick to lots of operators, so I don't think inconsistency is that relevant; but the unexpectedness is certainly a concern</p>



<a name="281423391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281423391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281423391">(May 06 2022 at 11:09)</a>:</h4>
<p>There will be the need of <code>to_padditive</code>...</p>



<a name="281428525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281428525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281428525">(May 06 2022 at 12:07)</a>:</h4>
<p>I'm more comfortable with the pexpr parser approach because it doesn't bleed out into other things. I don't want adding proofs with <code>+</code> to be generally possible, not least because of the overloading of <code>+</code></p>



<a name="281428713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281428713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281428713">(May 06 2022 at 12:08)</a>:</h4>
<p>I think it is more excusable when it is part of a bespoke tactic, people are already used to tactics introducing their own funny syntax</p>



<a name="281429052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281429052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281429052">(May 06 2022 at 12:11)</a>:</h4>
<p>I think what I'm actually after here is a tactic version of <a href="https://leanprover-community.github.io/mathlib_docs/find/congr_arg">docs#congr_arg</a> that's generalized to <code>n</code> variables and has a nice syntax</p>



<a name="281429126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281429126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281429126">(May 06 2022 at 12:12)</a>:</h4>
<p>Rather than restricting ourself to only a few operators (like your pexpr trick), or building nasty hacks (like my <code>padd</code>)</p>



<a name="281429172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281429172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281429172">(May 06 2022 at 12:12)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#congr">tactic#congr</a>?</p>



<a name="281429335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281429335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281429335">(May 06 2022 at 12:14)</a>:</h4>
<p>So something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hcd</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">hef</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">combine</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">_</span><span class="o">[</span><span class="n">hab</span><span class="o">]</span> <span class="bp">+</span> <span class="n">_</span><span class="o">[</span><span class="n">hcd</span><span class="o">]</span> <span class="bp">*</span> <span class="n">_</span><span class="o">[</span><span class="n">hef</span><span class="o">]),</span>
    <span class="c1">-- this: 1 + a + c * e = 1 + b + d * f</span>
    <span class="n">trivial</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281429570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281429570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281429570">(May 06 2022 at 12:16)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#congr">tactic#congr</a> requires you to state your goal up front, this would work out the sides of the equality from the inputs.</p>



<a name="281429862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281429862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281429862">(May 06 2022 at 12:18)</a>:</h4>
<p>this is pretty similar to <code>&lt;- e</code> desugaring in lean 4</p>



<a name="281430420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430420">(May 06 2022 at 12:24)</a>:</h4>
<p>With the difference being that instead of evaluating the expression on the results of the monads <code>e</code>, you evaluate <code>congr_argn</code> on the  expression and the <code>e</code>s?</p>



<a name="281430502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430502">(May 06 2022 at 12:25)</a>:</h4>
<p>I guess I agree the parsing task is pretty similar</p>



<a name="281430504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430504">(May 06 2022 at 12:25)</a>:</h4>
<p>Oh, another example of this kind of transformation is <code>%%e</code> in expr quotations</p>



<a name="281430642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430642">(May 06 2022 at 12:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">λ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">,</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">h1</span> <span class="bp">+</span> <span class="bp">%%</span><span class="n">h2</span> <span class="bp">+</span> <span class="bp">%%</span><span class="n">h3</span><span class="o">)</span>
<span class="c1">-- λ (h1 h2 h3 : pexpr),</span>
<span class="c1">--   ((``(λ (_x_1 _x_2 _x_3 : _), has_add.add (has_add.add _x_1 _x_2) _x_3)</span>
<span class="c1">--      .subst (to_pexpr h1))</span>
<span class="c1">--      .subst (to_pexpr h2))</span>
<span class="c1">--      .subst (to_pexpr h3)</span>
</code></pre></div>



<a name="281430705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430705">(May 06 2022 at 12:27)</a>:</h4>
<p>thats <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.subst">docs#expr.subst</a> not <a href="https://leanprover-community.github.io/mathlib_docs/find/eq.subst">docs#eq.subst</a> I assume</p>



<a name="281430727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430727">(May 06 2022 at 12:27)</a>:</h4>
<p>yes</p>



<a name="281430815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430815">(May 06 2022 at 12:28)</a>:</h4>
<p>So should we just hack into that parser and manipulate the resulting pexpr?</p>



<a name="281430827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281430827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281430827">(May 06 2022 at 12:28)</a>:</h4>
<p>although... it wouldn't be too hard to parse that pexpr with the lambda and subst</p>



<a name="281431363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281431363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281431363">(May 06 2022 at 12:34)</a>:</h4>
<p>Here's a free corner of the syntax: <code>combine 1 + _ h1 + _ h2 + _ h3</code></p>



<a name="281449195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281449195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281449195">(May 06 2022 at 14:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281384635">said</a>:</p>
<blockquote>
<p>here's a parser:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">expr.get_frozen_name</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">name</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">e.is_annotation</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="bp">`</span><span class="n">frozen_name</span><span class="o">,</span> <span class="n">expr.const</span> <span class="n">n</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">name.anonymous</span>
<span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">pexpr.get_app_args</span> <span class="o">:</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">opt_param</span> <span class="o">(</span><span class="n">list</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">pexpr</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">pexpr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">pexpr.get_app_args</span> <span class="n">e1</span> <span class="o">(</span><span class="n">e2</span><span class="o">::</span><span class="n">r</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e1</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_mul</span> <span class="o">:</span> <span class="n">list</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">pexpr</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="o">:=</span> <span class="n">e</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">e</span><span class="o">::</span><span class="n">es</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">e</span> <span class="bp">*</span> <span class="bp">%%</span><span class="o">(</span><span class="n">mk_mul</span> <span class="n">es</span><span class="o">))</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">as_linear_combo</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">pexpr</span> <span class="bp">×</span> <span class="n">pexpr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pexpr.get_app_args</span> <span class="n">e</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">head.get_frozen_name</span><span class="o">,</span> <span class="n">args</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_add.add</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e1</span> <span class="bp">++</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_sub.sub</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e1</span> <span class="bp">++</span> <span class="n">as_linear_combo</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">neg</span><span class="o">)</span> <span class="n">ms</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_mul.mul</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="o">(</span><span class="n">e1</span><span class="o">::</span><span class="n">ms</span><span class="o">)</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_neg.neg</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">neg</span><span class="o">)</span> <span class="n">ms</span> <span class="n">e1</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">mk_mul</span> <span class="n">ms</span> <span class="k">in</span> <span class="o">[(</span><span class="k">if</span> <span class="n">neg</span> <span class="k">then</span> <span class="bp">``</span><span class="o">(</span><span class="bp">-%%</span><span class="n">m</span><span class="o">)</span> <span class="k">else</span> <span class="n">m</span><span class="o">,</span> <span class="n">e</span><span class="o">)]</span>
  <span class="kd">end</span>

<span class="kn">section</span>
<span class="n">setup_tactic_parser</span>
<span class="kn">open</span> <span class="n">tactic</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.linear_combo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">as_linear_combo</span> <span class="n">ff</span> <span class="o">[]</span> <span class="bp">&lt;$&gt;</span> <span class="n">texpr</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">p</span> <span class="bp">←</span> <span class="n">p.mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩,</span> <span class="k">do</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">i_to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span><span class="o">:</span><span class="n">ℤ</span><span class="o">),</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">i_to_expr</span> <span class="n">b</span><span class="o">,</span> <span class="n">pure</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)),</span>
  <span class="n">trace</span> <span class="n">p</span> <span class="bp">&gt;&gt;</span> <span class="gr">admit</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">linear_combo</span> <span class="bp">-</span><span class="n">h1</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">h2</span>
  <span class="c1">-- [(-1, h1), (-2, h2)]</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Interesting. This is lower level and more robust than my attempt to do this yesterday (trying to split the components at parse time instead of after). Let me try it out a bit. One thing I worry about a little is the predictability of when you need parens around the scalar and/or proof term, but your approach is better than mine here</p>



<a name="281449386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281449386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281449386">(May 06 2022 at 14:44)</a>:</h4>
<p>I should say, my ulterior motive here is for a tactic that will produce <code>Try this:</code> suggestions involving <code>linear_combination</code>, so I'd really like the syntax of <code>linear_combination</code> to stay predictable.</p>



<a name="281449663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281449663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281449663">(May 06 2022 at 14:46)</a>:</h4>
<p>Can't say I'm a big fan of adding global notation instances to Prop, but it's kind of cute that it works!</p>



<a name="281450444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281450444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281450444">(May 06 2022 at 14:51)</a>:</h4>
<p>Also, this syntax change is mostly orthogonal to <a href="https://github.com/leanprover-community/mathlib/pull/13979">#13979</a>, so it should be a separate PR</p>



<a name="281485078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281485078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281485078">(May 06 2022 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281429335">said</a>:</p>
<blockquote>
<p>So something like</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hcd</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">hef</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">combine</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">_</span><span class="o">[</span><span class="n">hab</span><span class="o">]</span> <span class="bp">+</span> <span class="n">_</span><span class="o">[</span><span class="n">hcd</span><span class="o">]</span> <span class="bp">*</span> <span class="n">_</span><span class="o">[</span><span class="n">hef</span><span class="o">]),</span>
    <span class="c1">-- this: 1 + a + c * e = 1 + b + d * f</span>
    <span class="n">trivial</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>One way to understand this <code>combine</code> tactic proposal is that (in this example) you're explicitly writing down the motive for an "<code>eq.rec3</code>" along with which equalities are used. Maybe rather than a tactic, you could have a <code>congr!</code> macro that looks something like <code>congr!(1 + %hab + %hcd + %hef)</code> so it could be easily used in term mode too.</p>



<a name="281485122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281485122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281485122">(May 06 2022 at 19:42)</a>:</h4>
<p>I hadn't even considered that term-mode macros exist</p>



<a name="281572654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281572654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281572654">(May 08 2022 at 02:07)</a>:</h4>
<p>I'm warming to <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> 's parser for <code>linear_combination</code>. <a href="https://github.com/leanprover-community/mathlib/commit/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad">https://github.com/leanprover-community/mathlib/commit/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad</a>  </p>
<p>Two quirks. One, I had to add a <code>with</code> in order to parse the optional config object, otherwise it gets picked up as part of the pexpr. This isn't a problem. Two, it doesn't like the <a href="https://github.com/leanprover-community/mathlib/commit/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad#diff-bab69459876baf7d7bd3c5a90d915708f02e0912cbc69df05303049e3fed3707R181">zero arguments case</a>, without a trailing <code>.</code> it tries to parse the next <code>example</code>. Not sure what the fix is there.</p>



<a name="281582749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281582749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281582749">(May 08 2022 at 06:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> Where is your "zero arguments case" link going? I don't see any examples of zero arguments in the PR.</p>



<a name="281583100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281583100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281583100">(May 08 2022 at 06:38)</a>:</h4>
<p>I wanted to write it to parse <code>0</code> as an empty list of summands, but it will require more lean API (as you know, it is woefully underpowered when it comes to reflection on <code>pexpr</code>s). Here's a workaround that uses string parsing to recognize prenums:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">pexpr.is_prenum</span> <span class="o">:</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">expr.macro</span> <span class="n">m</span> <span class="o">[])</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">expr.macro_def_name</span> <span class="n">m</span> <span class="bp">=</span> <span class="bp">`</span><span class="n">prenum</span> <span class="k">then</span> <span class="n">string.to_nat</span> <span class="n">e.to_string</span> <span class="k">else</span> <span class="n">none</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">as_linear_combo</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">pexpr</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">pexpr</span> <span class="bp">×</span> <span class="n">pexpr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pexpr.get_app_args</span> <span class="n">e</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">head.get_frozen_name</span><span class="o">,</span> <span class="n">args</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_add.add</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e1</span> <span class="bp">++</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_sub.sub</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="n">ms</span> <span class="n">e1</span> <span class="bp">++</span> <span class="n">as_linear_combo</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">neg</span><span class="o">)</span> <span class="n">ms</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_mul.mul</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="n">neg</span> <span class="o">(</span><span class="n">e1</span><span class="o">::</span><span class="n">ms</span><span class="o">)</span> <span class="n">e2</span>
  <span class="bp">|</span> <span class="bp">``</span><span class="n">has_neg.neg</span><span class="o">,</span> <span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">:=</span> <span class="n">as_linear_combo</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">neg</span><span class="o">)</span> <span class="n">ms</span> <span class="n">e1</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">head.is_prenum</span><span class="o">,</span> <span class="n">args</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="mi">0</span><span class="o">,</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">mk_mul</span> <span class="n">ms</span> <span class="k">in</span> <span class="o">[(</span><span class="k">if</span> <span class="n">neg</span> <span class="k">then</span> <span class="bp">``</span><span class="o">(</span><span class="bp">-%%</span><span class="n">m</span><span class="o">)</span> <span class="k">else</span> <span class="n">m</span><span class="o">,</span> <span class="n">e</span><span class="o">)]</span>
    <span class="kd">end</span>
  <span class="kd">end</span>
</code></pre></div>
<p>Now you can write <code>linear_combo 0</code> and <code>linear_combo 0 + h1</code> and so on.</p>



<a name="281602521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281602521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281602521">(May 08 2022 at 14:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281582749">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> Where is your "zero arguments case" link going? I don't see any examples of zero arguments in the PR.</p>
</blockquote>
<p>Huh, guess the link to a line of a commit doesn't work, it's <a href="https://github.com/leanprover-community/mathlib/blob/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad/test/linear_combination.lean#L181">here</a>. Not changed in the PR, on <a href="https://github.com/leanprover-community/mathlib/tree/robertylewis/lc-syntax">branch#robertylewis/lc-syntax</a> since the syntax change is mostly independent of this PR</p>



<a name="281602569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281602569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281602569">(May 08 2022 at 14:48)</a>:</h4>
<p>I don't love having to write 0 for the empty list. <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> as <code>linear_combination</code>'s main customer, what do you think here?</p>



<a name="281603123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281603123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281603123">(May 08 2022 at 15:01)</a>:</h4>
<p>I don't think optional exprs have ever worked. <code>transitivity</code> shows the same behavior. It works if there is anything else around the tactic: <code>by { linear_combo }</code> or <code>begin linear_combo end</code> or <code>linear_combo,</code> in a tactic sequence all work fine. So I would say use <code>texpr?</code> in the parser and take advantage of it when you can</p>



<a name="281627870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281627870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281627870">(May 09 2022 at 01:15)</a>:</h4>
<p>Here's a possible realization of <span class="user-mention" data-user-id="310045">@Eric Wieser</span>'s idea from earlier. It's a tactic since I couldn't get <code>user_command</code>s to work -- they don't seem to have access to local variables. (I'm not proposing that this be used for <code>linear_combination</code>, but it would be nice to have something like this for creating congruence lemmas.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="n">setup_tactic_parser</span>

<span class="kd">def</span> <span class="n">congr_subst</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kd">prefix</span> <span class="bp">`%!`</span><span class="o">:</span><span class="n">std.prec.max_plus</span> <span class="o">:=</span> <span class="n">congr_subst</span>

<span class="c1">-- use congr lemmas? (like mk_specialized_congr_lemma used by tactic.congr)</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">congr_mk</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">option</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">congr_subst</span> <span class="bp">%%</span><span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="c1">-- need to be careful due to potential dependent types</span>
  <span class="n">hf</span> <span class="bp">←</span> <span class="n">congr_mk</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">hx</span> <span class="bp">←</span> <span class="n">congr_mk</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">hf</span><span class="o">,</span> <span class="n">hx</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">hf</span><span class="o">),</span> <span class="o">(</span><span class="n">some</span> <span class="n">hx</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_congr</span> <span class="n">hf</span> <span class="n">hx</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">hf</span><span class="o">),</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_congr_fun</span> <span class="n">hf</span> <span class="n">x</span>
  <span class="bp">|</span> <span class="n">none</span><span class="o">,</span> <span class="o">(</span><span class="n">some</span> <span class="n">hx</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_congr_arg</span> <span class="n">f</span> <span class="n">hx</span>
  <span class="bp">|</span> <span class="n">none</span><span class="o">,</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">none</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">none</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">interactive.exact_congr</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">i_to_expr_strict</span> <span class="n">e</span><span class="o">,</span> <span class="c1">-- the definition of congr_subst results in reasonable type errors here</span>
  <span class="n">he</span> <span class="bp">←</span> <span class="n">congr_mk</span> <span class="n">e</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">he</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">mk_eq_refl</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.exact</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">he</span> <span class="o">:=</span> <span class="n">tactic.exact</span> <span class="n">he</span>
  <span class="kd">end</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="mi">3</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">5</span><span class="bp">*</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">11</span><span class="bp">*</span><span class="n">y</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">11</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_congr</span> <span class="bp">-</span><span class="mi">2</span><span class="bp">*%!</span><span class="n">h1</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*%!</span><span class="n">h2</span><span class="o">,</span>
  <span class="n">ring_nf</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">c</span><span class="bp">*</span><span class="mi">3</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">h4</span> <span class="o">:</span> <span class="bp">-</span><span class="n">d</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">2</span><span class="bp">*</span><span class="n">a</span> <span class="bp">-</span> <span class="mi">3</span> <span class="bp">+</span> <span class="mi">9</span><span class="bp">*</span><span class="n">c</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*</span><span class="n">d</span> <span class="bp">=</span> <span class="mi">8</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*</span><span class="n">d</span> <span class="bp">-</span> <span class="mi">3</span><span class="bp">*</span><span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_congr</span> <span class="mi">2</span><span class="bp">*%!</span><span class="n">h1</span> <span class="bp">-</span><span class="mi">1</span><span class="bp">*%!</span><span class="n">h2</span> <span class="bp">+</span><span class="mi">3</span><span class="bp">*%!</span><span class="n">h3</span> <span class="bp">-</span><span class="mi">3</span><span class="bp">*%!</span><span class="n">h4</span><span class="o">,</span>
  <span class="n">ring_nf</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281629593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281629593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281629593">(May 09 2022 at 01:57)</a>:</h4>
<p>Nice! Agreed, I don't think it makes sense for <code>linear_combination</code>, but something like that is a useful feature in its own right</p>



<a name="281629649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/281629649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#281629649">(May 09 2022 at 01:58)</a>:</h4>
<p>If people are okay with the slightly broken syntax in the empty case I'll PR it soon. But <a href="https://github.com/leanprover-community/mathlib/pull/13979">#13979</a> is independent and can be merged first</p>



<a name="282842391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2313979%20arbitrary%20proof%20terms%20in%20%60linear_combination%60/near/282842391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60.html#282842391">(May 18 2022 at 20:10)</a>:</h4>
<p>I've opened <a href="https://github.com/leanprover-community/mathlib/pull/14229">#14229</a> which builds on this one, adding Mario's parser.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
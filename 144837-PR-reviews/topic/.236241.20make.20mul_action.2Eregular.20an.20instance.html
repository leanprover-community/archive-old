---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html">#6241 make mul_action.regular an instance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227313972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227313972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227313972">(Feb 22 2021 at 18:27)</a>:</h4>
<p>This PR had a bit of discussion last week, which died out quickly. The question is whether to make <code>mul_action.regular</code> an instance by default, which would make <code>(a : M) \smul (b : M)</code> equal <code>a * b</code> for any monoid <code>M</code>. (This is currently only the case for semirings.) Currently, some places already opt in with <code>local attribute [instance] mul_action.regular</code>. The objection is that there are many other multiplicative actions of monoids/groups on themselves, e.g. conjugation.</p>
<p>I think if we want to privilege one multiplicative action, it would have to be <code>mul_action.regular</code>, at least to match the <code>semiring</code> situation. And we can always add type synonyms to handle other actions, like we already do with <code>opposite</code>. So I'm weakly in favour of this PR.</p>
<p>What do you all think?</p>



<a name="227315343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227315343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227315343">(Feb 22 2021 at 18:36)</a>:</h4>
<p>So what would happen if a second year undergraduate comes along to me and says "how do I define the conjugation action of G on G and prove it's an action in Lean"?</p>



<a name="227315366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227315366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227315366">(Feb 22 2021 at 18:36)</a>:</h4>
<p>(G a group)</p>



<a name="227315551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227315551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227315551">(Feb 22 2021 at 18:37)</a>:</h4>
<p>The answer is probably "we already have that but your chance of finding it is zero because doc-gen only indexes things tagged with @[instance]", as it is today.</p>



<a name="227316168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227316168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227316168">(Feb 22 2021 at 18:42)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/conj.quandle">docs#conj.quandle</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/conj_act_eq_conj">docs#conj_act_eq_conj</a> are the mathlib definitions</p>



<a name="227316185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227316185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227316185">(Feb 22 2021 at 18:42)</a>:</h4>
<p>Where the conclusion seems to have been "don't use mul_action at all"</p>



<a name="227316404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227316404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227316404">(Feb 22 2021 at 18:44)</a>:</h4>
<p>Students typically want to define something themselves, not just find it in mathlib. I'm asking whether this would somehow become harder if this idea were to be implemented.</p>



<a name="227316625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227316625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227316625">(Feb 22 2021 at 18:46)</a>:</h4>
<p>The pattern I see is that someone comes along just once to Xena, announces that they want to prove some random thing that they've learnt today in class, e.g. that if G is a group such that g^2=1 for all g then G is abelian, and I help them along and they formalise it in Lean and they're really pleased and then they go away and I may never see them again but at least they can tell their grandchildren that they once formalised a proof on a computer. This is fine by me.</p>



<a name="227317740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227317740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227317740">(Feb 22 2021 at 18:53)</a>:</h4>
<p>So, whatever problem they'd face defining the conjugation on a group if we made <code>mul_action.regular</code> an instance, they already face when defining the same action on a group_with_zero with the instance <a href="https://leanprover-community.github.io/mathlib_docs/find/semiring.to_semimodule">docs#semiring.to_semimodule</a>. But at a first glance, there is no problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">mul_action.regular</span>  <span class="c1">-- makes no difference</span>

<span class="kd">instance</span> <span class="n">conj_action</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">M</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span>
    <span class="k">calc</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_inv_rev</span>
                             <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">conj_action'</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group_with_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">M</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span>
    <span class="k">calc</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_inv_rev'</span>
                             <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>

<span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">G</span> <span class="n">G</span><span class="o">)</span>  <span class="c1">-- conj_action, not mul_action.regular</span>

<span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">ℚ</span> <span class="n">ℚ</span><span class="o">)</span>  <span class="c1">-- conj_action', not semiring.to_semimodule</span>
</code></pre></div>
<p>You're in for a bad time anyway if you're using a different <code>mul_action</code> instance to <code>regular</code>, as all the places that set it as a local instance will look like they apply to your version too but won't.</p>



<a name="227776943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227776943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227776943">(Feb 25 2021 at 14:40)</a>:</h4>
<p>Any more thoughts on marking the instance given the above?</p>



<a name="227893997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227893997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227893997">(Feb 26 2021 at 08:02)</a>:</h4>
<p>Let's have a poll. Personally, I'm coming around to the idea that whenever we want a non-regular action we should just have some type synonym to deal with it.</p>



<a name="227894044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227894044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227894044">(Feb 26 2021 at 08:03)</a>:</h4>
<p>/poll Shall <code>mul_action.regular</code> be an instance?</p>
<ul>
<li>yes</li>
<li>no</li>
<li>did you say pancakes? <span aria-label="pancakes" class="emoji emoji-1f95e" role="img" title="pancakes">:pancakes:</span></li>
</ul>



<a name="227905001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%236241%20make%20mul_action.regular%20an%20instance/near/227905001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.236241.20make.20mul_action.2Eregular.20an.20instance.html#227905001">(Feb 26 2021 at 09:54)</a>:</h4>
<p>Eric's post convinces me that in the use case I was thinking about (a one-off experiment which I just want to work out of the box) it's fine. And even if it hadn't worked one could just remove the instance. My objection is "for a one-off experiment will this get in the way", but I think the correct question is "for a development which is mathlib-worthy, will this get in the way" i.e. something like "is there some branch of maths where one consistently uses a different action of a monoid on itself" and I guess my answer is "I can't think of any right now", so like Anne I am weakly in favour.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
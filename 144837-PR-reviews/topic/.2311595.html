---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2311595.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html">#11595</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273305981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273305981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273305981">(Feb 26 2022 at 01:00)</a>:</h4>
<p>Can we merge this? It's been a couple weeks and it's relatively important.</p>



<a name="273311830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273311830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273311830">(Feb 26 2022 at 02:43)</a>:</h4>
<p>I left a few comments.</p>



<a name="273328113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273328113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273328113">(Feb 26 2022 at 08:49)</a>:</h4>
<p>Why do you need this specialization of <code>eq_to_hom</code>?</p>



<a name="273328168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273328168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273328168">(Feb 26 2022 at 08:50)</a>:</h4>
<p>Also, it would be nice to isolate adding the coercion to <code>Groupoid</code> and removing the <code>.α</code> in a separate PR.</p>



<a name="273328377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273328377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273328377">(Feb 26 2022 at 08:57)</a>:</h4>
<p>Yes -- PRs of over 200 lines and containing several definitions are harder to review -- the shorter you can make a PR the better. The community has extremely high standards when it comes to library code as well. A postdoc of mine made a PR changing one character and two weeks later there's still a lively discussion going on about the change.</p>



<a name="273352268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273352268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273352268">(Feb 26 2022 at 17:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> which one? I want to see this.</p>



<a name="273353400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273353400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273353400">(Feb 26 2022 at 17:45)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/11962">#11962</a> changes a <code>u</code> to a <code>v</code></p>



<a name="273371690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273371690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273371690">(Feb 27 2022 at 00:21)</a>:</h4>
<p><span class="user-mention" data-user-id="437861">@Praneeth Kolichala</span>, my comment about splitting off the <code>has_coe_to_sort</code> changes is for you to <strong>split them off</strong>, not retract them <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="273371737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273371737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273371737">(Feb 27 2022 at 00:22)</a>:</h4>
<p>Understand, <a href="https://github.com/leanprover-community/mathlib/pull/11595">#11595</a> should depend on the <code>has_coe_to_sort</code> PR.</p>



<a name="273372301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273372301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273372301">(Feb 27 2022 at 00:34)</a>:</h4>
<p>Oh my idea was the reverse. I locally checked out a new branch with the coe_to_sort changes, reverted those commits on the old branch, and I was planning on making the has_coe_to_sort branch depend on the old one.</p>



<a name="273372388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273372388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273372388">(Feb 27 2022 at 00:37)</a>:</h4>
<p>I can do what you're suggesting too (but I guess I would have to manually copy over the  <code>has_coe_to_sort</code> changes, since the commits modify code in <a href="https://github.com/leanprover-community/mathlib/pull/11595">#11595</a>, so they can't be automatically be added to a different branch?)</p>



<a name="273372588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273372588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273372588">(Feb 27 2022 at 00:42)</a>:</h4>
<p>I made the PR because it was already ready (<a href="https://github.com/leanprover-community/mathlib/pull/12323">#12323</a>), but I'll work on doing it in the way <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> suggested, which is to have this PR (<a href="https://github.com/leanprover-community/mathlib/pull/11595">#11595</a>) depend on that rather than the other way around.</p>



<a name="273383666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273383666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273383666">(Feb 27 2022 at 05:19)</a>:</h4>
<p>Both should be fine (but you should have merge conflicts either way, right?)</p>



<a name="273589289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273589289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273589289">(Mar 01 2022 at 04:19)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> To respond to your questions/suggestions that you left on the pull request:</p>
<p>The <code>ulift</code> here is to allow <code>H : I × X -&gt; Y</code>, a homotopy, to be of type <code>(ulift I) × X -&gt; Y</code>, as you know. This is so that we can map pairs of paths <code>(p, q)</code>, where p is a homotopy path class in <code>I</code> and <code>q</code> is a homotopy path class in <code>X</code>, to the path in Y that happens when you "run" <code>p</code> and <code>q</code> in parallel (i.e. the path which is at <code>H(p(t), q(t))</code> at time <code>t</code>; for this to be well-defined, we need to show that it doesn't matter which path you choose in <code>p</code>).   I thought this was in general a useful notion to have for homotopies, and this is already implemented by <code>prod_to_prod_Top</code>, which provides an isomorphism <code>πₓA × πₓB = πₓ(A × B)</code>, and hence exactly such a map. Unfortunately, because <code>prod_to_prod_Top</code> is a statement using category theory, it requires <code>A</code> and <code>B</code> to be in the same universe. This is why I explicitly want a conversion of <code>H</code> to a map where <code>I</code> and <code>X</code> are in the same universe. We don't need to lift <code>X</code> and <code>Y</code> to higher universes because they are already spaces in an arbitrary universe, whereas we need to lift <code>I</code> because it is a subset of the real numbers, which only lives in <code>Type 0</code>.</p>
<p>I have another version using the lower level <code>path.homotopic.prod</code>, which is what <code>prod_to_prod_Top</code> is based off of, and avoiding the slightly messy <code>ulift</code>'s . However, I chose to use this because it takes advantage of the existing category theory library. For example, I can use the functorality of <code>prod_to_prod_Top</code> without reproving it (e.g. see lemma <code>eq_diag_path</code>). I'm OK with going back to that version if people think it's cleaner/shorter.</p>



<a name="273589644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273589644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273589644">(Mar 01 2022 at 04:26)</a>:</h4>
<p>For <code>hcast</code> (homotopy cast), this is largely for convenience. I agree that there might be a better way to do it, but I'm not really sure how. Without this abbreviation, <code>eq_to_hom</code> becomes very painful to use for the fundamental groupoid, because Lean doesn't recognize <code>x=y</code>, where <code>x</code> and <code>y</code> are points in a topological space, as also expressing an equality about points in the corresponding fundamental groupoid.</p>
<p>For example, the definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">diagonal_path'</span> <span class="o">:</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₀</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">g</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">hcast</span> <span class="o">(</span><span class="n">H.apply_zero</span> <span class="n">x₀</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">H.diagonal_path</span> <span class="n">p</span><span class="o">)</span> <span class="bp">≫</span> <span class="n">hcast</span> <span class="o">(</span><span class="n">H.apply_one</span> <span class="n">x₁</span><span class="o">)</span>
</code></pre></div>
<p>would have to be something like (untested):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">diagonal_path'</span> <span class="o">:</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₀</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">g</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">eq_to_hom</span> <span class="o">(</span><span class="n">H.apply_zero</span> <span class="n">x₀</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">:</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₀</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">H</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x₀</span><span class="o">)))</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">H.diagonal_path</span> <span class="n">p</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">eq_to_hom</span> <span class="o">(</span><span class="n">eq_to_hom</span> <span class="o">(</span><span class="n">H.apply_one</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">H</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x₁</span><span class="o">))</span> <span class="bp">⟶</span> <span class="n">from_top</span> <span class="o">(</span><span class="n">g</span> <span class="n">x₁</span><span class="o">))</span>
</code></pre></div>
<p>which is much longer, and time-consuming to think about because Lean doesn't automatically figure out the types for you.</p>
<p>I'm not sure in what other way I'm reinventing the wheel. The rest of the file relates <code>hcast</code> for homotopy classes of paths to <code>path.cast</code>, and then proves a small lemma that involves casts. I was thinking it might be easier to use <code>heq</code> since there seems to be some additions to the relationship between <code>eq_to_hom</code> and <code>heq</code>, but <code>eq_to_hom</code> is good enough here. If you have any suggestions to simplify, or could point me to lemmas that I've accidentally duplicated, I'd appreciate it!</p>



<a name="273607059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2311595/near/273607059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2311595.html#273607059">(Mar 01 2022 at 08:51)</a>:</h4>
<p>I swear this is a question for <span class="user-mention" data-user-id="266440">@Shing Tak Lam</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
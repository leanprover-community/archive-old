---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html">#17767 uniform continuity of functions in Câ‚€(X, Y)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="312987349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2317767%20uniform%20continuity%20of%20functions%20in%20C%E2%82%80%28X%2C%20Y%29/near/312987349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html#312987349">(Nov 30 2022 at 05:04)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/17767">#17767</a><br>
I wonder if there's a slicker proof using filters, or if there's an simpler statement of <code>is_compact.uniform_continuous_at_of_continuous_at</code> using filters.</p>



<a name="313013442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2317767%20uniform%20continuity%20of%20functions%20in%20C%E2%82%80%28X%2C%20Y%29/near/313013442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html#313013442">(Nov 30 2022 at 09:04)</a>:</h4>
<p>I don't have much time, but I can bet the first step towards answering this question is to reformulate</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">âˆ€</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">âˆˆ</span> <span class="bp">ğ“¤</span> <span class="n">Î²</span> <span class="bp">â†’</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span> <span class="bp">Ã—</span> <span class="n">Î±</span> <span class="bp">|</span> <span class="n">x.1</span> <span class="bp">âˆˆ</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="o">(</span><span class="n">f</span> <span class="n">x.1</span><span class="o">,</span> <span class="n">f</span> <span class="n">x.2</span><span class="o">)</span> <span class="bp">âˆˆ</span> <span class="n">r</span><span class="o">}</span> <span class="bp">âˆˆ</span> <span class="bp">ğ“¤</span> <span class="n">Î±</span>
</code></pre></div>
<p>into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">map</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">f</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">ğ“¤</span> <span class="n">Î±</span> <span class="bp">âŠ“</span> <span class="o">(</span><span class="bp">ğ“Ÿ</span> <span class="n">s</span> <span class="bp">Ã—á¶ </span> <span class="bp">âŠ¤</span><span class="o">))</span> <span class="bp">â‰¤</span> <span class="bp">ğ“¤</span> <span class="n">Î²</span>
</code></pre></div>
<p>which says the same thing in a more filter-friendly way. Note it is also more reader-friendly, it says <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>Ã—</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f \times f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">Ã—</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> sends the "set" of pairs of points in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î±</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">Î±</span></span></span></span> which are close to each other and such that the first point is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> into the "set" of pairs of points in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î²</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">Î²</span></span></span></span> which are close to each other.</p>



<a name="313101719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2317767%20uniform%20continuity%20of%20functions%20in%20C%E2%82%80%28X%2C%20Y%29/near/313101719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html#313101719">(Nov 30 2022 at 16:40)</a>:</h4>
<p>Thanks for the explanation, your statement now looks pretty intuitive to me. I'm wondering whether we could come up with a proof similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/compact_space.uniform_continuous_of_continuous/src">src#compact_space.uniform_continuous_of_continuous</a> simply by calculation using filters.</p>



<a name="315305477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2317767%20uniform%20continuity%20of%20functions%20in%20C%E2%82%80%28X%2C%20Y%29/near/315305477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html#315305477">(Dec 12 2022 at 07:46)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="481963">@David Loeffler</span> for addressing reviews at <a href="https://github.com/leanprover-community/mathlib/pull/17767">#17767</a>; it's now about to be merged. I was busy last week and I also thought about adopting <span class="user-mention" data-user-id="110031">@Patrick Massot</span>'s filter formulation of <code>is_compact.uniform_continuous_at_of_continuous_at</code> above; that's why I took no action on the PR for the whole week.</p>
<p>The filter formulation would be nice if we could stay in the language of filters, but with the current proof it's harder to work with definitionally, so it didn't end up in the PR. I've worked out a proof that uses filters more substantially in <a href="https://gist.github.com/alreadydone/c2dd40c087ccf69de8461eb76d5091b4">this gist</a>, but unfortunately it's longer. However, two lemmas there may still be worth including in mathlib. The first is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_compact.nhds_set_diagonalâ‚</span> <span class="o">{</span><span class="n">Î±</span><span class="o">}</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">ğ“Ë¢</span> <span class="o">((</span><span class="bp">Î»</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">ğ“¤</span> <span class="n">Î±</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ë¢</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="bp">â»Â¹'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(and the version with <code>fst</code> replaced by <code>snd</code>). Notice that the LHS tends to <code>ğ“¤ Î²</code> by continuity, and the RHS is <code>â‰¥ ğ“¤ Î± âŠ“ ğ“Ÿ (prod.fst â»Â¹' s) = ğ“¤ Î± âŠ“ (ğ“Ÿ s Ã—á¶  âŠ¤)</code>, so this is a stronger result than <code>uniform_continuous_at_of_continuous_at</code>.</p>
<p>The second is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">filter.le_of_inf_principal_compl_le</span> <span class="o">{</span><span class="n">fâ‚</span> <span class="n">fâ‚‚</span> <span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fâ‚‚</span> <span class="bp">â‰¤</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">s</span> <span class="bp">âˆˆ</span> <span class="n">fâ‚‚</span><span class="o">,</span> <span class="n">fâ‚</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span><span class="bp">á¶œ</span> <span class="bp">â‰¤</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">fâ‚</span> <span class="bp">â‰¤</span> <span class="n">g</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>which feels like it could be broken down to sublemmas, but I don't see how yet. The statement is a bit weird; for example <code>s âˆˆ fâ‚‚</code> could be replaced by <code>s âˆˆ g</code>.</p>



<a name="315309072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2317767%20uniform%20continuity%20of%20functions%20in%20C%E2%82%80%28X%2C%20Y%29/near/315309072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html#315309072">(Dec 12 2022 at 08:11)</a>:</h4>
<p>I've been resisting the urge to work on this because I have very little time and you already had a more traditional proof. Maybe one day we will have fun refactoring this, but I don't think this should prevent merging the PR.</p>



<a name="315312972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2317767%20uniform%20continuity%20of%20functions%20in%20C%E2%82%80%28X%2C%20Y%29/near/315312972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2317767.20uniform.20continuity.20of.20functions.20in.20C.E2.82.80(X.2C.20Y).html#315312972">(Dec 12 2022 at 08:35)</a>:</h4>
<p>I realized the second lemma above can be simplified to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">filter.le_of_inf_principal_compl_le</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">s</span> <span class="bp">âˆˆ</span> <span class="n">g</span><span class="o">,</span> <span class="n">f</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span><span class="bp">á¶œ</span> <span class="bp">â‰¤</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">â‰¤</span> <span class="n">g</span> <span class="o">:=</span>
</code></pre></div>
<p>and updated <a href="https://gist.github.com/alreadydone/c2dd40c087ccf69de8461eb76d5091b4">the gist</a>. Still find it very curious.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
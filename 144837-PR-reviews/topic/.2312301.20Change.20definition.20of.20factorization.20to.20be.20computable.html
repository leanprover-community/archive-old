---
layout: archive
title: Zulip Chat Archive
permalink: /stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/index.html">PR reviews</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html">#12301 Change definition of factorization to be computable</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="287699524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287699524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287699524">(Jun 28 2022 at 10:55)</a>:</h4>
<p>With permission from <span class="user-mention" data-user-id="282271">@Bolton Bailey</span> I've made progress on this PR so it now passes CI.  This PR changes the definition of <code>n.factorization : ℕ →₀ ℕ</code> to <code>λ p, if p.prime then padic_val_nat p n else 0</code> which is computable, thereby avoiding the noncomputability issues of my original definition.</p>



<a name="287699814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287699814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287699814">(Jun 28 2022 at 10:59)</a>:</h4>
<p>This should make <code>factorization</code> more useful in situations where it previously wasn't, such as in <a href="https://github.com/leanprover-community/mathlib/pull/12254">#12254</a> (which is what <a href="https://github.com/leanprover-community/mathlib/pull/12254#discussion_r814220807">originally prompted</a> this redefinition).</p>



<a name="287701928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287701928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287701928">(Jun 28 2022 at 11:24)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/padic_val_nat">docs#padic_val_nat</a></p>



<a name="287701962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287701962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287701962">(Jun 28 2022 at 11:24)</a>:</h4>
<p><del>the imports for this are outstandingly heavy and essentially makes <code>factorization</code> not usable anywhere</del> I accidentally opened the "imported by" column instead of the "imports" column</p>



<a name="287701997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287701997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287701997">(Jun 28 2022 at 11:25)</a>:</h4>
<p>(deleted)</p>



<a name="287702386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287702386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287702386">(Jun 28 2022 at 11:29)</a>:</h4>
<p>I'm going to have a quick go at making <code>multiset.to_finsupp</code> computable</p>



<a name="287703015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287703015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287703015">(Jun 28 2022 at 11:35)</a>:</h4>
<p>I'm confused by the conversation on <a href="https://github.com/leanprover-community/mathlib/pull/12254">#12254</a></p>



<a name="287703143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287703143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287703143">(Jun 28 2022 at 11:36)</a>:</h4>
<p>If you just want the power of 2 dividing n, you definitely don't want to compute the whole prime factorization of n!</p>



<a name="287703289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287703289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287703289">(Jun 28 2022 at 11:38)</a>:</h4>
<p>Yes, this was the point that Bolton raised <a href="https://github.com/leanprover-community/mathlib/pull/12301#issuecomment-1052654030">in the comments</a> on <a href="https://github.com/leanprover-community/mathlib/pull/12301">#12301</a>.</p>



<a name="287703302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287703302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287703302">(Jun 28 2022 at 11:38)</a>:</h4>
<p>This is one reason I don't like this collective obsession with <code>noncomputable</code>--it encourages a binary viewpoint of computable vs. noncomputable, but if you are actually computing things then algorithms matter</p>



<a name="287705831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287705831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287705831">(Jun 28 2022 at 12:05)</a>:</h4>
<p>for me, it's to make my <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.rec_on_prime_pow">docs#nat.rec_on_prime_pow</a> + co computable; <code>factorisation</code> is only really used in the proofs, so it doesn't even compute anything, but it poisons a completely computable and easy procedure into one that is not</p>



<a name="287706786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287706786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287706786">(Jun 28 2022 at 12:15)</a>:</h4>
<p>I am certainly guilty of not caring about computability.</p>
<p>However I've always imagined that we could have the best of both worlds. E.g., suppose I have some function <code>ℕ → ℕ</code> which has a mathematically-convenient non-computable definition. Suppose further that we might also want this function compute sometimes. Then we would do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">non_computable_def</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">computable_def</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>  <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">computable_eq_non_computable_def</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">computable_def</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">non_computable_def</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="287706927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287706927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287706927">(Jun 28 2022 at 12:16)</a>:</h4>
<p>I assume by "mathematically convenient" you mean "definitionally convenient"?</p>



<a name="287706945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287706945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287706945">(Jun 28 2022 at 12:16)</a>:</h4>
<p>I'd rather not be pinned down on that.</p>



<a name="287706973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287706973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287706973">(Jun 28 2022 at 12:17)</a>:</h4>
<p>Since i'd argue that "mathematical convenience" is "I didn't have to write the longer / more complicated / less clear computable implementation", which ceases to be convenient once you've done it anyway!</p>



<a name="287707180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287707180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287707180">(Jun 28 2022 at 12:19)</a>:</h4>
<p>I think that's what Lean 4 does with the <code>@[csimp]</code> attribute. You write an easy-to-reason implementation and a fast implementation, and tag <code>easy_eq_fast</code> with the <code>@[csimp]</code> attribute. Then Lean uses the fast version for code generation and you can keep proving things using the other version. See, for example, <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/Basic.lean#L58">https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/Basic.lean#L58</a></p>



<a name="287707371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287707371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287707371">(Jun 28 2022 at 12:21)</a>:</h4>
<p>Interesting!</p>



<a name="287707512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287707512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287707512">(Jun 28 2022 at 12:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable/near/287705831">said</a>:</p>
<blockquote>
<p>for me, it's to make my <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.rec_on_prime_pow">docs#nat.rec_on_prime_pow</a> + co computable; <code>factorisation</code> is only really used in the proofs, so it doesn't even compute anything, but it poisons a completely computable and easy procedure into one that is not</p>
</blockquote>
<p>It looks like <code>nat.rec_on_prime_pow</code> should also be using <code>padic_val_nat</code>, and not touch any kind of <code>factorization</code>, for the same reason</p>



<a name="287707595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287707595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287707595">(Jun 28 2022 at 12:23)</a>:</h4>
<p>that's actually the original proof, c.f. <a href="https://github.com/leanprover-community/mathlib/pull/8514">#8514</a></p>



<a name="287707598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287707598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287707598">(Jun 28 2022 at 12:23)</a>:</h4>
<p>I mean <code>nat.rec_on_prime_pow</code> is basically computing the prime factorization anyways, but when you find the smallest prime factor, you don't need to compute the rest of the prime factorization and then throw it away before doing the recursive call</p>



<a name="287754536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287754536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287754536">(Jun 28 2022 at 18:09)</a>:</h4>
<p>Linking for convenience: <a href="https://github.com/leanprover-community/mathlib/pull/12301">#12301</a></p>



<a name="287758986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287758986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287758986">(Jun 28 2022 at 18:45)</a>:</h4>
<p><span class="user-mention" data-user-id="240862">@Oliver Nash</span> My motivation for messing around with the noncomputability checker earlier this year was to be able to use the typeclass system to store those computable definitions and equality lemmas in a way that the definitions are allowed to depend on additional assumptions. Like Reid said, algorithms matter, so you want to take advantage of additional properties your types might have (for example, if you have a computable total order then your finite sets could be stored as binary trees, which have logarithmic membership testing).</p>
<p>Here's a simple example for computing the infimum of a set in <code>nat</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.lattice</span>

<span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_eq</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">export</span> <span class="n">computable</span>

<span class="kd">instance</span> <span class="n">nat.Inf.computable</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">s.nonempty</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">s</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">Inf</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">compute</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">s.nonempty</span> <span class="k">then</span> <span class="n">nat.find</span> <span class="n">h</span> <span class="k">else</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">compute_eq</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">nat.Inf_def</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">congr'</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">convert</span> <span class="n">nat.Inf_empty.symm</span> <span class="n">using</span> <span class="mi">2</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">set.ne_empty_iff_nonempty</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">A</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;=</span> <span class="n">b</span> <span class="k">then</span>
  <span class="n">is_true</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>
<span class="k">else</span>
  <span class="n">is_false</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>

<span class="kd">instance</span> <span class="n">B</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span> <span class="k">then</span>
  <span class="n">is_true</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">)</span>
<span class="k">else</span>
  <span class="n">is_false</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">compute</span> <span class="bp">$</span> <span class="n">Inf</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="mi">2</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">-- 2</span>
</code></pre></div>



<a name="287759126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287759126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287759126">(Jun 28 2022 at 18:46)</a>:</h4>
<p>A problem with Lean 4's <code>csimp</code> attribute is that it's a definition that completely replaces the original one -- you can't use different algorithms that depend on the existence of other algorithms for the given types and values. In other words, this <code>computable</code> class lets you define a patchwork of partially defined algorithms, much like how <code>decidable</code> partially defines a function from expressions in <code>Prop</code> to <code>Bool</code>.</p>



<a name="287759458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287759458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287759458">(Jun 28 2022 at 18:49)</a>:</h4>
<p>With this, you get to define things in a "mathematical convenient" way (meaning, for example, that you don't need artificial decidability assumptions in your definitions), but then you can still compute things for whichever situations you provide algorithms through the typeclass system.</p>



<a name="287759542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/287759542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#287759542">(Jun 28 2022 at 18:50)</a>:</h4>
<p>I've been wanting to introduce this into mathlib, but I haven't found the time to develop it.</p>



<a name="289884501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%2312301%20Change%20definition%20of%20factorization%20to%20be%20computable/near/289884501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/144837-PR-reviews/topic/.2312301.20Change.20definition.20of.20factorization.20to.20be.20computable.html#289884501">(Jul 17 2022 at 13:20)</a>:</h4>
<p><span aria-label="ping pong" class="emoji emoji-1f3d3" role="img" title="ping pong">:ping_pong:</span> The last substantive change to this was almost three weeks ago but it keeps dropping to the bottom of the queue when I resolve merge conflicts.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>